<?xml version="1.0"?>
<doc>
    <assembly>
        "ManagedBridge"
    </assembly>
    <members>
        <member name="P:Microblink.USDLRecognitionResult.Elements">
            <summary>
String -&gt; Object map of result elements. 
</summary>
            <remarks> Result data can
be retrieved from this map instead of using the specific
properties in IRecognitionResult implementing classes.
In the instances when specific property is not implemented
the only way of retrieving the data is via this map.
</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.Empty">
            <summary>
Indicates if the result is empty
</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.Valid">
            <summary>
Indicates if the result is valid
</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.Uncertain">
            <summary>
true if returned data is uncertain.        
</summary>
            <remarks>
Only applicable if used with PDF417RecognizerSettings.UncertainScanMode set to true.
</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.RawData">
            <summary>
Raw barcode data.
</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.StringData">
            <summary>
String representation of data inside barcode.
</summary>
        </member>
        <member name="M:Microblink.USDLRecognitionResult.GetField(System.String)">
            <summary />
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kDataDiscriminator">
            <summary>Optional on compact encoding.

		Document discriminator.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kUniqueCustomerId">
            <summary>Optional on AAMVA version 01.

		A number or alphanumeric string used by some jurisdictions to identify a "customer" across multiple data bases.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kNonResident">
            <summary>Optional on AAMVA version 01.

		Non-Resident Indicator. "Y". Used by some jurisdictions to indicate holder of the document is a non-resident.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kMedicalIndicator">
            <summary>Optional on AAMVA version 01.

		Medical Indicator/Codes.
		STATE SPECIFIC. Freeform; Standard "TBD"</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kHAZMATExpirationDate">
            <summary>Optional on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

		Date on which the hazardous material endorsement granted by the document is
		no longer valid. (MMDDCCYY format)</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kComplianceType">
            <summary>Optional on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

		DHS required field that indicates compliance: "M" = materially compliant;
		"F" = fully compliant; and, "N" = non-compliant.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAuditInformation">
            <summary>Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		A string of letters and/or numbers that identifies when, where, and by whom a driver
		license/ID card was made.</summary>
            <remarks>If audit information is not used on the card or the MRT, it
		must be included in the driver record.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kNumberOfDuplicates">
            <summary>Optional on AAMVA version 01.

		Number of duplicate cards issued for a license or ID if any.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kPermitIssueDate">
            <summary>Optional on AAMVA version 01.

		Driver Permit Issue Date. MMDDCCYY format. Date permit was issued.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kPermitIdentifier">
            <summary>Optional on AAMVA version 01.

		Type of permit.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kPermitExpirationDate">
            <summary>Optional on AAMVA version 01.

		Driver Permit Expiration Date. MMDDCCYY format. Date permit expires.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kIssueTimestamp">
            <summary>Optional on AAMVA version 01.

		Issue Timestamp. A string used by some jurisdictions to validate the document against their data base.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kLimitedDurationDocument">
            <summary>Optional on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

		DHS required field that indicates that the cardholder has temporary lawful status = "1".</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kDocumentDiscriminator">
            <summary>Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding</summary>
            <remarks>Number must uniquely identify a particular document issued to that customer
		from others that may have been issued in the past. This number may serve multiple
		purposes of document discrimination, audit information number, and/or inventory control.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kCardRevisionDate">
            <summary>Optional on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

		DHS required field that indicates date of the most recent version change or
		modification to the visible format of the DL/ID (MMDDCCYY format)</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kInventoryControlNumber">
            <summary>Optional on AAMVA 02, 03, 04, 05, 06, 07, 08

		A string of letters and/or numbers that is affixed to the raw materials (card stock,
		laminate, etc.) used in producing driver licenses and ID cards. (DHS recommended field)</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kJurisdictionRestrictionCodeDescription">
            <summary>Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Text describing the jurisdiction-specific restriction code(s) that curtail driving privileges.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kJurisdictionEndorsmentCodeDescription">
            <summary>Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Text that explains the jurisdiction-specific code(s) that indicates additional
		driving privileges granted to the cardholder beyond the vehicle class.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kJurisdictionVehicleClassificationDescription">
            <summary>Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Text that explains the jurisdiction-specific code(s) for classifications
		of vehicles cardholder is authorized to drive.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kBiometricData">
            <summary>Optional on compact encodings.

		Biometric data block</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kBiometricDataLength">
            <summary>Optional on compact encodings.

		Biometric data block length</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kBDBFormatType">
            <summary>Optional on compact encodings.

		BDB format type</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kBDBFormatOwner">
            <summary>Optional on compact encodings.

		BDB format owner</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kPortraitImage">
            <summary>Optional on compact encoding.

		Portrait image</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kImageType">
            <summary>Optional on compact encoding.

		Type of image</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kImageTimestamp">
            <summary>Optional on compact encoding.

		Portrait image timestamp</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAKADateOfBirth">
            <summary>Optional on AAMVA 01. (MMDDCCYY format)

		ALTERNATIVE DATES(S) given as date of birth.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kVeteran">
            <summary>Optional on AAMVA 07, 08

		Field that indicates that the cardholder is a veteran = "1"</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kOrganDonor">
            <summary>Optional on AAMVA 06, 07, 08

		Field that indicates that the cardholder is an organ donor = "1".</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAKASuffixName">
            <summary>Optional on AAMVA 01, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Other suffix by which cardholder is known.</summary>
            <remarks>The Suffix Code Portion, if submitted, can contain only the Suffix Codes shown in the following table (e.g., Andrew Johnson, III = JOHNSON@ANDREW@@3RD):

		Suffix     Meaning or Synonym
		JR         Junior
		SR         Senior or Esquire 1ST First
		2ND        Second
		3RD        Third
		4TH        Fourth
		5TH        Fifth
		6TH        Sixth
		7TH        Seventh
		8TH        Eighth
		9TH        Ninth</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAKAPrefixName">
            <summary>Optional on AAMVA 01

		ALTERNATIVE PREFIX to Driver Name. Freeform as defined by issuing jurisdiction.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAKAGivenName">
            <summary>Optional on AAMVA 01, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Other given name by which cardholder is known</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAKAFamilyName">
            <summary>Optional on AAMVA 01, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Other family name by which cardholder is known.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAKAFullName">
            <summary>Optional on AAMVA version 01, 02

		Other name by which cardholder is known.</summary>
            <remarks>ALTERNATIVE NAME(S) of the individual holding
		the Driver License or ID. FORMAT same as defined in ANSI D20 Data Dictionary.
		(Lastname@Firstname@MI@ suffix if any.)

		(Machine, Mag Stripe uses ‘$’ and Bar Code uses ‘,’ in place of ‘@’)
		Firstname, Middle Initial, Lastname (Human)

		The Name field contains four portions, separated with the "@" delimiter: Last Name (required)
		@ (required)
		First Name (required)
		@ (required if other name portions follow, otherwise optional)
		Middle Name(s) (optional)
		@ (required if other name portions follow, otherwise optional)
		Suffix Code (optional)
		@ (optional)</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAKASocialSecurityNumber">
            <summary>Optional on AAMVA version 01.

		Driver "AKA" Social Security Number. FORMAT SAME AS DRIVER SOC SEC NUM. ALTERNATIVE NUMBERS(S) used as SS NUM.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kSocialSecurityNumber">
            <summary>Optional on AAMVA version 01.

		The number assigned to an individual by the Social Security Administration.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kUnder21">
            <summary>Optional on AAMVA 05, 06, 07, 08

		Date on which the cardholder turns 21 years old. (MMDDCCYY format)</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kUnder19">
            <summary>Optional on AAMVA 05, 06, 07, 08

		Date on which the cardholder turns 19 years old. (MMDDCCYY format)</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kUnder18">
            <summary>Optional on AAMVA 05, 06, 07, 08

		Date on which the cardholder turns 18 years old. (MMDDCCYY format)</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kHeightCm">
            <summary>Optional on AAMVA 01
		Mandatory on Compact encoding

		HEIGHT in CENTIMETERS</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kHeightIn">
            <summary>Optional on AAMVA 01

		Height (FT/IN)</summary>
            <remarks>FEET (1st char); Inches (2nd and 3rd char).
		Ex. 509 = 5 ft., 9 in.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kResidencePostalCode">
            <summary>Optional on AAMVA version 01.

		Driver Residence Postal Code.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kResidenceJurisdictionCode">
            <summary>Optional on AAMVA version 01.

		Driver Residence Jurisdiction Code.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kResidenceCity">
            <summary>Optional on AAMVA version 01.

		Driver Residence City</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kResidenceStreetAddress2">
            <summary>Optional on AAMVA version 01.

		Driver Residence Street Address 2.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kResidenceStreetAddress">
            <summary>Optional on AAMVA version 01.

		Driver Residence Street Address 1.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kCountryIdentification">
            <summary>Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Country in which DL/ID is issued. U.S. = USA, Canada = CAN.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kNamePrefix">
            <summary>Optional on AAMVA 01

		PREFIX to Driver Name. Freeform as defined by issuing jurisdiction.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kRaceEthnicity">
            <summary>Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Codes for race or ethnicity of the cardholder, as defined in ANSI D20.</summary>
            <remarks>Race:
		Code   Description
		AI     Alaskan or American Indian (Having Origins in Any of The Original Peoples of
		North America, and Maintaining Cultural Identification Through Tribal
		Affiliation of Community Recognition)
		AP     Asian or Pacific Islander (Having Origins in Any of the Original Peoples of
		the Far East, Southeast Asia, or Pacific Islands. This Includes China, India,
		Japan, Korea, the Philippines Islands, and Samoa)
		BK     Black (Having Origins in Any of the Black Racial Groups of Africa)
		W      White (Having Origins in Any of The Original Peoples of Europe, North Africa,
		or the Middle East)

		Ethnicity:
		Code   Description
		H      Hispanic Origin (A Person of Mexican, Puerto Rican, Cuban, Central or South
		American or Other Spanish Culture or Origin, Regardless of Race)
		O      Not of Hispanic Origin (Any Person Other Than Hispanic)
		U      Unknown
		</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kWeightKilograms">
            <summary>Optional on AAMVA 01, 04, 05, 06, 07, 08 and Compact Encoding

		Cardholder weight in kilograms Ex. 84 kg = "084"</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kWeightPounds">
            <summary>Optional on AAMVA 01, 04, 05, 06, 07, 08

		Cardholder weight in pounds Ex. 185 lb = "185"</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kWeightRange">
            <summary>Optional on AAMVA 02, 03, 04, 05, 06, 07, 08

		Indicates the approximate weight range of the cardholder:
		0 = up to 31 kg (up to 70 lbs)
		1 = 32 – 45 kg (71 – 100 lbs)
		2 = 46 - 59 kg (101 – 130 lbs)
		3 = 60 - 70 kg (131 – 160 lbs)
		4 = 71 - 86 kg (161 – 190 lbs)
		5 = 87 - 100 kg (191 – 220 lbs)
		6 = 101 - 113 kg (221 – 250 lbs)
		7 = 114 - 127 kg (251 – 280 lbs)
		8 = 128 – 145 kg (281 – 320 lbs)
		9 = 146+ kg (321+ lbs)</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kPlaceOfBirth">
            <summary>Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Country and municipality and/or state/province</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kSecurityVersion">
            <summary>Mandatory on AMMVA Magnetic Stripe Encoding

		Security version beeing used.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kFederalCommercialVehicleCodes">
            <summary>Mandatory on AAMVA versions 02 and 03.

		Federally established codes for vehicle categories, endorsements, and restrictions
		that are generally applicable to commercial motor vehicles. If the vehicle is not a
		commercial vehicle, "NONE" is to be entered.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kMiddleNameTruncation">
            <summary>Mandatory on AAMVA 04, 05, 06, 07, 08

		A code that indicates whether a field has been truncated (T), has not been
		truncated (N), or – unknown whether truncated (U).</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kFirstNameTruncation">
            <summary>Mandatory on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

		A code that indicates whether a field has been truncated (T), has not been
		truncated (N), or – unknown whether truncated (U).</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kFamilyNameTruncation">
            <summary>Mandatory on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

		A code that indicates whether a field has been truncated (T), has not been
		truncated (N), or – unknown whether truncated (U).</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kFullAddress">
            <summary>Mandatory on compact encoding.

		Cardholder address.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kCustomerFullName">
            <summary>Mandatory on AAMVA 01

		NAME of the individual holding the Driver License or ID as defined in
		ANSI D20 Data Dictionary. (Lastname@Firstname@MI@ suffix if any)</summary>
            <remarks>
		(Machine, Mag Stripe uses ‘$’ and Bar Code uses ‘,’ in place of ‘@’)
		Firstname, Middle Initial, Lastname (Human)

		The Name field contains four portions, separated with the "@" delimiter: Last Name (required)
		@ (required)
		First Name (required)
		@ (required if other name portions follow, otherwise optional)
		Middle Name(s) (optional)
		@ (required if other name portions follow, otherwise optional)
		Suffix Code (optional)
		@ (optional)</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kHeight">
            <summary>Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08

		Height of cardholder.</summary>
            <remarks>
		Inches (in): number of inches followed by " in"
		example. 6'1'' = "073 in"

		Centimeters (cm): number of centimeters followed by " cm"
		example. 181 centimeters="181 cm"</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kCustomerMiddleName">
            <summary>Mandatory on AAMVA 04, 05, 06, 07, 08

		Optional on 01.

		Middle name(s) of the cardholder.</summary>
            <remarks>In the case of multiple middle names they
		shall be separated by a comma ",".</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kStandardRestrictionCode">
            <summary>Optional on AAMVA 01, 02, 03, 04, 05, 06, 07 and 08

		Standard restriction code(s) for cardholder.</summary>
            <remarks> See codes in D20. This data element is a placeholder
		for future efforts to standardize restriction codes.

		Code   Description
		B      Corrective Lenses
		C      Mechanical Devices (Special Brakes, Hand Controls, or Other Adaptive Devices)
		D      Prosthetic Aid
		E      Automatic Transmission
		F      Outside Mirror
		G      Limit to Daylight Only
		H      Limit to Employment
		I      Limited Other
		J      Other
		K      CDL Intrastate Only
		L      Vehicles without air brakes
		M      Except Class A bus
		N      Except Class A and Class B bus
		O      Except Tractor-Trailer
		V      Medical Variance Documentation Required
		W      Farm Waiver</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kStandardEndorsementCode">
            <summary>Optional on AAMVA 01, 02, 03, 04, 05, 06, 07 and 08

		Standard endorsement code(s) for cardholder.</summary>
            <remarks> See codes in D20. This data element is a
		placeholder for future efforts to standardize endorsement codes.

		Code   Description
		H      Hazardous Material - This endorsement is required for the operation of any vehicle
		transporting hazardous materials requiring placarding, as defined by U.S.
		Department of Transportation regulations.
		L      Motorcycles – Including Mopeds/Motorized Bicycles.
		N      Tank - This endorsement is required for the operation of any vehicle transporting,
		as its primary cargo, any liquid or gaseous material within a tank attached to the vehicle.
		O      Other Jurisdiction Specific Endorsement(s) - This code indicates one or more
		additional jurisdiction assigned endorsements.
		P      Passenger - This endorsement is required for the operation of any vehicle used for
		transportation of sixteen or more occupants, including the driver.
		S      School Bus - This endorsement is required for the operation of a school bus. School bus means a
		CMV used to transport pre-primary, primary, or secondary school students from home to school,
		from school to home, or to and from school sponsored events. School bus does not include a
		bus used as common carrier (49 CRF 383.5).
		T      Doubles/Triples - This endorsement is required for the operation of any vehicle that would be
		referred to as a double or triple.
		X      Combined Tank/HAZ-MAT - This endorsement may be issued to any driver who qualifies for
		both the N and H endorsements.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kStandardVehicleClassification">
            <summary>Optional on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Standard vehicle classification code(s) for cardholder.</summary>
            <remarks> This data element is a
		placeholder for future efforts to standardize vehicle classifications.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kIssuingJurisdiction">
            <summary>Optional on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

		Mandatory on Compact Encoding</summary>
            <remarks>
		Jurisdictions may define a subfile to contain jurisdiction-specific information.
		These subfiles are designated with the first character of “Z” and the second
		character is the first letter of the jurisdiction's name. For example, "ZC" would
		be the designator for a California or Colorado jurisdiction-defined subfile; "ZQ"
		would be the designator for a Quebec jurisdiction-defined subfile. In the case of
		a jurisdiction-defined subfile that has a first letter that could be more than
		one jurisdiction (e.g. California, Colorado, Connecticut) then other data, like
		the IIN or address, must be examined to determine the jurisdiction.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAddressStreet2">
            <summary>Optional on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

		On Compact encoding, use kFullAddress

		Second line of street portion of the cardholder address.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kHairColor">
            <summary>Optional on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Bald, black, blonde, brown, gray, red/auburn, sandy, white, unknown.</summary>
            <remarks>If the issuing
		jurisdiction wishes to abbreviate colors, the three-character codes provided in ANSI D20 must be
		used.

		Code   Description
		BAL    Bald
		BLK    Black
		BLN    Blond
		BRO    Brown
		GRY    Grey
		RED    Red/Auburn
		SDY    Sandy
		WHI    White
		UNK    Unknown</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kCustomerIdNumber">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		The number assigned or calculated by the issuing authority.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kJurisdictionEndorsementCodes">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

		Jurisdiction-specific codes that represent additional privileges
		granted to the cardholder beyond the vehicle class (such as transportation of
		passengers, hazardous materials, operation of motorcycles, etc.).</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kJurisdictionRestrictionCodes">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

		Jurisdiction-specific codes that represent restrictions to driving
		privileges (such as airbrakes, automatic transmission, daylight only, etc.).</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kJurisdictionVehicleClass">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

		Jurisdiction-specific vehicle class / group code</summary>
            <remarks> designating the type
		of vehicle the cardholder has privilege to drive.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kJurisdictionVersionNumber">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Jurisdiction Version Number</summary>
            <remarks>This is a decimal value between 00 and 99 that
		specifies the jurisdiction version level of the PDF417 bar code format.
		Notwithstanding iterations of this standard, jurisdictions implement incremental
		changes to their bar codes, including new jurisdiction-specific data, compression
		algorithms for digitized images, digital signatures, or new truncation
		conventions used for names and addresses. Each change to the bar code format
		within each AAMVA version (above) must be noted, beginning with Jurisdiction
		Version 00.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kDocumentNonexpiring">
            <summary>Optional on AAMVA Magnetic Stripe Encoding

		Field that indicates that the driving and identification privileges granted by the
		document are nonexpiring = "1".</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kDocumentExpirationMonth">
            <summary>Optional on AAMVA Magnetic Stripe Encoding

		Date on which the driving and identification privileges granted by the document are
		no longer valid. (MMYY format)</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kDocumentExpirationDate">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Date on which the driving and identification privileges granted by the document are
		no longer valid. (MMDDCCYY format)</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kDocumentIssueDate">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

		Date on which the document was issued. (MMDDCCYY format)</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kIssuerIdentificationNumber">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08
		Optional on Compact encoding</summary>
            <remarks>This number uniquely identifies the issuing jurisdiction and can
		be obtained by contacting the ISO Issuing Authority (AAMVA)</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAddressPostalCode">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

		On compact encoding, use kFullAddress.</summary>
            <remarks>Postal code portion of the cardholder address in the U.S. and Canada. If the
		trailing portion of the postal code in the U.S. is not known, zeros will be used
		to fill the trailing set of numbers up to nine (9) digits.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAddressJurisdictionCode">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

		On compact encoding, use kFullAddress.</summary>
            <remarks>State portion of the cardholder address.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAddressCity">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

		On compact encoding, use kFullAddress.</summary>
            <remarks>City portion of the cardholder address.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAddressStreet">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

		On compact encoding, use kFullAddress.</summary>
            <remarks>Street portion of the cardholder address.
		The place where the registered driver of a vehicle (individual or corporation) may be contacted such as a house number, street address etc.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kEyeColor">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact encoding

		Color of cardholder's eyes.</summary>
            <remarks>(ANSI D-20 codes)

		Code   Description
		BLK    Black
		BLU    Blue
		BRO    Brown
		GRY    Gray
		GRN    Green
		HAZ    Hazel
		MAR    Maroon
		PNK    Pink
		DIC    Dichromatic
		UNK    Unknown</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kSex">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact encoding

		Gender of the cardholder. 1 = male, 2 = female.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kDateOfBirth">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact encoding

		Date on which the cardholder was born. (MMDDCCYY format)</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kCustomerFirstName">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact encoding

		First name of the cardholder.</summary>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kCustomerFamilyName">
            <summary>Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 AND compact encoding.

		Family name of the cardholder.</summary>
            <remarks>(Family name is sometimes also called "last name" or "surname.")
		Collect full name for record, print as many characters as possible on portrait side of DL/ID.</remarks>
        </member>
        <member name="P:Microblink.USDLRecognitionResult.kAamvaVersionNumber">
            <summary>Mandatory on all AAMVA driver's license versions.
		
		AAMVA Version Number.</summary>
            <remarks>This is a decimal value between 00 and 99 that
		specifies the version level of the PDF417 bar code format. Version "0" and "00"
		is reserved for bar codes printed to the specification of the American Association
		of Motor Vehicle Administrators (AAMVA) prior to the adoption of the AAMVA DL/ID-2000
		standard. All bar codes compliant with the AAMVA DL/ID-2000 standard are designated
		Version "01." All barcodes compliant with AAMVA Card Design Specification version
		1.0, dated 09-2003 shall be designated Version "02." All barcodes compliant with
		AAMVA Card Design Specification version 2.0, dated 03-2005 shall be designated
		Version "03." All barcodes compliant with AAMVA Card Design Standard version 1.0,
		dated 07-2009 shall be designated Version "04." All barcodes compliant with AAMVA
		Card Design Standard version 1.0, dated 07-2010 shall be designated Version "05."
		All barcodes compliant with AAMVA Card Design Standard version 1.0, dated 07- 2011
		shall be designated Version "06". All barcodes compliant with AAMVA Card Design
		Standard version 1.0, dated 06-2012 shall be designated Version "07". All barcodes
		compliant with this current AAMVA standard shall be designated "08". Should a need
		arise requiring major revision to the format, this field provides the means to
		accommodate additional revision. "Compact" when Compact encoding is used.</remarks>
        </member>
        <member name="T:Microblink.USDLRecognitionResult">
            <summary>
US driver's license recognition result
</summary>
        </member>
        <member name="M:photopay.DLRecognizer.setAutoScaleDetection(System.Boolean)">
Enables detecting the scale of the image before trying to read code29 and code 128 barcodes
@param autoScale

</member>
        <member name="M:photopay.DLRecognizer.setUseTryHarder(System.Boolean)">
Enables to spent more time trying to read code39 and code128 barcodes
@param tryHarder

</member>
        <member name="M:photopay.DLRecognizer.setAllowNullQuietZone(System.Boolean)">
Enables decoding of barcodes without quiet zone round the barcode
(e.g. text concatenated with barcode blocks)
@param allowNullQuietZone

</member>
        <member name="M:photopay.DLRecognizer.setUseUncertainDecoding(System.Boolean)">
Enables decoding of barcodes where multiple rows are missing from the end of the barcode
(e.g. when more lines at the end of barcode are not printed, and there is not enough
error correction codewords left to compensate for missing rows)
@param useUncertainDecoding

</member>
        <member name="M:photopay.DLRecognizer.resetResults">
Resets the best results in the whole chain
and clears history

</member>
        <member name="M:photopay.DLRecognizer.recognize(photopay.RecognitionContext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
     * Method fills the recognition result object with
     * payment data recognized from given image

     * Returns true if scanning was successful, false otherwise

</member>
        <member name="F:photopay.Keys.kDataDiscriminator">
Optional on compact encoding.

Document discriminator.

</member>
        <member name="F:photopay.Keys.kUniqueCustomerId">
Optional on AAMVA version 01.

A number or alphanumeric string used by some jurisdictions to identify a "customer" across multiple data bases.

</member>
        <member name="F:photopay.Keys.kNonResident">
Optional on AAMVA version 01.

Non-Resident Indicator. "Y". Used by some jurisdictions to indicate holder of the document is a non-resident.

</member>
        <member name="F:photopay.Keys.kMedicalIndicator">
Optional on AAMVA version 01.

Medical Indicator/Codes.
STATE SPECIFIC. Freeform; Standard "TBD"

</member>
        <member name="F:photopay.Keys.kHAZMATExpirationDate">
Optional on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

Date on which the hazardous material endorsement granted by the document is
no longer valid. (MMDDCCYY format)

</member>
        <member name="F:photopay.Keys.kComplianceType">
Optional on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

DHS required field that indicates compliance: "M" = materially compliant;
"F" = fully compliant; and, "N" = non-compliant.

</member>
        <member name="F:photopay.Keys.kAuditInformation">
Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

A string of letters and/or numbers that identifies when, where, and by whom a driver
license/ID card was made. If audit information is not used on the card or the MRT, it
must be included in the driver record.

</member>
        <member name="F:photopay.Keys.kNumberOfDuplicates">
Optional on AAMVA version 01.

Number of duplicate cards issued for a license or ID if any.

</member>
        <member name="F:photopay.Keys.kPermitIssueDate">
Optional on AAMVA version 01.

Driver Permit Issue Date. MMDDCCYY format. Date permit was issued.

</member>
        <member name="F:photopay.Keys.kPermitIdentifier">
Optional on AAMVA version 01.

Type of permit.

</member>
        <member name="F:photopay.Keys.kPermitExpirationDate">
Optional on AAMVA version 01.

Driver Permit Expiration Date. MMDDCCYY format. Date permit expires.

</member>
        <member name="F:photopay.Keys.kIssueTimestamp">
Optional on AAMVA version 01.

Issue Timestamp. A string used by some jurisdictions to validate the document against their data base.

</member>
        <member name="F:photopay.Keys.kLimitedDurationDocument">
Optional on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

DHS required field that indicates that the cardholder has temporary lawful status = "1".

</member>
        <member name="F:photopay.Keys.kDocumentDiscriminator">
Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Number must uniquely identify a particular document issued to that customer
from others that may have been issued in the past. This number may serve multiple
purposes of document discrimination, audit information number, and/or inventory control.

</member>
        <member name="F:photopay.Keys.kCardRevisionDate">
Optional on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

DHS required field that indicates date of the most recent version change or
modification to the visible format of the DL/ID (MMDDCCYY format)

</member>
        <member name="F:photopay.Keys.kInventoryControlNumber">
Optional on AAMVA 02, 03, 04, 05, 06, 07, 08

A string of letters and/or numbers that is affixed to the raw materials (card stock,
laminate, etc.) used in producing driver licenses and ID cards. (DHS recommended field)

</member>
        <member name="F:photopay.Keys.kJurisdictionRestrictionCodeDescription">
Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Text describing the jurisdiction-specific restriction code(s) that curtail driving privileges.

</member>
        <member name="F:photopay.Keys.kJurisdictionEndorsmentCodeDescription">
Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Text that explains the jurisdiction-specific code(s) that indicates additional
driving privileges granted to the cardholder beyond the vehicle class.

</member>
        <member name="F:photopay.Keys.kJurisdictionVehicleClassificationDescription">
Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Text that explains the jurisdiction-specific code(s) for classifications
of vehicles cardholder is authorized to drive.

</member>
        <member name="F:photopay.Keys.kBiometricData">
Optional on compact encodings.

Biometric data block

</member>
        <member name="F:photopay.Keys.kBiometricDataLength">
Optional on compact encodings.

Biometric data block length

</member>
        <member name="F:photopay.Keys.kBDBFormatType">
Optional on compact encodings.

BDB format type

</member>
        <member name="F:photopay.Keys.kBDBFormatOwner">
Optional on compact encodings.

BDB format owner

</member>
        <member name="F:photopay.Keys.kPortraitImage">
Optional on compact encoding.

Portrait image

</member>
        <member name="F:photopay.Keys.kImageType">
Optional on compact encoding.

Type of image

</member>
        <member name="F:photopay.Keys.kImageTimestamp">
Optional on compact encoding.

Portrait image timestamp

</member>
        <member name="F:photopay.Keys.kAKADateOfBirth">
Optional on AAMVA 01. (MMDDCCYY format)

ALTERNATIVE DATES(S) given as date of birth.

</member>
        <member name="F:photopay.Keys.kVeteran">
Optional on AAMVA 07, 08

Field that indicates that the cardholder is a veteran = "1"

</member>
        <member name="F:photopay.Keys.kOrganDonor">
Optional on AAMVA 06, 07, 08

Field that indicates that the cardholder is an organ donor = "1".

</member>
        <member name="F:photopay.Keys.kAKASuffixName">
Optional on AAMVA 01, 03, 04, 05, 06, 07, 08 and Compact Encoding

Other suffix by which cardholder is known.

The Suffix Code Portion, if submitted, can contain only the Suffix Codes shown in the following table (e.g., Andrew Johnson, III = JOHNSON@ANDREW@@3RD):

Suffix     Meaning or Synonym
JR         Junior
SR         Senior or Esquire 1ST First
2ND        Second
3RD        Third
4TH        Fourth
5TH        Fifth
6TH        Sixth
7TH        Seventh
8TH        Eighth
9TH        Ninth

</member>
        <member name="F:photopay.Keys.kAKAPrefixName">
Optional on AAMVA 01

ALTERNATIVE PREFIX to Driver Name. Freeform as defined by issuing jurisdiction.

</member>
        <member name="F:photopay.Keys.kAKAGivenName">
Optional on AAMVA 01, 03, 04, 05, 06, 07, 08 and Compact Encoding

Other given name by which cardholder is known

</member>
        <member name="F:photopay.Keys.kAKAMiddleName">
Optional on AAMVA 01

ALTERNATIVE MIDDLE NAME(s) or INITIALS of the individual holding the Driver License or ID.
Hyphenated names acceptable, spaces between names acceptable, but no other
use of special symbols

</member>
        <member name="F:photopay.Keys.kAKAFamilyName">
Optional on AAMVA 01, 03, 04, 05, 06, 07, 08 and Compact Encoding

Other family name by which cardholder is known.

</member>
        <member name="F:photopay.Keys.kAKAFullName">
Optional on AAMVA version 01, 02

Other name by which cardholder is known. ALTERNATIVE NAME(S) of the individual holding
the Driver License or ID. FORMAT same as defined in ANSI D20 Data Dictionary.
(Lastname@Firstname@MI@ suffix if any.)

(Machine, Mag Stripe uses â€$â€™ and Bar Code uses â€,â€™ in place of â€@â€™)
Firstname, Middle Initial, Lastname (Human)

The Name field contains four portions, separated with the "@" delimiter: Last Name (required)
@ (required)
First Name (required)
@ (required if other name portions follow, otherwise optional)
Middle Name(s) (optional)
@ (required if other name portions follow, otherwise optional)
Suffix Code (optional)
@ (optional)

</member>
        <member name="F:photopay.Keys.kAKASocialSecurityNumber">
Optional on AAMVA version 01.

Driver "AKA" Social Security Number. FORMAT SAME AS DRIVER SOC SEC NUM. ALTERNATIVE NUMBERS(S) used as SS NUM.

</member>
        <member name="F:photopay.Keys.kSocialSecurityNumber">
Optional on AAMVA version 01.

The number assigned to an individual by the Social Security Administration.

</member>
        <member name="F:photopay.Keys.kUnder21">
Optional on AAMVA 05, 06, 07, 08

Date on which the cardholder turns 21 years old. (MMDDCCYY format)

</member>
        <member name="F:photopay.Keys.kUnder19">
Optional on AAMVA 05, 06, 07, 08

Date on which the cardholder turns 19 years old. (MMDDCCYY format)

</member>
        <member name="F:photopay.Keys.kUnder18">
Optional on AAMVA 05, 06, 07, 08

Date on which the cardholder turns 18 years old. (MMDDCCYY format)

</member>
        <member name="F:photopay.Keys.kHeightCm">
Optional on AAMVA 01
Mandatory on Compact encoding

HEIGHT in CENTIMETERS

</member>
        <member name="F:photopay.Keys.kHeightIn">
Optional on AAMVA 01

Height (FT/IN)

FEET (1st char); Inches (2nd and 3rd char).
Ex. 509 = 5 ft., 9 in.

</member>
        <member name="F:photopay.Keys.kResidencePostalCode">
Optional on AAMVA version 01.

Driver Residence Postal Code.

</member>
        <member name="F:photopay.Keys.kResidenceJurisdictionCode">
Optional on AAMVA version 01.

Driver Residence Jurisdiction Code.

</member>
        <member name="F:photopay.Keys.kResidenceCity">
Optional on AAMVA version 01.

Driver Residence City

</member>
        <member name="F:photopay.Keys.kResidenceStreetAddress2">
Optional on AAMVA version 01.

Driver Residence Street Address 2.

</member>
        <member name="F:photopay.Keys.kResidenceStreetAddress">
Optional on AAMVA version 01.

Driver Residence Street Address 1.

</member>
        <member name="F:photopay.Keys.kCountryIdentification">
Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Country in which DL/ID is issued. U.S. = USA, Canada = CAN.

</member>
        <member name="F:photopay.Keys.kNamePrefix">
Optional on AAMVA 01

PREFIX to Driver Name. Freeform as defined by issuing jurisdiction.

</member>
        <member name="F:photopay.Keys.kRaceEthnicity">
Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Codes for race or ethnicity of the cardholder, as defined in ANSI D20.

Race:
Code   Description
AI     Alaskan or American Indian (Having Origins in Any of The Original Peoples of
North America, and Maintaining Cultural Identification Through Tribal
Affiliation of Community Recognition)
AP     Asian or Pacific Islander (Having Origins in Any of the Original Peoples of
the Far East, Southeast Asia, or Pacific Islands. This Includes China, India,
Japan, Korea, the Philippines Islands, and Samoa)
BK     Black (Having Origins in Any of the Black Racial Groups of Africa)
W      White (Having Origins in Any of The Original Peoples of Europe, North Africa,
or the Middle East)

Ethnicity:
Code   Description
H      Hispanic Origin (A Person of Mexican, Puerto Rican, Cuban, Central or South
American or Other Spanish Culture or Origin, Regardless of Race)
O      Not of Hispanic Origin (Any Person Other Than Hispanic) U Unknown


</member>
        <member name="F:photopay.Keys.kWeightKilograms">
Optional on AAMVA 01, 04, 05, 06, 07, 08 and Compact Encoding

Cardholder weight in kilograms Ex. 84 kg = "084"

</member>
        <member name="F:photopay.Keys.kWeightPounds">
Optional on AAMVA 01, 04, 05, 06, 07, 08

Cardholder weight in pounds Ex. 185 lb = "185"

</member>
        <member name="F:photopay.Keys.kWeightRange">
Optional on AAMVA 02, 03, 04, 05, 06, 07, 08

Indicates the approximate weight range of the cardholder:
0 = up to 31 kg (up to 70 lbs)
1 = 32 â€“ 45 kg (71 â€“ 100 lbs)
2 = 46 - 59 kg (101 â€“ 130 lbs)
3 = 60 - 70 kg (131 â€“ 160 lbs)
4 = 71 - 86 kg (161 â€“ 190 lbs)
5 = 87 - 100 kg (191 â€“ 220 lbs)
6 = 101 - 113 kg (221 â€“ 250 lbs)
7 = 114 - 127 kg (251 â€“ 280 lbs)
8 = 128 â€“ 145 kg (281 â€“ 320 lbs)
9 = 146+ kg (321+ lbs)

</member>
        <member name="F:photopay.Keys.kPlaceOfBirth">
Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Country and municipality and/or state/province

</member>
        <member name="F:photopay.Keys.kSecurityVersion">
      Mandatory on AMMVA Magnetic Stripe Encoding

      Security version beeing used.

</member>
        <member name="F:photopay.Keys.kFederalCommercialVehicleCodes">
Mandatory on AAMVA versions 02 and 03.

Federally established codes for vehicle categories, endorsements, and restrictions
that are generally applicable to commercial motor vehicles. If the vehicle is not a
commercial vehicle, "NONE" is to be entered.

</member>
        <member name="F:photopay.Keys.kMiddleNameTruncation">
Mandatory on AAMVA 04, 05, 06, 07, 08

A code that indicates whether a field has been truncated (T), has not been
truncated (N), or â€“ unknown whether truncated (U).

</member>
        <member name="F:photopay.Keys.kFirstNameTruncation">
Mandatory on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

A code that indicates whether a field has been truncated (T), has not been
truncated (N), or â€“ unknown whether truncated (U).

</member>
        <member name="F:photopay.Keys.kFamilyNameTruncation">
Mandatory on AAMVA 04, 05, 06, 07, 08 and Compact Encoding

A code that indicates whether a field has been truncated (T), has not been
truncated (N), or â€“ unknown whether truncated (U).

</member>
        <member name="F:photopay.Keys.kFullAddress">
Mandatory on compact encoding.

Cardholder address.

</member>
        <member name="F:photopay.Keys.kCustomerFullName">
Mandatory on AAMVA 01

NAME of the individual holding the Driver License or ID as defined in
ANSI D20 Data Dictionary. (Lastname@Firstname@MI@ suffix if any)

(Machine, Mag Stripe uses â€$â€™ and Bar Code uses â€,â€™ in place of â€@â€™)
Firstname, Middle Initial, Lastname (Human)

The Name field contains four portions, separated with the "@" delimiter: Last Name (required)
@ (required)
First Name (required)
@ (required if other name portions follow, otherwise optional)
Middle Name(s) (optional)
@ (required if other name portions follow, otherwise optional)
Suffix Code (optional)
@ (optional)

</member>
        <member name="F:photopay.Keys.kHeight">
Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08

Height of cardholder.

Inches (in): number of inches followed by " in"
example. 6'1'' = "073 in"

Centimeters (cm): number of centimeters followed by " cm"
example. 181 centimeters="181 cm"

</member>
        <member name="F:photopay.Keys.kCustomerMiddleName">
Mandatory on AAMVA 04, 05, 06, 07, 08

Optional on 01.

Middle name(s) of the cardholder. In the case of multiple middle names they
shall be separated by a comma ",".

</member>
        <member name="F:photopay.Keys.kStandardRestrictionCode">
Optional on AAMVA 01, 02, 03, 04, 05, 06, 07 and 08

Standard restriction code(s) for cardholder. See codes in D20. This data element is a placeholder
for future efforts to standardize restriction codes.

Code   Description
B      Corrective Lenses
C      Mechanical Devices (Special Brakes, Hand Controls, or Other Adaptive Devices)
D      Prosthetic Aid
E      Automatic Transmission
F      Outside Mirror
G      Limit to Daylight Only
H      Limit to Employment
I      Limited Other
J      Other
K      CDL Intrastate Only
L      Vehicles without air brakes
M      Except Class A bus
N      Except Class A and Class B bus
O      Except Tractor-Trailer
V      Medical Variance Documentation Required
W      Farm Waiver

</member>
        <member name="F:photopay.Keys.kStandardEndorsementCode">
Optional on AAMVA 01, 02, 03, 04, 05, 06, 07 and 08

Standard endorsement code(s) for cardholder. See codes in D20. This data element is a
placeholder for future efforts to standardize endorsement codes.

Code   Description
H      Hazardous Material - This endorsement is required for the operation of any vehicle
transporting hazardous materials requiring placarding, as defined by U.S.
Department of Transportation regulations.
L      Motorcycles â€“ Including Mopeds/Motorized Bicycles.
N      Tank - This endorsement is required for the operation of any vehicle transporting,
as its primary cargo, any liquid or gaseous material within a tank attached to the vehicle.
O      Other Jurisdiction Specific Endorsement(s) - This code indicates one or more
additional jurisdiction assigned endorsements.
P      Passenger - This endorsement is required for the operation of any vehicle used for
transportation of sixteen or more occupants, including the driver.
S      School Bus - This endorsement is required for the operation of a school bus. School bus means a
CMV used to transport pre-primary, primary, or secondary school students from home to school,
from school to home, or to and from school sponsored events. School bus does not include a
bus used as common carrier (49 CRF 383.5).
T      Doubles/Triples - This endorsement is required for the operation of any vehicle that would be
referred to as a double or triple.
X      Combined Tank/HAZ-MAT - This endorsement may be issued to any driver who qualifies for
both the N and H endorsements.

</member>
        <member name="F:photopay.Keys.kStandardVehicleClassification">
Optional on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Standard vehicle classification code(s) for cardholder. This data element is a
placeholder for future efforts to standardize vehicle classifications.

</member>
        <member name="F:photopay.Keys.kIssuingJurisdiction">
Optional on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

Mandatory on Compact Encoding

Jurisdictions may define a subfile to contain jurisdiction-specific information.
These subfiles are designated with the first character of â€śZâ€ť and the second
character is the first letter of the jurisdiction's name. For example, "ZC" would
be the designator for a California or Colorado jurisdiction-defined subfile; "ZQ"
would be the designator for a Quebec jurisdiction-defined subfile. In the case of
a jurisdiction-defined subfile that has a first letter that could be more than
one jurisdiction (e.g. California, Colorado, Connecticut) then other data, like
the IIN or address, must be examined to determine the jurisdiction.

</member>
        <member name="F:photopay.Keys.kAddressStreet2">
Optional on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

On Compact encoding, use kFullAddress

Second line of street portion of the cardholder address.

</member>
        <member name="F:photopay.Keys.kNameSuffix">
Optional on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Name Suffix (If jurisdiction participates in systems requiring name suffix (PDPS, CDLIS, etc.), the suffix must be collected and displayed on the DL/ID and in the MRT). Collect full name for record, print as many characters as possible on portrait side of DL/ID.
- JR (Junior)
- SR (Senior)
- 1ST or I (First)
- 2ND or II (Second)
- 3RD or III (Third)
- 4TH or IV (Fourth)
- 5TH or V (Fifth)
- 6TH or VI (Sixth)
- 7TH or VII (Seventh)
- 8TH or VIII (Eighth)
- 9TH or IX (Ninth)

</member>
        <member name="F:photopay.Keys.kHairColor">
Optional on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Bald, black, blonde, brown, gray, red/auburn, sandy, white, unknown. If the issuing
jurisdiction wishes to abbreviate colors, the three-character codes provided in ANSI D20 must be
used.

Code   Description
BAL    Bald
BLK    Black
BLN    Blond
BRO    Brown
GRY    Grey
RED    Red/Auburn
SDY    Sandy
WHI    White 
UNK    Unknown

</member>
        <member name="F:photopay.Keys.kCustomerIdNumber">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

The number assigned or calculated by the issuing authority.

</member>
        <member name="F:photopay.Keys.kJurisdictionEndorsementCodes">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

Jurisdiction-specific codes that represent additional privileges
granted to the cardholder beyond the vehicle class (such as transportation of
passengers, hazardous materials, operation of motorcycles, etc.).

</member>
        <member name="F:photopay.Keys.kJurisdictionRestrictionCodes">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

Jurisdiction-specific codes that represent restrictions to driving
privileges (such as airbrakes, automatic transmission, daylight only, etc.).

</member>
        <member name="F:photopay.Keys.kJurisdictionVehicleClass">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

Jurisdiction-specific vehicle class / group code, designating the type
of vehicle the cardholder has privilege to drive.

</member>
        <member name="F:photopay.Keys.kJurisdictionVersionNumber">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Jurisdiction Version Number: This is a decimal value between 00 and 99 that
specifies the jurisdiction version level of the PDF417 bar code format.
Notwithstanding iterations of this standard, jurisdictions implement incremental
changes to their bar codes, including new jurisdiction-specific data, compression
algorithms for digitized images, digital signatures, or new truncation
conventions used for names and addresses. Each change to the bar code format
within each AAMVA version (above) must be noted, beginning with Jurisdiction
Version 00.

</member>
        <member name="F:photopay.Keys.kDocumentNonexpiring">
     Optional on AAMVA Magnetic Stripe Encoding

     Field that indicates that the driving and identification privileges granted by the
     document are nonexpiring = "1".

</member>
        <member name="F:photopay.Keys.kDocumentExpirationMonth">
     Optional on AAMVA Magnetic Stripe Encoding

     Date on which the driving and identification privileges granted by the document are
     no longer valid. (MMYY format)

</member>
        <member name="F:photopay.Keys.kDocumentExpirationDate">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding
Optional on AAMVA Magnetic Stripe Encoding

Date on which the driving and identification privileges granted by the document are
no longer valid. (MMDDCCYY format)

</member>
        <member name="F:photopay.Keys.kDocumentIssueDate">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact Encoding

Date on which the document was issued. (MMDDCCYY format)

</member>
        <member name="F:photopay.Keys.kIssuerIdentificationNumber">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08
Optional on Compact encoding

This number uniquely identifies the issuing jurisdiction and can
be obtained by contacting the ISO Issuing Authority (AAMVA)

</member>
        <member name="F:photopay.Keys.kAddressPostalCode">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

On compact encoding, use kFullAddress.

Postal code portion of the cardholder address in the U.S. and Canada. If the
trailing portion of the postal code in the U.S. is not known, zeros will be used
to fill the trailing set of numbers up to nine (9) digits.

</member>
        <member name="F:photopay.Keys.kAddressJurisdictionCode">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

On compact encoding, use kFullAddress.

State portion of the cardholder address.

</member>
        <member name="F:photopay.Keys.kAddressCity">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

On compact encoding, use kFullAddress.

City portion of the cardholder address.

</member>
        <member name="F:photopay.Keys.kAddressStreet">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08

On compact encoding, use kFullAddress.

Street portion of the cardholder address.
The place where the registered driver of a vehicle (individual or corporation) may be contacted such as a house number, street address etc.

</member>
        <member name="F:photopay.Keys.kEyeColor">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact encoding

Color of cardholder's eyes. (ANSI D-20 codes)

Code   Description
BLK    Black
BLU    Blue
BRO    Brown
GRY    Gray
GRN    Green
HAZ    Hazel
MAR    Maroon 
PNK    Pink
DIC    Dichromatic 
UNK    Unknown

</member>
        <member name="F:photopay.Keys.kSex">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact encoding

Gender of the cardholder. 1 = male, 2 = female.

</member>
        <member name="F:photopay.Keys.kDateOfBirth">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact encoding

Date on which the cardholder was born. (MMDDCCYY format)

</member>
        <member name="F:photopay.Keys.kCustomerFirstName">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 and Compact encoding

First name of the cardholder.

</member>
        <member name="F:photopay.Keys.kCustomerFamilyName">
Mandatory on AAMVA 01, 02, 03, 04, 05, 06, 07, 08 AND compact encoding.

Family name of the cardholder. (Family name is sometimes also called "last name" or "surname.")
Collect full name for record, print as many characters as possible on portrait side of DL/ID.

</member>
        <member name="F:photopay.Keys.kAamvaVersionNumber">
     Mandatory on all driver's licenses.

     AAMVA Version Number: This is a decimal value between 00 and 99 that
     specifies the version level of the PDF417 bar code format. Version "0" and "00"
     is reserved for bar codes printed to the specification of the American Association
     of Motor Vehicle Administrators (AAMVA) prior to the adoption of the AAMVA DL/ID-2000
     standard. All bar codes compliant with the AAMVA DL/ID-2000 standard are designated
     Version "01." All barcodes compliant with AAMVA Card Design Specification version
     1.0, dated 09-2003 shall be designated Version "02." All barcodes compliant with
     AAMVA Card Design Specification version 2.0, dated 03-2005 shall be designated
     Version "03." All barcodes compliant with AAMVA Card Design Standard version 1.0,
     dated 07-2009 shall be designated Version "04." All barcodes compliant with AAMVA
     Card Design Standard version 1.0, dated 07-2010 shall be designated Version "05."
     All barcodes compliant with AAMVA Card Design Standard version 1.0, dated 07- 2011
     shall be designated Version "06". All barcodes compliant with AAMVA Card Design
     Standard version 1.0, dated 06-2012 shall be designated Version "07". All barcodes
     compliant with this current AAMVA standard shall be designated "08". Should a need
     arise requiring major revision to the format, this field provides the means to
     accommodate additional revision.

</member>
        <member name="F:photopay.Keys.kDocumentType">
Mandatory on all driver's licenses. All barcodes which are using 3-track magnetic
stripe encoding used in the interest of smoothing a transition from legacy documents
shall be designated as "Magnetic". All barcodes which are using compact encoding
compliant with ISO/IEC 18013-2 shall be designated as "Compact". All barcodes (majority)
compliant with Mandatory PDF417 Bar Code of the American Association of Motor Vehicle
Administrators (AAMVA) Card Design Standard from AAMVA DL/ID-2000 standard to DL/ID-2013
shall be designated as "AAMVA".

</member>
        <member name="M:DateTimeFormatter.format(DateTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 @brief formats the datetime object to string

 @param dateTime
 @return

</member>
        <member name="M:DateTimeFormatter.parse(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,DateTime*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief parse
@param str
@param dateTime
@return

</member>
        <member name="M:DateTimeFormatter.Dispose">
Virtual destructor

</member>
        <member name="M:DateTimeFormatter.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief DateTimeFormatter
@param format

</member>
        <member name="F:DateTimeFormatter.format_">
Format 
</member>
        <member name="T:DateTimeFormatter">
 @brief Class responsible for parsing date time objects from string

 Currently supports following values:

 DD day in the month, two digit
 MM month, two digits
 YYYY year, four digits

 All combinations are allowed, e.g
 DDMMYYYY
 YYYYMMDD
 etc.

</member>
        <member name="M:DateTime.getCentury">
@brief getCentury
@return century in which the date is

</member>
        <member name="M:DateTime.getYear">
@brief getYear
@return Year of the date

</member>
        <member name="M:DateTime.getMonth">
@brief getMonth
@return Month in year from 1 to 12

</member>
        <member name="M:DateTime.getDay">
@brief getDay
@return day in month

</member>
        <member name="M:DateTime.Dispose">
Virtual destructor

</member>
        <member name="M:DateTime.create(System.Int32,System.Int32,System.Int32,DateTime*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief creates a day with a given day, month and year
@param day
@param month
@param year
@param date, returned by reference
@return true if succeded, false otherwise.

</member>
        <member name="M:DateTime.create(DateTime*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief creates a day with a current day, month and year
@param date, current date, returned by reference

</member>
        <member name="M:DateTime.#ctor">
Creates Now object

</member>
        <member name="M:DateTime.#ctor(tm)">
 Designated constructor.

 Private. Use factory method which returns a status if creation failed.

</member>
        <member name="F:DateTime.time_">
Exact time
@brief time_

</member>
        <member name="T:DateTime">
 \file

 Date.hpp

  Created on: May 22, 2014
      Author: cerovec

 Copyright (c)20114 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

</member>
        <member name="M:cv.ml.createConcentricSpheresTestSet(System.Int32,System.Int32,System.Int32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Creates test set 
</member>
        <member name="M:cv.ml.randGaussMixture(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Generates sample from gaussian mixture distribution 
</member>
        <member name="M:cv.ml.randMVNormal(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Generates _sample_ from multivariate normal distribution

@param mean an average row vector
@param cov symmetric covariation matrix
@param nsamples returned samples count
@param samples returned samples array

</member>
        <member name="M:cv.ml.LogisticRegression.create">
@brief Creates empty model.

    Creates Logistic Regression model with parameters given.

</member>
        <member name="M:cv.ml.LogisticRegression.get_learnt_thetas">
@brief This function returns the trained paramters arranged across rows.

    For a two class classifcation problem, it returns a row matrix. It returns learnt paramters of
    the Logistic Regression as a matrix of type CV_32F.

</member>
        <member name="M:cv.ml.LogisticRegression.predict(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Predicts responses for input samples and returns a float type.

    @param samples The input data for the prediction algorithm. Matrix [m x n], where each row
        contains variables (features) of one object being classified. Should have data type CV_32F.
    @param results Predicted labels as a column matrix of type CV_32S.
    @param flags Not used.

</member>
        <member name="M:cv.ml.LogisticRegression.setTermCriteria(cv.TermCriteria)">
@copybrief getTermCriteria @see getTermCriteria 
</member>
        <member name="M:cv.ml.LogisticRegression.getTermCriteria">
Termination criteria of the algorithm. 
@see setTermCriteria 
</member>
        <member name="M:cv.ml.LogisticRegression.setMiniBatchSize(System.Int32)">
@copybrief getMiniBatchSize @see getMiniBatchSize 
</member>
        <member name="M:cv.ml.LogisticRegression.getMiniBatchSize">
Specifies the number of training samples taken in each step of Mini-Batch Gradient
    Descent. Will only be used if using LogisticRegression::MINI_BATCH training algorithm. It
    has to take values less than the total number of training samples. 
@see setMiniBatchSize 
</member>
        <member name="M:cv.ml.LogisticRegression.setTrainMethod(System.Int32)">
@copybrief getTrainMethod @see getTrainMethod 
</member>
        <member name="M:cv.ml.LogisticRegression.getTrainMethod">
Kind of training method used. See LogisticRegression::Methods. 
@see setTrainMethod 
</member>
        <member name="M:cv.ml.LogisticRegression.setRegularization(System.Int32)">
@copybrief getRegularization @see getRegularization 
</member>
        <member name="M:cv.ml.LogisticRegression.getRegularization">
Kind of regularization to be applied. See LogisticRegression::RegKinds. 
@see setRegularization 
</member>
        <member name="M:cv.ml.LogisticRegression.setIterations(System.Int32)">
@copybrief getIterations @see getIterations 
</member>
        <member name="M:cv.ml.LogisticRegression.getIterations">
Number of iterations. 
@see setIterations 
</member>
        <member name="M:cv.ml.LogisticRegression.setLearningRate(System.Double)">
@copybrief getLearningRate @see getLearningRate 
</member>
        <member name="M:cv.ml.LogisticRegression.getLearningRate">
Learning rate. 
@see setLearningRate 
</member>
        <member name="T:cv.ml.LogisticRegression">
@brief Implements Logistic Regression classifier.

@sa @ref ml_intro_lr

</member>
        <member name="F:NO_OUTPUT_SCALE">
Do not normalize the output vectors. If the flag is not set, the training algorithm
        normalizes each output feature independently, by transforming it to the certain range
        depending on the used activation function. 
</member>
        <member name="F:NO_INPUT_SCALE">
Do not normalize the input vectors. If this flag is not set, the training algorithm
        normalizes each input feature independently, shifting its mean value to 0 and making the
        standard deviation equal to 1. If the network is assumed to be updated frequently, the new
        training data could be much different from original one. In this case, you should take care
        of proper normalization. 
</member>
        <member name="F:UPDATE_WEIGHTS">
Update the network weights, rather than compute them from scratch. In the latter case
        the weights are initialized using the Nguyen-Widrow algorithm. 
</member>
        <member name="T:cv.ml.ANN_MLP.TrainFlags">
Train options 
</member>
        <member name="F:GAUSSIAN">
Gaussian function: \f$f(x)=\beta e^{-\alpha x*x}\f$ 
</member>
        <member name="F:SIGMOID_SYM">
Symmetrical sigmoid: \f$f(x)=\beta*(1-e^{-\alpha x})/(1+e^{-\alpha x}\f$
        @note
        If you are using the default sigmoid activation function with the default parameter values
        fparam1=0 and fparam2=0 then the function used is y = 1.7159\*tanh(2/3 \* x), so the output
        will range from [-1.7159, 1.7159], instead of [0,1].
</member>
        <member name="F:IDENTITY">
Identity function: \f$f(x)=x\f$ 
</member>
        <member name="T:cv.ml.ANN_MLP.ActivationFunctions">
possible activation functions 
</member>
        <member name="M:cv.ml.ANN_MLP.setRpropDWMax(System.Double)">
@copybrief getRpropDWMax @see getRpropDWMax 
</member>
        <member name="M:cv.ml.ANN_MLP.getRpropDWMax">
RPROP: Update-values upper limit \f$\Delta_{max}\f$.
    It must be \&gt;1. Default value is 50.
@see setRpropDWMax 
</member>
        <member name="M:cv.ml.ANN_MLP.setRpropDWMin(System.Double)">
@copybrief getRpropDWMin @see getRpropDWMin 
</member>
        <member name="M:cv.ml.ANN_MLP.getRpropDWMin">
RPROP: Update-values lower limit \f$\Delta_{min}\f$.
    It must be positive. Default value is FLT_EPSILON.
@see setRpropDWMin 
</member>
        <member name="M:cv.ml.ANN_MLP.setRpropDWMinus(System.Double)">
@copybrief getRpropDWMinus @see getRpropDWMinus 
</member>
        <member name="M:cv.ml.ANN_MLP.setRpropDWPlus(System.Double)">
@copybrief getRpropDWPlus @see getRpropDWPlus 
</member>
        <member name="M:cv.ml.ANN_MLP.getRpropDWPlus">
RPROP: Increase factor \f$\eta^+\f$.
    It must be \&gt;1. Default value is 1.2.
@see setRpropDWPlus 
</member>
        <member name="M:cv.ml.ANN_MLP.setRpropDW0(System.Double)">
@copybrief getRpropDW0 @see getRpropDW0 
</member>
        <member name="M:cv.ml.ANN_MLP.getRpropDW0">
RPROP: Initial value \f$\Delta_0\f$ of update-values \f$\Delta_{ij}\f$.
    Default value is 0.1.
@see setRpropDW0 
</member>
        <member name="M:cv.ml.ANN_MLP.setBackpropMomentumScale(System.Double)">
@copybrief getBackpropMomentumScale @see getBackpropMomentumScale 
</member>
        <member name="M:cv.ml.ANN_MLP.getBackpropMomentumScale">
BPROP: Strength of the momentum term (the difference between weights on the 2 previous iterations).
    This parameter provides some inertia to smooth the random fluctuations of the weights. It can
    vary from 0 (the feature is disabled) to 1 and beyond. The value 0.1 or so is good enough.
    Default value is 0.1.
@see setBackpropMomentumScale 
</member>
        <member name="M:cv.ml.ANN_MLP.setBackpropWeightScale(System.Double)">
@copybrief getBackpropWeightScale @see getBackpropWeightScale 
</member>
        <member name="M:cv.ml.ANN_MLP.getBackpropWeightScale">
BPROP: Strength of the weight gradient term.
    The recommended value is about 0.1. Default value is 0.1.
@see setBackpropWeightScale 
</member>
        <member name="M:cv.ml.ANN_MLP.setTermCriteria(cv.TermCriteria)">
@copybrief getTermCriteria @see getTermCriteria 
</member>
        <member name="M:cv.ml.ANN_MLP.getTermCriteria">
Termination criteria of the training algorithm.
    You can specify the maximum number of iterations (maxCount) and/or how much the error could
    change between the iterations to make the algorithm continue (epsilon). Default value is
    TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 1000, 0.01).
@see setTermCriteria 
</member>
        <member name="M:cv.ml.ANN_MLP.getLayerSizes">
Integer vector specifying the number of neurons in each layer including the input and output layers.
   The very first element specifies the number of elements in the input layer.
   The last element - number of elements in the output layer.
   @sa setLayerSizes 
</member>
        <member name="M:cv.ml.ANN_MLP.setLayerSizes(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Integer vector specifying the number of neurons in each layer including the input and output layers.
   The very first element specifies the number of elements in the input layer.
   The last element - number of elements in the output layer. Default value is empty Mat.
   @sa getLayerSizes 
</member>
        <member name="M:cv.ml.ANN_MLP.setActivationFunction(System.Int32,System.Double,System.Double)">
Initialize the activation function for each neuron.
    Currently the default and the only fully supported activation function is ANN_MLP::SIGMOID_SYM.
    @param type The type of activation function. See ANN_MLP::ActivationFunctions.
    @param param1 The first parameter of the activation function, \f$\alpha\f$. Default value is 0.
    @param param2 The second parameter of the activation function, \f$\beta\f$. Default value is 0.

</member>
        <member name="M:cv.ml.ANN_MLP.getTrainMethod">
Returns current training method 
</member>
        <member name="M:cv.ml.ANN_MLP.setTrainMethod(System.Int32,System.Double,System.Double)">
Sets training method and common parameters.
    @param method Default value is ANN_MLP::RPROP. See ANN_MLP::TrainingMethods.
    @param param1 passed to setRpropDW0 for ANN_MLP::RPROP and to setBackpropWeightScale for ANN_MLP::BACKPROP
    @param param2 passed to setRpropDWMin for ANN_MLP::RPROP and to setBackpropMomentumScale for ANN_MLP::BACKPROP.

</member>
        <member name="T:cv.ml.ANN_MLP.TrainingMethods">
Available training methods 
</member>
        <member name="T:cv.ml.ANN_MLP">
@brief Artificial Neural Networks - Multi-Layer Perceptrons.

Unlike many other models in ML that are constructed and trained at once, in the MLP model these
steps are separated. First, a network with the specified topology is created using the non-default
constructor or the method ANN_MLP::create. All the weights are set to zeros. Then, the network is
trained using a set of input and output vectors. The training procedure can be repeated more than
once, that is, the weights can be adjusted based on the new training data.

Additional flags for StatModel::train are available: ANN_MLP::TrainFlags.

@sa @ref ml_intro_ann

</member>
        <member name="T:cv.ml.Boost.Types">
Boosting type.
    Gentle AdaBoost and Real AdaBoost are often the preferable choices. 
</member>
        <member name="M:cv.ml.Boost.setWeightTrimRate(System.Double)">
@copybrief getWeightTrimRate @see getWeightTrimRate 
</member>
        <member name="M:cv.ml.Boost.getWeightTrimRate">
A threshold between 0 and 1 used to save computational time.
    Samples with summary weight \f$\leq 1 - weight_trim_rate\f$ do not participate in the *next*
    iteration of training. Set this parameter to 0 to turn off this functionality. Default value is 0.95.
@see setWeightTrimRate 
</member>
        <member name="M:cv.ml.Boost.setWeakCount(System.Int32)">
@copybrief getWeakCount @see getWeakCount 
</member>
        <member name="M:cv.ml.Boost.getWeakCount">
The number of weak classifiers.
    Default value is 100. 
@see setWeakCount 
</member>
        <member name="M:cv.ml.Boost.setBoostType(System.Int32)">
@copybrief getBoostType @see getBoostType 
</member>
        <member name="M:cv.ml.Boost.getBoostType">
Type of the boosting algorithm.
    See Boost::Types. Default value is Boost::REAL. 
@see setBoostType 
</member>
        <member name="T:cv.ml.Boost">
@brief Boosted tree classifier derived from DTrees

@sa @ref ml_intro_boost

</member>
        <member name="M:cv.ml.RTrees.create">
Creates the empty model.
    Use StatModel::train to train the model, StatModel::train to create and train the model,
    Algorithm::load to load the pre-trained model.

</member>
        <member name="M:cv.ml.RTrees.getVarImportance">
Returns the variable importance array.
    The method returns the variable importance vector, computed at the training stage when
    CalculateVarImportance is set to true. If this flag was set to false, the empty matrix is
    returned.

</member>
        <member name="M:cv.ml.RTrees.setTermCriteria(cv.TermCriteria!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copybrief getTermCriteria @see getTermCriteria 
</member>
        <member name="M:cv.ml.RTrees.getTermCriteria">
The termination criteria that specifies when the training algorithm stops.
    Either when the specified number of trees is trained and added to the ensemble or when
    sufficient accuracy (measured as OOB error) is achieved. Typically the more trees you have the
    better the accuracy. However, the improvement in accuracy generally diminishes and asymptotes
    pass a certain number of trees. Also to keep in mind, the number of tree increases the
    prediction time linearly. Default value is TermCriteria(TermCriteria::MAX_ITERS +
    TermCriteria::EPS, 50, 0.1)
@see setTermCriteria 
</member>
        <member name="M:cv.ml.RTrees.setActiveVarCount(System.Int32)">
@copybrief getActiveVarCount @see getActiveVarCount 
</member>
        <member name="M:cv.ml.RTrees.getActiveVarCount">
The size of the randomly selected subset of features at each tree node and that are used
    to find the best split(s).
    If you set it to 0 then the size will be set to the square root of the total number of
    features. Default value is 0.
@see setActiveVarCount 
</member>
        <member name="M:cv.ml.RTrees.setCalculateVarImportance(System.Boolean)">
@copybrief getCalculateVarImportance @see getCalculateVarImportance 
</member>
        <member name="M:cv.ml.RTrees.getCalculateVarImportance">
If true then variable importance will be calculated and then it can be retrieved by RTrees::getVarImportance.
    Default value is false.
@see setCalculateVarImportance 
</member>
        <member name="T:cv.ml.RTrees">
@brief The class implements the random forest predictor.

@sa @ref ml_intro_rtrees

</member>
        <member name="M:cv.ml.DTrees.getSubsets">
@brief Returns all the bitsets for categorical splits

    Split::subsetOfs is an offset in the returned vector

</member>
        <member name="M:cv.ml.DTrees.getSplits">
@brief Returns all the splits

    all the split indices are indices in the returned vector

</member>
        <member name="M:cv.ml.DTrees.getNodes">
@brief Returns all the nodes

    all the node indices are indices in the returned vector

</member>
        <member name="M:cv.ml.DTrees.getRoots">
@brief Returns indices of root nodes

</member>
        <member name="T:cv.ml.DTrees.Split">
@brief The class represents split in a decision tree.

</member>
        <member name="T:cv.ml.DTrees.Node">
@brief The class represents a decision tree node.

</member>
        <member name="M:cv.ml.DTrees.setPriors(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copybrief getPriors @see getPriors 
</member>
        <member name="M:cv.ml.DTrees.getPriors">
@brief The array of a priori class probabilities, sorted by the class label value.

    The parameter can be used to tune the decision tree preferences toward a certain class. For
    example, if you want to detect some rare anomaly occurrence, the training base will likely
    contain much more normal cases than anomalies, so a very good classification performance
    will be achieved just by considering every case as normal. To avoid this, the priors can be
    specified, where the anomaly probability is artificially increased (up to 0.5 or even
    greater), so the weight of the misclassified anomalies becomes much bigger, and the tree is
    adjusted properly.

    You can also think about this parameter as weights of prediction categories which determine
    relative weights that you give to misclassification. That is, if the weight of the first
    category is 1 and the weight of the second category is 10, then each mistake in predicting
    the second category is equivalent to making 10 mistakes in predicting the first category.
    Default value is empty Mat.
@see setPriors 
</member>
        <member name="M:cv.ml.DTrees.setRegressionAccuracy(System.Single)">
@copybrief getRegressionAccuracy @see getRegressionAccuracy 
</member>
        <member name="M:cv.ml.DTrees.getRegressionAccuracy">
Termination criteria for regression trees.
    If all absolute differences between an estimated value in a node and values of train samples
    in this node are less than this parameter then the node will not be split further. Default
    value is 0.01f
@see setRegressionAccuracy 
</member>
        <member name="M:cv.ml.DTrees.setTruncatePrunedTree(System.Boolean)">
@copybrief getTruncatePrunedTree @see getTruncatePrunedTree 
</member>
        <member name="M:cv.ml.DTrees.getTruncatePrunedTree">
If true then pruned branches are physically removed from the tree.
    Otherwise they are retained and it is possible to get results from the original unpruned (or
    pruned less aggressively) tree. Default value is true.
@see setTruncatePrunedTree 
</member>
        <member name="M:cv.ml.DTrees.setUse1SERule(System.Boolean)">
@copybrief getUse1SERule @see getUse1SERule 
</member>
        <member name="M:cv.ml.DTrees.getUse1SERule">
If true then a pruning will be harsher.
    This will make a tree more compact and more resistant to the training data noise but a bit less
    accurate. Default value is true.
@see setUse1SERule 
</member>
        <member name="M:cv.ml.DTrees.setUseSurrogates(System.Boolean)">
@copybrief getUseSurrogates @see getUseSurrogates 
</member>
        <member name="M:cv.ml.DTrees.getUseSurrogates">
If true then surrogate splits will be built.
    These splits allow to work with missing data and compute variable importance correctly.
    Default value is false.
    @note currently it's not implemented.
@see setUseSurrogates 
</member>
        <member name="M:cv.ml.DTrees.setCVFolds(System.Int32)">
@copybrief getCVFolds @see getCVFolds 
</member>
        <member name="M:cv.ml.DTrees.getCVFolds">
If CVFolds \&gt; 1 then algorithms prunes the built decision tree using K-fold
    cross-validation procedure where K is equal to CVFolds.
    Default value is 10.
@see setCVFolds 
</member>
        <member name="M:cv.ml.DTrees.setMinSampleCount(System.Int32)">
@copybrief getMinSampleCount @see getMinSampleCount 
</member>
        <member name="M:cv.ml.DTrees.getMinSampleCount">
If the number of samples in a node is less than this parameter then the node will not be split.

    Default value is 10.
@see setMinSampleCount 
</member>
        <member name="M:cv.ml.DTrees.setMaxDepth(System.Int32)">
@copybrief getMaxDepth @see getMaxDepth 
</member>
        <member name="M:cv.ml.DTrees.getMaxDepth">
The maximum possible depth of the tree.
    That is the training algorithms attempts to split a node while its depth is less than maxDepth.
    The root node has zero depth. The actual depth may be smaller if the other termination criteria
    are met (see the outline of the training procedure @ref ml_intro_trees "here"), and/or if the
    tree is pruned. Default value is INT_MAX.
@see setMaxDepth 
</member>
        <member name="M:cv.ml.DTrees.setMaxCategories(System.Int32)">
@copybrief getMaxCategories @see getMaxCategories 
</member>
        <member name="T:cv.ml.DTrees.Flags">
Predict options 
</member>
        <member name="T:cv.ml.DTrees">
@brief The class represents a single decision tree or a collection of decision trees.

The current public interface of the class allows user to train only a single decision tree, however
the class is capable of storing multiple decision trees and using them for prediction (by summing
responses or using a voting schemes), and the derived from DTrees classes (such as RTrees and Boost)
use this capability to implement decision tree ensembles.

@sa @ref ml_intro_trees

</member>
        <member name="M:cv.ml.EM.trainM(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Estimate the Gaussian mixture parameters from a samples set.

    This variation starts with Maximization step. You need to provide initial probabilities
    \f$p_{i,k}\f$ to use this option.

    @param samples Samples from which the Gaussian mixture model will be estimated. It should be a
        one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type
        it will be converted to the inner matrix of such type for the further computing.
    @param probs0
    @param logLikelihoods The optional output matrix that contains a likelihood logarithm value for
        each sample. It has \f$nsamples \times 1\f$ size and CV_64FC1 type.
    @param labels The optional output "class label" for each sample:
        \f$\texttt{labels}_i=\texttt{arg max}_k(p_{i,k}), i=1..N\f$ (indices of the most probable
        mixture component for each sample). It has \f$nsamples \times 1\f$ size and CV_32SC1 type.
    @param probs The optional output matrix that contains posterior probabilities of each Gaussian
        mixture component given the each sample. It has \f$nsamples \times nclusters\f$ size and
        CV_64FC1 type.

</member>
        <member name="M:cv.ml.EM.trainE(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.Compile">
@brief Estimate the Gaussian mixture parameters from a samples set.

    This variation starts with Expectation step. You need to provide initial means \f$a_k\f$ of
    mixture components. Optionally you can pass initial weights \f$\pi_k\f$ and covariance matrices
    \f$S_k\f$ of mixture components.

    @param samples Samples from which the Gaussian mixture model will be estimated. It should be a
        one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type
        it will be converted to the inner matrix of such type for the further computing.
    @param means0 Initial means \f$a_k\f$ of mixture components. It is a one-channel matrix of
        \f$nclusters \times dims\f$ size. If the matrix does not have CV_64F type it will be
        converted to the inner matrix of such type for the further computing.
    @param covs0 The vector of initial covariance matrices \f$S_k\f$ of mixture components. Each of
        covariance matrices is a one-channel matrix of \f$dims \times dims\f$ size. If the matrices
        do not have CV_64F type they will be converted to the inner matrices of such type for the
        further computing.
    @param weights0 Initial weights \f$\pi_k\f$ of mixture components. It should be a one-channel
        floating-point matrix with \f$1 \times nclusters\f$ or \f$nclusters \times 1\f$ size.
    @param logLikelihoods The optional output matrix that contains a likelihood logarithm value for
        each sample. It has \f$nsamples \times 1\f$ size and CV_64FC1 type.
    @param labels The optional output "class label" for each sample:
        \f$\texttt{labels}_i=\texttt{arg max}_k(p_{i,k}), i=1..N\f$ (indices of the most probable
        mixture component for each sample). It has \f$nsamples \times 1\f$ size and CV_32SC1 type.
    @param probs The optional output matrix that contains posterior probabilities of each Gaussian
        mixture component given the each sample. It has \f$nsamples \times nclusters\f$ size and
        CV_64FC1 type.

</member>
        <member name="M:cv.ml.EM.trainEM(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Estimate the Gaussian mixture parameters from a samples set.

    This variation starts with Expectation step. Initial values of the model parameters will be
    estimated by the k-means algorithm.

    Unlike many of the ML models, %EM is an unsupervised learning algorithm and it does not take
    responses (class labels or function values) as input. Instead, it computes the *Maximum
    Likelihood Estimate* of the Gaussian mixture parameters from an input sample set, stores all the
    parameters inside the structure: \f$p_{i,k}\f$ in probs, \f$a_k\f$ in means , \f$S_k\f$ in
    covs[k], \f$\pi_k\f$ in weights , and optionally computes the output "class label" for each
    sample: \f$\texttt{labels}_i=\texttt{arg max}_k(p_{i,k}), i=1..N\f$ (indices of the most
    probable mixture component for each sample).

    The trained model can be used further for prediction, just like any other classifier. The
    trained model is similar to the NormalBayesClassifier.

    @param samples Samples from which the Gaussian mixture model will be estimated. It should be a
        one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type
        it will be converted to the inner matrix of such type for the further computing.
    @param logLikelihoods The optional output matrix that contains a likelihood logarithm value for
        each sample. It has \f$nsamples \times 1\f$ size and CV_64FC1 type.
    @param labels The optional output "class label" for each sample:
        \f$\texttt{labels}_i=\texttt{arg max}_k(p_{i,k}), i=1..N\f$ (indices of the most probable
        mixture component for each sample). It has \f$nsamples \times 1\f$ size and CV_32SC1 type.
    @param probs The optional output matrix that contains posterior probabilities of each Gaussian
        mixture component given the each sample. It has \f$nsamples \times nclusters\f$ size and
        CV_64FC1 type.

</member>
        <member name="M:cv.ml.EM.predict2(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Returns a likelihood logarithm value and an index of the most probable mixture component
    for the given sample.

    @param sample A sample for classification. It should be a one-channel matrix of
        \f$1 \times dims\f$ or \f$dims \times 1\f$ size.
    @param probs Optional output matrix that contains posterior probabilities of each component
        given the sample. It has \f$1 \times nclusters\f$ size and CV_64FC1 type.

    The method returns a two-element double vector. Zero element is a likelihood logarithm value for
    the sample. First element is an index of the most probable mixture component for the given
    sample.

</member>
        <member name="M:cv.ml.EM.getCovs(std.vector&lt;cv.Mat&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Returns covariation matrices

    Returns vector of covariation matrices. Number of matrices is the number of gaussian mixtures,
    each matrix is a square floating-point matrix NxN, where N is the space dimensionality.

</member>
        <member name="M:cv.ml.EM.getMeans">
@brief Returns the cluster centers (means of the Gaussian mixture)

    Returns matrix with the number of rows equal to the number of mixtures and number of columns
    equal to the space dimensionality.

</member>
        <member name="M:cv.ml.EM.getWeights">
@brief Returns weights of the mixtures

    Returns vector with the number of elements equal to the number of mixtures.

</member>
        <member name="M:cv.ml.EM.setTermCriteria(cv.TermCriteria!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copybrief getTermCriteria @see getTermCriteria 
</member>
        <member name="M:cv.ml.EM.getTermCriteria">
The termination criteria of the %EM algorithm.
    The %EM algorithm can be terminated by the number of iterations termCrit.maxCount (number of
    M-steps) or when relative change of likelihood logarithm is less than termCrit.epsilon. Default
    maximum number of iterations is EM::DEFAULT_MAX_ITERS=100. 
@see setTermCriteria 
</member>
        <member name="M:cv.ml.EM.setCovarianceMatrixType(System.Int32)">
@copybrief getCovarianceMatrixType @see getCovarianceMatrixType 
</member>
        <member name="M:cv.ml.EM.getCovarianceMatrixType">
Constraint on covariance matrices which defines type of matrices.
    See EM::Types. 
@see setCovarianceMatrixType 
</member>
        <member name="M:cv.ml.EM.setClustersNumber(System.Int32)">
@copybrief getClustersNumber @see getClustersNumber 
</member>
        <member name="M:cv.ml.EM.getClustersNumber">
The number of mixture components in the Gaussian mixture model.
    Default value of the parameter is EM::DEFAULT_NCLUSTERS=5. Some of %EM implementation could
    determine the optimal number of mixtures within a specified value range, but that is not the
    case in ML yet. 
@see setClustersNumber 
</member>
        <member name="F:COV_MAT_GENERIC">
A symmetric positively defined matrix. The number of free
        parameters in each matrix is about \f$d^2/2\f$. It is not recommended to use this option, unless
        there is pretty accurate initial estimation of the parameters and/or a huge number of
        training samples. 
</member>
        <member name="F:COV_MAT_DIAGONAL">
A diagonal matrix with positive diagonal elements. The number of
        free parameters is d for each matrix. This is most commonly used option yielding good
        estimation results. 
</member>
        <member name="F:COV_MAT_SPHERICAL">
A scaled identity matrix \f$\mu_k * I\f$. There is the only
        parameter \f$\mu_k\f$ to be estimated for each matrix. The option may be used in special cases,
        when the constraint is relevant, or as a first step in the optimization (for example in case
        when the data is preprocessed with PCA). The results of such preliminary estimation may be
        passed again to the optimization procedure, this time with
        covMatType=EM::COV_MAT_DIAGONAL. 
</member>
        <member name="T:cv.ml.EM">
@brief The class implements the Expectation Maximization algorithm.

@sa @ref ml_intro_em

</member>
        <member name="M:cv.ml.SVM.create">
Creates empty model.
    Use StatModel::train to train the model. Since %SVM has several parameters, you may want to
    find the best parameters for your problem, it can be done with SVM::trainAuto. 
</member>
        <member name="M:cv.ml.SVM.getDefaultGrid(System.Int32)">
@brief Generates a grid for %SVM parameters.

    @param param_id %SVM parameters IDs that must be one of the SVM::ParamTypes. The grid is
    generated for the parameter with this ID.

    The function generates a grid for the specified parameter of the %SVM algorithm. The grid may be
    passed to the function SVM::trainAuto.

</member>
        <member name="M:cv.ml.SVM.getDecisionFunction(System.Int32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Retrieves the decision function

    @param i the index of the decision function. If the problem solved is regression, 1-class or
        2-class classification, then there will be just one decision function and the index should
        always be 0. Otherwise, in the case of N-class classification, there will be \f$N(N-1)/2\f$
        decision functions.
    @param alpha the optional output vector for weights, corresponding to different support vectors.
        In the case of linear %SVM all the alpha's will be 1's.
    @param svidx the optional output vector of indices of support vectors within the matrix of
        support vectors (which can be retrieved by SVM::getSupportVectors). In the case of linear
        %SVM each decision function consists of a single "compressed" support vector.

    The method returns rho parameter of the decision function, a scalar subtracted from the weighted
    sum of kernel responses.

</member>
        <member name="M:cv.ml.SVM.getSupportVectors">
@brief Retrieves all the support vectors

    The method returns all the support vector as floating-point matrix, where support vectors are
    stored as matrix rows.

</member>
        <member name="M:cv.ml.SVM.trainAuto(cv.Ptr&lt;cv.ml.TrainData&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.ml.ParamGrid,cv.ml.ParamGrid,cv.ml.ParamGrid,cv.ml.ParamGrid,cv.ml.ParamGrid,cv.ml.ParamGrid,System.Boolean)">
@brief Trains an %SVM with optimal parameters.

    @param data the training data that can be constructed using TrainData::create or
        TrainData::loadFromCSV.
    @param kFold Cross-validation parameter. The training set is divided into kFold subsets. One
        subset is used to test the model, the others form the train set. So, the %SVM algorithm is
        executed kFold times.
    @param Cgrid grid for C
    @param gammaGrid grid for gamma
    @param pGrid grid for p
    @param nuGrid grid for nu
    @param coeffGrid grid for coeff
    @param degreeGrid grid for degree
    @param balanced If true and the problem is 2-class classification then the method creates more
        balanced cross-validation subsets that is proportions between classes in subsets are close
        to such proportion in the whole train dataset.

    The method trains the %SVM model automatically by choosing the optimal parameters C, gamma, p,
    nu, coef0, degree. Parameters are considered optimal when the cross-validation
    estimate of the test set error is minimal.

    If there is no need to optimize a parameter, the corresponding grid step should be set to any
    value less than or equal to 1. For example, to avoid optimization in gamma, set `gammaGrid.step
    = 0`, `gammaGrid.minVal`, `gamma_grid.maxVal` as arbitrary numbers. In this case, the value
    `Gamma` is taken for gamma.

    And, finally, if the optimization in a parameter is required but the corresponding grid is
    unknown, you may call the function SVM::getDefaultGrid. To generate a grid, for example, for
    gamma, call `SVM::getDefaultGrid(SVM::GAMMA)`.

    This function works for the classification (SVM::C_SVC or SVM::NU_SVC) as well as for the
    regression (SVM::EPS_SVR or SVM::NU_SVR). If it is SVM::ONE_CLASS, no optimization is made and
    the usual %SVM with parameters specified in params is executed.

</member>
        <member name="F:INTER">
Histogram intersection kernel. A fast kernel. \f$K(x_i, x_j) = min(x_i,x_j)\f$. 
</member>
        <member name="F:CHI2">
Exponential Chi2 kernel, similar to the RBF kernel:
        \f$K(x_i, x_j) = e^{-\gamma \chi^2(x_i,x_j)}, \chi^2(x_i,x_j) = (x_i-x_j)^2/(x_i+x_j), \gamma &gt; 0\f$. 
</member>
        <member name="F:SIGMOID">
Sigmoid kernel: \f$K(x_i, x_j) = \tanh(\gamma x_i^T x_j + coef0)\f$. 
</member>
        <member name="F:RBF">
Radial basis function (RBF), a good choice in most cases.
        \f$K(x_i, x_j) = e^{-\gamma ||x_i - x_j||^2}, \gamma &gt; 0\f$. 
</member>
        <member name="F:POLY">
Polynomial kernel:
        \f$K(x_i, x_j) = (\gamma x_i^T x_j + coef0)^{degree}, \gamma &gt; 0\f$. 
</member>
        <member name="F:LINEAR">
Linear kernel. No mapping is done, linear discrimination (or regression) is
        done in the original feature space. It is the fastest option. \f$K(x_i, x_j) = x_i^T x_j\f$. 
</member>
        <member name="F:CUSTOM">
Returned by SVM::getKernelType in case when custom kernel has been set 
</member>
        <member name="F:NU_SVR">
\f$\nu\f$-Support Vector Regression. \f$\nu\f$ is used instead of p.
        See @cite LibSVM for details. 
</member>
        <member name="F:EPS_SVR">
\f$\epsilon\f$-Support Vector Regression. The distance between feature vectors
        from the training set and the fitting hyper-plane must be less than p. For outliers the
        penalty multiplier C is used. 
</member>
        <member name="F:ONE_CLASS">
Distribution Estimation (One-class %SVM). All the training data are from
        the same class, %SVM builds a boundary that separates the class from the rest of the feature
        space. 
</member>
        <member name="F:NU_SVC">
\f$\nu\f$-Support Vector Classification. n-class classification with possible
        imperfect separation. Parameter \f$\nu\f$ (in the range 0..1, the larger the value, the smoother
        the decision boundary) is used instead of C. 
</member>
        <member name="F:C_SVC">
C-Support Vector Classification. n-class classification (n \f$\geq\f$ 2), allows
        imperfect separation of classes with penalty multiplier C for outliers. 
</member>
        <member name="M:cv.ml.SVM.setCustomKernel(cv.Ptr&lt;cv.ml.SVM.Kernel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Initialize with custom kernel.
    See SVM::Kernel class for implementation details 
</member>
        <member name="M:cv.ml.SVM.setKernel(System.Int32)">
Initialize with one of predefined kernels.
    See SVM::KernelTypes. 
</member>
        <member name="M:cv.ml.SVM.getKernelType">
Type of a %SVM kernel.
    See SVM::KernelTypes. Default value is SVM::RBF. 
</member>
        <member name="M:cv.ml.SVM.setTermCriteria(cv.TermCriteria!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copybrief getTermCriteria @see getTermCriteria 
</member>
        <member name="M:cv.ml.SVM.getTermCriteria">
Termination criteria of the iterative %SVM training procedure which solves a partial
    case of constrained quadratic optimization problem.
    You can specify tolerance and/or the maximum number of iterations. Default value is
    `TermCriteria( TermCriteria::MAX_ITER + TermCriteria::EPS, 1000, FLT_EPSILON )`; 
@see setTermCriteria 
</member>
        <member name="M:cv.ml.SVM.setClassWeights(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copybrief getClassWeights @see getClassWeights 
</member>
        <member name="M:cv.ml.SVM.getClassWeights">
Optional weights in the SVM::C_SVC problem, assigned to particular classes.
    They are multiplied by _C_ so the parameter _C_ of class _i_ becomes `classWeights(i) * C`. Thus
    these weights affect the misclassification penalty for different classes. The larger weight,
    the larger penalty on misclassification of data from the corresponding class. Default value is
    empty Mat. 
@see setClassWeights 
</member>
        <member name="M:cv.ml.SVM.setP(System.Double)">
@copybrief getP @see getP 
</member>
        <member name="M:cv.ml.SVM.getP">
Parameter \f$\epsilon\f$ of a %SVM optimization problem.
    For SVM::EPS_SVR. Default value is 0. 
@see setP 
</member>
        <member name="M:cv.ml.SVM.setNu(System.Double)">
@copybrief getNu @see getNu 
</member>
        <member name="M:cv.ml.SVM.getNu">
Parameter \f$\nu\f$ of a %SVM optimization problem.
    For SVM::NU_SVC, SVM::ONE_CLASS or SVM::NU_SVR. Default value is 0. 
@see setNu 
</member>
        <member name="M:cv.ml.SVM.setC(System.Double)">
@copybrief getC @see getC 
</member>
        <member name="M:cv.ml.SVM.getC">
Parameter _C_ of a %SVM optimization problem.
    For SVM::C_SVC, SVM::EPS_SVR or SVM::NU_SVR. Default value is 0. 
@see setC 
</member>
        <member name="M:cv.ml.SVM.setDegree(System.Double)">
@copybrief getDegree @see getDegree 
</member>
        <member name="M:cv.ml.SVM.getDegree">
Parameter _degree_ of a kernel function.
    For SVM::POLY. Default value is 0. 
@see setDegree 
</member>
        <member name="M:cv.ml.SVM.setCoef0(System.Double)">
@copybrief getCoef0 @see getCoef0 
</member>
        <member name="M:cv.ml.SVM.getCoef0">
Parameter _coef0_ of a kernel function.
    For SVM::POLY or SVM::SIGMOID. Default value is 0.
@see setCoef0 
</member>
        <member name="M:cv.ml.SVM.setGamma(System.Double)">
@copybrief getGamma @see getGamma 
</member>
        <member name="M:cv.ml.SVM.getGamma">
Parameter \f$\gamma\f$ of a kernel function.
    For SVM::POLY, SVM::RBF, SVM::SIGMOID or SVM::CHI2. Default value is 1. 
@see setGamma 
</member>
        <member name="M:cv.ml.SVM.setType(System.Int32)">
@copybrief getType @see getType 
</member>
        <member name="M:cv.ml.SVM.getType">
Type of a %SVM formulation.
    See SVM::Types. Default value is SVM::C_SVC. 
@see setType 
</member>
        <member name="T:cv.ml.SVM">
@brief Support Vector Machines.

@sa @ref ml_intro_svm

</member>
        <member name="M:cv.ml.KNearest.create">
@brief Creates the empty model

    The static method creates empty %KNearest classifier. It should be then trained using StatModel::train method.

</member>
        <member name="T:cv.ml.KNearest.Types">
@brief Implementations of KNearest algorithm

</member>
        <member name="M:cv.ml.KNearest.setAlgorithmType(System.Int32)">
@copybrief getAlgorithmType @see getAlgorithmType 
</member>
        <member name="M:cv.ml.KNearest.getAlgorithmType">
%Algorithm type, one of KNearest::Types. 
@see setAlgorithmType 
</member>
        <member name="M:cv.ml.KNearest.setEmax(System.Int32)">
@copybrief getEmax @see getEmax 
</member>
        <member name="M:cv.ml.KNearest.getEmax">
Parameter for KDTree implementation. 
@see setEmax 
</member>
        <member name="M:cv.ml.KNearest.setIsClassifier(System.Boolean)">
@copybrief getIsClassifier @see getIsClassifier 
</member>
        <member name="M:cv.ml.KNearest.getIsClassifier">
Whether classification or regression model should be trained. 
@see setIsClassifier 
</member>
        <member name="M:cv.ml.KNearest.setDefaultK(System.Int32)">
@copybrief getDefaultK @see getDefaultK 
</member>
        <member name="M:cv.ml.KNearest.getDefaultK">
Default number of neighbors to use in predict method. 
@see setDefaultK 
</member>
        <member name="T:cv.ml.KNearest">
@brief The class implements K-Nearest Neighbors model

@sa @ref ml_intro_knn

</member>
        <member name="M:cv.ml.NormalBayesClassifier.create">
Creates empty model
    Use StatModel::train to train the model after creation. 
</member>
        <member name="M:cv.ml.NormalBayesClassifier.predictProb(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Predicts the response for sample(s).

    The method estimates the most probable classes for input vectors. Input vectors (one or more)
    are stored as rows of the matrix inputs. In case of multiple input vectors, there should be one
    output vector outputs. The predicted class for a single input vector is returned by the method.
    The vector outputProbs contains the output probabilities corresponding to each element of
    result.

</member>
        <member name="T:cv.ml.NormalBayesClassifier">
@brief Bayes classifier for normally distributed data.

@sa @ref ml_intro_bayes

</member>
        <member name="M:cv.ml.StatModel.predict(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Predicts response(s) for the provided sample(s)

    @param samples The input samples, floating-point matrix
    @param results The optional output matrix of results.
    @param flags The optional flags, model-dependent. See cv::ml::StatModel::Flags.

</member>
        <member name="M:cv.ml.StatModel.calcError(cv.Ptr&lt;cv.ml.TrainData&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes error on the training or test dataset

    @param data the training data
    @param test if true, the error is computed over the test subset of the data, otherwise it's
        computed over the training subset of the data. Please note that if you loaded a completely
        different dataset to evaluate already trained classifier, you will probably want not to set
        the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so
        that the error is computed for the whole new set. Yes, this sounds a bit confusing.
    @param resp the optional output responses.

    The method uses StatModel::predict to compute the error. For regression models the error is
    computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%).

</member>
        <member name="M:cv.ml.StatModel.train(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Trains the statistical model

    @param samples training samples
    @param layout See ml::SampleTypes.
    @param responses vector of responses associated with the training samples.

</member>
        <member name="M:cv.ml.StatModel.train(cv.Ptr&lt;cv.ml.TrainData&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Trains the statistical model

    @param trainData training data that can be loaded from file using TrainData::loadFromCSV or
        created with TrainData::create.
    @param flags optional flags, depending on the model. Some of the models can be updated with the
        new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP).

</member>
        <member name="M:cv.ml.StatModel.isClassifier">
@brief Returns true if the model is classifier 
</member>
        <member name="M:cv.ml.StatModel.isTrained">
@brief Returns true if the model is trained 
</member>
        <member name="M:cv.ml.StatModel.getVarCount">
@brief Returns the number of variables in training samples 
</member>
        <member name="T:cv.ml.StatModel.Flags">
Predict options 
</member>
        <member name="T:cv.ml.StatModel">
@brief Base class for statistical models in OpenCV ML.

</member>
        <member name="M:cv.ml.TrainData.loadFromCSV(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
@brief Reads the dataset from a .csv file and returns the ready-to-use training data.

    @param filename The input file name
    @param headerLineCount The number of lines in the beginning to skip; besides the header, the
        function also skips empty lines and lines staring with `#`
    @param responseStartIdx Index of the first output variable. If -1, the function considers the
        last variable as the response
    @param responseEndIdx Index of the last output variable + 1. If -1, then there is single
        response variable at responseStartIdx.
    @param varTypeSpec The optional text string that specifies the variables' types. It has the
        format `ord[n1-n2,n3,n4-n5,...]cat[n6,n7-n8,...]`. That is, variables from `n1 to n2`
        (inclusive range), `n3`, `n4 to n5` ... are considered ordered and `n6`, `n7 to n8` ... are
        considered as categorical. The range `[n1..n2] + [n3] + [n4..n5] + ... + [n6] + [n7..n8]`
        should cover all the variables. If varTypeSpec is not specified, then algorithm uses the
        following rules:
        - all input variables are considered ordered by default. If some column contains has non-
          numerical values, e.g. 'apple', 'pear', 'apple', 'apple', 'mango', the corresponding
          variable is considered categorical.
        - if there are several output variables, they are all considered as ordered. Error is
          reported when non-numerical values are used.
        - if there is a single output variable, then if its values are non-numerical or are all
          integers, then it's considered categorical. Otherwise, it's considered ordered.
    @param delimiter The character used to separate values in each line.
    @param missch The character used to specify missing measurements. It should not be a digit.
        Although it's a non-numerical value, it surely does not affect the decision of whether the
        variable ordered or categorical.

</member>
        <member name="M:cv.ml.TrainData.setTrainTestSplitRatio(System.Double,System.Boolean)">
@brief Splits the training data into the training and test parts

    The function selects a subset of specified relative size and then returns it as the training
    set. If the function is not called, all the data is used for training. Please, note that for
    each of TrainData::getTrain\* there is corresponding TrainData::getTest\*, so that the test
    subset can be retrieved and processed as well.
    @sa TrainData::setTrainTestSplit

</member>
        <member name="M:cv.ml.TrainData.setTrainTestSplit(System.Int32,System.Boolean)">
@brief Splits the training data into the training and test parts
    @sa TrainData::setTrainTestSplitRatio

</member>
        <member name="M:cv.ml.TrainData.getClassLabels">
@brief Returns the vector of class labels

    The function returns vector of unique labels occurred in the responses.

</member>
        <member name="M:cv.ml.TrainData.getTrainResponses">
@brief Returns the vector of responses

    The function returns ordered or the original categorical responses. Usually it's used in
    regression algorithms.

</member>
        <member name="M:cv.ml.TrainData.getTrainSamples(System.Int32,System.Boolean,System.Boolean)">
@brief Returns matrix of train samples

    @param layout The requested layout. If it's different from the initial one, the matrix is
        transposed. See ml::SampleTypes.
    @param compressSamples if true, the function returns only the training samples (specified by
        sampleIdx)
    @param compressVars if true, the function returns the shorter training samples, containing only
        the active variables.

    In current implementation the function tries to avoid physical data copying and returns the
    matrix stored inside TrainData (unless the transposition or compression is needed).

</member>
        <member name="M:cv.ml.ParamGrid.#ctor(System.Double,System.Double,System.Double)">
@brief Constructor with parameters 
</member>
        <member name="M:cv.ml.ParamGrid.#ctor">
@brief Default constructor 
</member>
        <member name="T:cv.ml.ParamGrid">
@brief The structure represents the logarithmic grid range of statmodel parameters.

It is used for optimizing statmodel accuracy by varying model parameters, the accuracy estimate
being computed by cross-validation.

</member>
        <member name="T:cv.ml.SampleTypes">
@brief Sample types 
</member>
        <member name="T:cv.ml.ErrorTypes">
@brief %Error types 
</member>
        <member name="T:cv.ml.VariableTypes">
@brief Variable types 
</member>
        <member name="M:cv.loadWindowParameters(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Loads parameters of the specified window.

@param windowName Name of the window.

The function loadWindowParameters loads size, location, flags, trackbars value, zoom and panning
location of the window window_name .

</member>
        <member name="M:cv.saveWindowParameters(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Saves parameters of the specified window.

@param windowName Name of the window.

The function saveWindowParameters saves size, location, flags, trackbars value, zoom and panning
location of the window window_name .

</member>
        <member name="M:cv.displayStatusBar(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Displays a text on the window statusbar during the specified period of time.

@param winname Name of the window.
@param text Text to write on the window statusbar.
@param delayms Duration (in milliseconds) to display the text. If this function is called before
the previous text timed out, the timer is restarted and the text is updated. If this value is
zero, the text never disappears.

The function displayOverlay displays useful information/tips on top of the window for a certain
amount of time *delayms* . This information is displayed on the window statusbar (the window must be
created with the CV_GUI_EXPANDED flags).

</member>
        <member name="M:cv.displayOverlay(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Displays a text on a window image as an overlay for a specified duration.

@param winname Name of the window.
@param text Overlay text to write on a window image.
@param delayms The period (in milliseconds), during which the overlay text is displayed. If this
function is called before the previous overlay text timed out, the timer is restarted and the text
is updated. If this value is zero, the text never disappears.

The function displayOverlay displays useful information/tips on top of the window for a certain
amount of time *delayms*. The function does not modify the image, displayed in the window, that is,
after the specified delay the original content of the window is restored.

</member>
        <member name="M:cv.addText(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,cv.QtFont!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Creates the font to draw a text on an image.

@param img 8-bit 3-channel image where the text should be drawn.
@param text Text to write on an image.
@param org Point(x,y) where the text should start on an image.
@param font Font to use to draw a text.

The function addText draws *text* on an image *img* using a specific font *font* (see example fontQt
)

</member>
        <member name="M:cv.fontQt(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.Scalar_&lt;System.Double&gt;,System.Int32,System.Int32,System.Int32)">
@brief Creates the font to draw a text on an image.

@param nameFont Name of the font. The name should match the name of a system font (such as
*Times*). If the font is not found, a default one is used.
@param pointSize Size of the font. If not specified, equal zero or negative, the point size of the
font is set to a system-dependent default value. Generally, this is 12 points.
@param color Color of the font in BGRA where A = 255 is fully transparent. Use the macro CV _ RGB
for simplicity.
@param weight Font weight. The following operation flags are available:
 -   **CV_FONT_LIGHT** Weight of 25
 -   **CV_FONT_NORMAL** Weight of 50
 -   **CV_FONT_DEMIBOLD** Weight of 63
 -   **CV_FONT_BOLD** Weight of 75
 -   **CV_FONT_BLACK** Weight of 87

 You can also specify a positive integer for better control.
@param style Font style. The following operation flags are available:
 -   **CV_STYLE_NORMAL** Normal font
 -   **CV_STYLE_ITALIC** Italic font
 -   **CV_STYLE_OBLIQUE** Oblique font
@param spacing Spacing between characters. It can be negative or positive.

The function fontQt creates a CvFont object. This CvFont is not compatible with putText .

A basic usage of this function is the following: :
@code
    CvFont font = fontQt(''Times'');
    addText( img1, ``Hello World !'', Point(50,50), font);
@endcode

</member>
        <member name="M:cv.updateWindow(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Force window to redraw its context and call draw callback ( setOpenGlDrawCallback ).

@param winname Window name

</member>
        <member name="M:cv.setOpenGlContext(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Sets the specified window as current OpenGL context.

@param winname Window name

</member>
        <member name="M:cv.setTrackbarMax(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Sets the trackbar maximum position.

@param trackbarname Name of the trackbar.
@param winname Name of the window that is the parent of trackbar.
@param maxval New maximum position.

The function sets the maximum position of the specified trackbar in the specified window.

@note

**[Qt Backend Only]** winname can be empty (or NULL) if the trackbar is attached to the control
panel.

</member>
        <member name="M:cv.setTrackbarPos(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Sets the trackbar position.

@param trackbarname Name of the trackbar.
@param winname Name of the window that is the parent of trackbar.
@param pos New position.

The function sets the position of the specified trackbar in the specified window.

@note

**[Qt Backend Only]** winname can be empty (or NULL) if the trackbar is attached to the control
panel.

</member>
        <member name="M:cv.getTrackbarPos(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Returns the trackbar position.

@param trackbarname Name of the trackbar.
@param winname Name of the window that is the parent of the trackbar.

The function returns the current position of the specified trackbar.

@note

**[Qt Backend Only]** winname can be empty (or NULL) if the trackbar is attached to the control
panel.


</member>
        <member name="M:cv.createTrackbar(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*,System.Int32,=FUNC:System.Void(System.Int32,System.Void*),System.Void*)">
@brief Creates a trackbar and attaches it to the specified window.

@param trackbarname Name of the created trackbar.
@param winname Name of the window that will be used as a parent of the created trackbar.
@param value Optional pointer to an integer variable whose value reflects the position of the
slider. Upon creation, the slider position is defined by this variable.
@param count Maximal position of the slider. The minimal position is always 0.
@param onChange Pointer to the function to be called every time the slider changes position. This
function should be prototyped as void Foo(int,void\*); , where the first parameter is the trackbar
position and the second parameter is the user data (see the next parameter). If the callback is
the NULL pointer, no callbacks are called, but only value is updated.
@param userdata User data that is passed as is to the callback. It can be used to handle trackbar
events without using global variables.

The function createTrackbar creates a trackbar (a slider or range control) with the specified name
and range, assigns a variable value to be a position synchronized with the trackbar and specifies
the callback function onChange to be called on the trackbar position change. The created trackbar is
displayed in the specified window winname.

@note

**[Qt Backend Only]** winname can be empty (or NULL) if the trackbar should be attached to the
control panel.

Clicking the label of each trackbar enables editing the trackbar values manually.

@note

-   An example of using the trackbar functionality can be found at
    opencv_source_code/samples/cpp/connected_components.cpp

</member>
        <member name="M:cv.getMouseWheelDelta(System.Int32)">
@brief Gets the mouse-wheel motion delta, when handling mouse-wheel events EVENT_MOUSEWHEEL and
EVENT_MOUSEHWHEEL.

@param flags The mouse callback flags parameter.

For regular mice with a scroll-wheel, delta will be a multiple of 120. The value 120 corresponds to
a one notch rotation of the wheel or the threshold for action to be taken and one such action should
occur for each delta. Some high-precision mice with higher-resolution freely-rotating wheels may
generate smaller values.

For EVENT_MOUSEWHEEL positive and negative values mean forward and backward scrolling,
respectively. For EVENT_MOUSEHWHEEL, where available, positive and negative values mean right and
left scrolling, respectively.

With the C API, the macro CV_GET_WHEEL_DELTA(flags) can be used alternatively.

@note

Mouse-wheel events are currently supported only on Windows.

</member>
        <member name="M:cv.getWindowProperty(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Provides parameters of a window.

@param winname Name of the window.
@param prop_id Window property to retrieve. The following operation flags are available:
 -   **CV_WND_PROP_FULLSCREEN** Change if the window is fullscreen ( CV_WINDOW_NORMAL or
     CV_WINDOW_FULLSCREEN ).
 -   **CV_WND_PROP_AUTOSIZE** Change if the window is resizable (CV_WINDOW_NORMAL or
     CV_WINDOW_AUTOSIZE ).
 -   **CV_WND_PROP_ASPECTRATIO** Change if the aspect ratio of the image is preserved
     (CV_WINDOW_FREERATIO or CV_WINDOW_KEEPRATIO ).

See setWindowProperty to know the meaning of the returned values.

The function getWindowProperty returns properties of a window.

</member>
        <member name="M:cv.setWindowTitle(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Updates window title

</member>
        <member name="M:cv.setWindowProperty(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double)">
@brief Changes parameters of a window dynamically.

@param winname Name of the window.
@param prop_id Window property to edit. The following operation flags are available:
 -   **CV_WND_PROP_FULLSCREEN** Change if the window is fullscreen ( CV_WINDOW_NORMAL or
     CV_WINDOW_FULLSCREEN ).
 -   **CV_WND_PROP_AUTOSIZE** Change if the window is resizable (CV_WINDOW_NORMAL or
     CV_WINDOW_AUTOSIZE ).
 -   **CV_WND_PROP_ASPECTRATIO** Change if the aspect ratio of the image is preserved (
     CV_WINDOW_FREERATIO or CV_WINDOW_KEEPRATIO ).
@param prop_value New value of the window property. The following operation flags are available:
 -   **CV_WINDOW_NORMAL** Change the window to normal size or make the window resizable.
 -   **CV_WINDOW_AUTOSIZE** Constrain the size by the displayed image. The window is not
     resizable.
 -   **CV_WINDOW_FULLSCREEN** Change the window to fullscreen.
 -   **CV_WINDOW_FREERATIO** Make the window resizable without any ratio constraints.
 -   **CV_WINDOW_KEEPRATIO** Make the window resizable, but preserve the proportions of the
     displayed image.

The function setWindowProperty enables changing properties of a window.

</member>
        <member name="M:cv.moveWindow(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief Moves window to the specified position

@param winname Window name
@param x The new x-coordinate of the window
@param y The new y-coordinate of the window

</member>
        <member name="M:cv.resizeWindow(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief Resizes window to the specified size

@param winname Window name
@param width The new window width
@param height The new window height

@note

-   The specified window size is for the image area. Toolbars are not counted.
-   Only windows created without CV_WINDOW_AUTOSIZE flag can be resized.

</member>
        <member name="M:cv.imshow(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Displays an image in the specified window.

@param winname Name of the window.
@param mat Image to be shown.

The function imshow displays an image in the specified window. If the window was created with the
CV_WINDOW_AUTOSIZE flag, the image is shown with its original size, however it is still limited by the screen resolution.
Otherwise, the image is scaled to fit the window. The function may scale the image, depending on its depth:

-   If the image is 8-bit unsigned, it is displayed as is.
-   If the image is 16-bit unsigned or 32-bit integer, the pixels are divided by 256. That is, the
    value range [0,255\*256] is mapped to [0,255].
-   If the image is 32-bit floating-point, the pixel values are multiplied by 255. That is, the
    value range [0,1] is mapped to [0,255].

If window was created with OpenGL support, imshow also support ogl::Buffer , ogl::Texture2D and
cuda::GpuMat as input.

If the window was not created before this function, it is assumed creating a window with CV_WINDOW_AUTOSIZE.

If you need to show an image that is bigger than the screen resolution, you will need to call namedWindow("", WINDOW_NORMAL) before the imshow.

@note This function should be followed by waitKey function which displays the image for specified
milliseconds. Otherwise, it won't display the image. For example, waitKey(0) will display the window
infinitely until any keypress (it is suitable for image display). waitKey(25) will display a frame
for 25 ms, after which display will be automatically closed. (If you put it in a loop to read
videos, it will display the video frame-by-frame)

@note

[Windows Backend Only] Pressing Ctrl+C will copy the image to the clipboard.


</member>
        <member name="M:cv.waitKey(System.Int32)">
@brief Waits for a pressed key.

@param delay Delay in milliseconds. 0 is the special value that means "forever".

The function waitKey waits for a key event infinitely (when \f$\texttt{delay}\leq 0\f$ ) or for delay
milliseconds, when it is positive. Since the OS has a minimum time between switching threads, the
function will not wait exactly delay ms, it will wait at least delay ms, depending on what else is
running on your computer at that time. It returns the code of the pressed key or -1 if no key was
pressed before the specified time had elapsed.

@note

This function is the only method in HighGUI that can fetch and handle events, so it needs to be
called periodically for normal event processing unless HighGUI is used within an environment that
takes care of event processing.

@note

The function only works if there is at least one HighGUI window created and the window is active.
If there are several HighGUI windows, any of them can be active.

</member>
        <member name="M:cv.destroyAllWindows">
@brief Destroys all of the HighGUI windows.

The function destroyAllWindows destroys all of the opened HighGUI windows.

</member>
        <member name="M:cv.destroyWindow(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Destroys a window.

@param winname Name of the window to be destroyed.

The function destroyWindow destroys the window with the given name.

</member>
        <member name="M:cv.namedWindow(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Creates a window.

@param winname Name of the window in the window caption that may be used as a window identifier.
@param flags Flags of the window. The supported flags are:
&gt; -   **WINDOW_NORMAL** If this is set, the user can resize the window (no constraint).
&gt; -   **WINDOW_AUTOSIZE** If this is set, the window size is automatically adjusted to fit the
&gt;     displayed image (see imshow ), and you cannot change the window size manually.
&gt; -   **WINDOW_OPENGL** If this is set, the window will be created with OpenGL support.

The function namedWindow creates a window that can be used as a placeholder for images and
trackbars. Created windows are referred to by their names.

If a window with the same name already exists, the function does nothing.

You can call destroyWindow or destroyAllWindows to close the window and de-allocate any associated
memory usage. For a simple program, you do not really have to call these functions because all the
resources and windows of the application are closed automatically by the operating system upon exit.

@note

Qt backend supports additional flags:
 -   **CV_WINDOW_NORMAL or CV_WINDOW_AUTOSIZE:** CV_WINDOW_NORMAL enables you to resize the
     window, whereas CV_WINDOW_AUTOSIZE adjusts automatically the window size to fit the
     displayed image (see imshow ), and you cannot change the window size manually.
 -   **CV_WINDOW_FREERATIO or CV_WINDOW_KEEPRATIO:** CV_WINDOW_FREERATIO adjusts the image
     with no respect to its ratio, whereas CV_WINDOW_KEEPRATIO keeps the image ratio.
 -   **CV_GUI_NORMAL or CV_GUI_EXPANDED:** CV_GUI_NORMAL is the old way to draw the window
     without statusbar and toolbar, whereas CV_GUI_EXPANDED is a new enhanced GUI.
By default, flags == CV_WINDOW_AUTOSIZE | CV_WINDOW_KEEPRATIO | CV_GUI_EXPANDED

</member>
        <member name="M:cv.VideoWriter.fourcc(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
@brief Concatenates 4 chars to a fourcc code

    This static method constructs the fourcc code of the codec to be used in the constructor
    VideoWriter::VideoWriter or VideoWriter::open.

</member>
        <member name="M:cv.VideoWriter.get(System.Int32)">
@brief Returns the specified VideoWriter property

     @param propId Property identifier. It can be one of the following:
     -   **VIDEOWRITER_PROP_QUALITY** Current quality of the encoded videostream.
     -   **VIDEOWRITER_PROP_FRAMEBYTES** (Read-only) Size of just encoded video frame; note that the encoding order may be different from representation order.

     @note When querying a property that is not supported by the backend used by the VideoWriter
     class, value 0 is returned.

</member>
        <member name="M:cv.VideoWriter.set(System.Int32,System.Double)">
@brief Sets a property in the VideoWriter.

     @param propId Property identifier. It can be one of the following:
     -   **VIDEOWRITER_PROP_QUALITY** Quality (0..100%) of the videostream encoded. Can be adjusted dynamically in some codecs.
     @param value Value of the property.

</member>
        <member name="M:cv.VideoWriter.write(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Writes the next video frame

    @param image The written frame

    The functions/methods write the specified image to video file. It must have the same size as has
    been specified when opening the video writer.

</member>
        <member name="M:cv.VideoWriter.release">
@brief Closes the video writer.

    The methods are automatically called by subsequent VideoWriter::open and by the VideoWriter
    destructor.

</member>
        <member name="M:cv.VideoWriter.isOpened">
@brief Returns true if video writer has been successfully initialized.

</member>
        <member name="M:cv.VideoWriter.open(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,cv.Size_&lt;System.Int32&gt;,System.Boolean)">
@brief Initializes or reinitializes video writer.

    The method opens video writer. Parameters are the same as in the constructor
    VideoWriter::VideoWriter.

</member>
        <member name="M:cv.VideoWriter.#ctor(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,cv.Size_&lt;System.Int32&gt;,System.Boolean)">
@overload
    @param filename Name of the output video file.
    @param fourcc 4-character code of codec used to compress the frames. For example,
    VideoWriter::fourcc('P','I','M','1') is a MPEG-1 codec, VideoWriter::fourcc('M','J','P','G') is a
    motion-jpeg codec etc. List of codes can be obtained at [Video Codecs by
    FOURCC](http://www.fourcc.org/codecs.php) page.
    @param fps Framerate of the created video stream.
    @param frameSize Size of the video frames.
    @param isColor If it is not zero, the encoder will expect and encode color frames, otherwise it
    will work with grayscale frames (the flag is currently supported on Windows only).

</member>
        <member name="M:cv.VideoWriter.#ctor">
@brief VideoWriter constructors

    The constructors/functions initialize video writers. On Linux FFMPEG is used to write videos; on
    Windows FFMPEG or VFW is used; on MacOSX QTKit is used.

</member>
        <member name="T:cv.VideoWriter">
@brief Video writer class.

</member>
        <member name="M:cv.VideoCapture.get(System.Int32)">
@brief Returns the specified VideoCapture property

    @param propId Property identifier. It can be one of the following:
     -   **CAP_PROP_POS_MSEC** Current position of the video file in milliseconds or video
         capture timestamp.
     -   **CAP_PROP_POS_FRAMES** 0-based index of the frame to be decoded/captured next.
     -   **CAP_PROP_POS_AVI_RATIO** Relative position of the video file: 0 - start of the
         film, 1 - end of the film.
     -   **CAP_PROP_FRAME_WIDTH** Width of the frames in the video stream.
     -   **CAP_PROP_FRAME_HEIGHT** Height of the frames in the video stream.
     -   **CAP_PROP_FPS** Frame rate.
     -   **CAP_PROP_FOURCC** 4-character code of codec.
     -   **CAP_PROP_FRAME_COUNT** Number of frames in the video file.
     -   **CAP_PROP_FORMAT** Format of the Mat objects returned by retrieve() .
     -   **CAP_PROP_MODE** Backend-specific value indicating the current capture mode.
     -   **CAP_PROP_BRIGHTNESS** Brightness of the image (only for cameras).
     -   **CAP_PROP_CONTRAST** Contrast of the image (only for cameras).
     -   **CAP_PROP_SATURATION** Saturation of the image (only for cameras).
     -   **CAP_PROP_HUE** Hue of the image (only for cameras).
     -   **CAP_PROP_GAIN** Gain of the image (only for cameras).
     -   **CAP_PROP_EXPOSURE** Exposure (only for cameras).
     -   **CAP_PROP_CONVERT_RGB** Boolean flags indicating whether images should be converted
         to RGB.
     -   **CAP_PROP_WHITE_BALANCE** Currently not supported
     -   **CAP_PROP_RECTIFICATION** Rectification flag for stereo cameras (note: only supported
         by DC1394 v 2.x backend currently)

    @note When querying a property that is not supported by the backend used by the VideoCapture
    class, value 0 is returned.

</member>
        <member name="M:cv.VideoCapture.set(System.Int32,System.Double)">
@brief Sets a property in the VideoCapture.

    @param propId Property identifier. It can be one of the following:
     -   **CAP_PROP_POS_MSEC** Current position of the video file in milliseconds.
     -   **CAP_PROP_POS_FRAMES** 0-based index of the frame to be decoded/captured next.
     -   **CAP_PROP_POS_AVI_RATIO** Relative position of the video file: 0 - start of the
         film, 1 - end of the film.
     -   **CAP_PROP_FRAME_WIDTH** Width of the frames in the video stream.
     -   **CAP_PROP_FRAME_HEIGHT** Height of the frames in the video stream.
     -   **CAP_PROP_FPS** Frame rate.
     -   **CAP_PROP_FOURCC** 4-character code of codec.
     -   **CAP_PROP_FRAME_COUNT** Number of frames in the video file.
     -   **CAP_PROP_FORMAT** Format of the Mat objects returned by retrieve() .
     -   **CAP_PROP_MODE** Backend-specific value indicating the current capture mode.
     -   **CAP_PROP_BRIGHTNESS** Brightness of the image (only for cameras).
     -   **CAP_PROP_CONTRAST** Contrast of the image (only for cameras).
     -   **CAP_PROP_SATURATION** Saturation of the image (only for cameras).
     -   **CAP_PROP_HUE** Hue of the image (only for cameras).
     -   **CAP_PROP_GAIN** Gain of the image (only for cameras).
     -   **CAP_PROP_EXPOSURE** Exposure (only for cameras).
     -   **CAP_PROP_CONVERT_RGB** Boolean flags indicating whether images should be converted
         to RGB.
     -   **CAP_PROP_WHITE_BALANCE** Currently unsupported
     -   **CAP_PROP_RECTIFICATION** Rectification flag for stereo cameras (note: only supported
         by DC1394 v 2.x backend currently)
    @param value Value of the property.

</member>
        <member name="M:cv.VideoCapture.read(cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Grabs, decodes and returns the next video frame.

    The methods/functions combine VideoCapture::grab and VideoCapture::retrieve in one call. This is the
    most convenient method for reading video files or capturing data from decode and return the just
    grabbed frame. If no frames has been grabbed (camera has been disconnected, or there are no more
    frames in video file), the methods return false and the functions return NULL pointer.

    @note OpenCV 1.x functions cvRetrieveFrame and cv.RetrieveFrame return image stored inside the video
    capturing structure. It is not allowed to modify or release the image! You can copy the frame using
    :ocvcvCloneImage and then do whatever you want with the copy.

</member>
        <member name="M:cv.VideoCapture.retrieve(cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Decodes and returns the grabbed video frame.

    The methods/functions decode and return the just grabbed frame. If no frames has been grabbed
    (camera has been disconnected, or there are no more frames in video file), the methods return false
    and the functions return NULL pointer.

    @note OpenCV 1.x functions cvRetrieveFrame and cv.RetrieveFrame return image stored inside the video
    capturing structure. It is not allowed to modify or release the image! You can copy the frame using
    :ocvcvCloneImage and then do whatever you want with the copy.

</member>
        <member name="M:cv.VideoCapture.release">
@brief Closes video file or capturing device.

    The methods are automatically called by subsequent VideoCapture::open and by VideoCapture
    destructor.

    The C function also deallocates memory and clears \*capture pointer.

</member>
        <member name="M:cv.VideoCapture.isOpened">
@brief Returns true if video capturing has been initialized already.

    If the previous call to VideoCapture constructor or VideoCapture::open succeeded, the method returns
    true.

</member>
        <member name="M:cv.VideoCapture.open(System.Int32)">
@overload
    @param device id of the opened video capturing device (i.e. a camera index).

</member>
        <member name="M:cv.VideoCapture.open(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Open video file or a capturing device for video capturing

    @param filename name of the opened video file (eg. video.avi) or image sequence (eg.
    img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)

    The methods first call VideoCapture::release to close the already opened file or camera.

</member>
        <member name="M:cv.VideoCapture.#ctor(System.Int32)">
@overload
    @param device id of the opened video capturing device (i.e. a camera index). If there is a single
    camera connected, just pass 0.

</member>
        <member name="M:cv.VideoCapture.#ctor(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param filename name of the opened video file (eg. video.avi) or image sequence (eg.
    img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)

</member>
        <member name="T:cv.VideoCapture">
@brief Class for video capturing from video files, image sequences or cameras. The class provides C++ API
for capturing video from cameras or for reading video files and image sequences. Here is how the
class can be used: :
@code
    #include "opencv2/opencv.hpp"

    using namespace cv;

    int main(int, char**)
    {
        VideoCapture cap(0); // open the default camera
        if(!cap.isOpened())  // check if we succeeded
            return -1;

        Mat edges;
        namedWindow("edges",1);
        for(;;)
        {
            Mat frame;
            cap &gt;&gt; frame; // get a new frame from camera
            cvtColor(frame, edges, COLOR_BGR2GRAY);
            GaussianBlur(edges, edges, Size(7,7), 1.5, 1.5);
            Canny(edges, edges, 0, 30, 3);
            imshow("edges", edges);
            if(waitKey(30) &gt;= 0) break;
        }
        // the camera will be deinitialized automatically in VideoCapture destructor
        return 0;
    }
@endcode
@note In C API the black-box structure CvCapture is used instead of VideoCapture.

@note
-   A basic sample on using the VideoCapture interface can be found at
    opencv_source_code/samples/cpp/starter_video.cpp
-   Another basic video processing sample can be found at
    opencv_source_code/samples/cpp/video_dmtx.cpp
-   (Python) A basic sample on using the VideoCapture interface can be found at
    opencv_source_code/samples/python2/video.py
-   (Python) Another basic video processing sample can be found at
    opencv_source_code/samples/python2/video_dmtx.py
-   (Python) A multi threaded video processing sample can be found at
    opencv_source_code/samples/python2/video_threaded.py

</member>
        <member name="T:CvCapture">
@defgroup videoio Media I/O
@{
  @defgroup videoio_c C API
  @defgroup videoio_ios iOS glue
  @defgroup videoio_winrt WinRT glue
@}


@addtogroup videoio_c
@{

</member>
        <member name="M:cv.imencode(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Encodes an image into a memory buffer.

@param ext File extension that defines the output format.
@param img Image to be written.
@param buf Output buffer resized to fit the compressed image.
@param params Format-specific parameters. See imwrite and @ref cv::ImwriteFlags.

The function compresses the image and stores it in the memory buffer that is resized to fit the
result. See imwrite for the list of supported formats and flags description.

@note cvEncodeImage returns single-row matrix of type CV_8UC1 that contains encoded image as array
of bytes.

</member>
        <member name="M:cv.imdecode(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.Mat*)">
@brief Reads an image from a buffer in memory.

@param buf Input array or vector of bytes.
@param flags The same flags as in imread, see @ref cv::ImreadModes.
@param dst The optional output placeholder for the decoded matrix. It can save the image
reallocations when the function is called repeatedly for images of the same size.

The function reads an image from the specified buffer in the memory. If the buffer is too short or
contains invalid data, the empty matrix/image is returned.

See imread for the list of supported formats and flags description.

@note In the case of color images, the decoded images will have the channels stored in B G R order.

</member>
        <member name="M:cv.imdecode(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@overload 
</member>
        <member name="M:cv.imreadmulti(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Mat&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Loads a multi-page image from a file. (see imread for details.)

@param filename Name of file to be loaded.
@param flags Flag that can take values of @ref cv::ImreadModes, default with IMREAD_ANYCOLOR.
@param mats A vector of Mat objects holding each page, if more than one.


</member>
        <member name="M:cv.imread(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Loads an image from a file.

@anchor imread

@param filename Name of file to be loaded.
@param flags Flag that can take values of @ref cv::ImreadModes

The function imread loads an image from the specified file and returns it. If the image cannot be
read (because of missing file, improper permissions, unsupported or invalid format), the function
returns an empty matrix ( Mat::data==NULL ). Currently, the following file formats are supported:

-   Windows bitmaps - \*.bmp, \*.dib (always supported)
-   JPEG files - \*.jpeg, \*.jpg, \*.jpe (see the *Notes* section)
-   JPEG 2000 files - \*.jp2 (see the *Notes* section)
-   Portable Network Graphics - \*.png (see the *Notes* section)
-   WebP - \*.webp (see the *Notes* section)
-   Portable image format - \*.pbm, \*.pgm, \*.ppm (always supported)
-   Sun rasters - \*.sr, \*.ras (always supported)
-   TIFF files - \*.tiff, \*.tif (see the *Notes* section)

@note

-   The function determines the type of an image by the content, not by the file extension.
-   On Microsoft Windows\* OS and MacOSX\*, the codecs shipped with an OpenCV image (libjpeg,
    libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs,
    and TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware
    that currently these native image loaders give images with different pixel values because of
    the color management embedded into MacOSX.
-   On Linux\*, BSD flavors and other Unix-like open-source operating systems, OpenCV looks for
    codecs supplied with an OS image. Install the relevant packages (do not forget the development
    files, for example, "libjpeg-dev", in Debian\* and Ubuntu\*) to get the codec support or turn
    on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake.

@note In the case of color images, the decoded images will have the channels stored in B G R order.

</member>
        <member name="T:CvPOSITObject">
@addtogroup calib3d_c
  @{

</member>
        <member name="M:cv.fisheye.stereoCalibrate(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices">
@brief Performs stereo calibration

    @param objectPoints Vector of vectors of the calibration pattern points.
    @param imagePoints1 Vector of vectors of the projections of the calibration pattern points,
    observed by the first camera.
    @param imagePoints2 Vector of vectors of the projections of the calibration pattern points,
    observed by the second camera.
    @param K1 Input/output first camera matrix:
    \f$\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}\f$ , \f$j = 0,\, 1\f$ . If
    any of fisheye::CALIB_USE_INTRINSIC_GUESS , fisheye::CV_CALIB_FIX_INTRINSIC are specified,
    some or all of the matrix components must be initialized.
    @param D1 Input/output vector of distortion coefficients \f$(k_1, k_2, k_3, k_4)\f$ of 4 elements.
    @param K2 Input/output second camera matrix. The parameter is similar to K1 .
    @param D2 Input/output lens distortion coefficients for the second camera. The parameter is
    similar to D1 .
    @param imageSize Size of the image used only to initialize intrinsic camera matrix.
    @param R Output rotation matrix between the 1st and the 2nd camera coordinate systems.
    @param T Output translation vector between the coordinate systems of the cameras.
    @param flags Different flags that may be zero or a combination of the following values:
    -   **fisheye::CV_CALIB_FIX_INTRINSIC** Fix K1, K2? and D1, D2? so that only R, T matrices
    are estimated.
    -   **fisheye::CALIB_USE_INTRINSIC_GUESS** K1, K2 contains valid initial values of
    fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image
    center (imageSize is used), and focal distances are computed in a least-squares fashion.
    -   **fisheye::CALIB_RECOMPUTE_EXTRINSIC** Extrinsic will be recomputed after each iteration
    of intrinsic optimization.
    -   **fisheye::CALIB_CHECK_COND** The functions will check validity of condition number.
    -   **fisheye::CALIB_FIX_SKEW** Skew coefficient (alpha) is set to zero and stay zero.
    -   **fisheye::CALIB_FIX_K1..4** Selected distortion coefficients are set to zeros and stay
    zero.
    @param criteria Termination criteria for the iterative optimization algorithm.

</member>
        <member name="M:cv.fisheye.stereoRectify(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.R">
@brief Stereo rectification for fisheye camera model

    @param K1 First camera matrix.
    @param D1 First camera distortion parameters.
    @param K2 Second camera matrix.
    @param D2 Second camera distortion parameters.
    @param imageSize Size of the image used for stereo calibration.
    @param R Rotation matrix between the coordinate systems of the first and the second
    cameras.
    @param tvec Translation vector between coordinate systems of the cameras.
    @param R1 Output 3x3 rectification transform (rotation matrix) for the first camera.
    @param R2 Output 3x3 rectification transform (rotation matrix) for the second camera.
    @param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first
    camera.
    @param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second
    camera.
    @param Q Output \f$4 \times 4\f$ disparity-to-depth mapping matrix (see reprojectImageTo3D ).
    @param flags Operation flags that may be zero or CV_CALIB_ZERO_DISPARITY . If the flag is set,
    the function makes the principal points of each camera have the same pixel coordinates in the
    rectified views. And if the flag is not set, the function may still shift the images in the
    horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the
    useful image area.
    @param newImageSize New image resolution after rectification. The same size should be passed to
    initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)
    is passed (default), it is set to the original imageSize . Setting it to larger value can help you
    preserve details in the original image, especially when there is a big radial distortion.
    @param balance Sets the new focal length in range between the min focal length and the max focal
    length. Balance is in range of [0, 1].
    @param fov_scale Divisor for new focal length.

</member>
        <member name="M:cv.fisheye.calibrate(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst">
@brief Performs camera calibaration

    @param objectPoints vector of vectors of calibration pattern points in the calibration pattern
    coordinate space.
    @param imagePoints vector of vectors of the projections of calibration pattern points.
    imagePoints.size() and objectPoints.size() and imagePoints[i].size() must be equal to
    objectPoints[i].size() for each i.
    @param image_size Size of the image used only to initialize the intrinsic camera matrix.
    @param K Output 3x3 floating-point camera matrix
    \f$A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\f$ . If
    fisheye::CALIB_USE_INTRINSIC_GUESS/ is specified, some or all of fx, fy, cx, cy must be
    initialized before calling the function.
    @param D Output vector of distortion coefficients \f$(k_1, k_2, k_3, k_4)\f$.
    @param rvecs Output vector of rotation vectors (see Rodrigues ) estimated for each pattern view.
    That is, each k-th rotation vector together with the corresponding k-th translation vector (see
    the next output parameter description) brings the calibration pattern from the model coordinate
    space (in which object points are specified) to the world coordinate space, that is, a real
    position of the calibration pattern in the k-th pattern view (k=0.. *M* -1).
    @param tvecs Output vector of translation vectors estimated for each pattern view.
    @param flags Different flags that may be zero or a combination of the following values:
    -   **fisheye::CALIB_USE_INTRINSIC_GUESS** cameraMatrix contains valid initial values of
    fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image
    center ( imageSize is used), and focal distances are computed in a least-squares fashion.
    -   **fisheye::CALIB_RECOMPUTE_EXTRINSIC** Extrinsic will be recomputed after each iteration
    of intrinsic optimization.
    -   **fisheye::CALIB_CHECK_COND** The functions will check validity of condition number.
    -   **fisheye::CALIB_FIX_SKEW** Skew coefficient (alpha) is set to zero and stay zero.
    -   **fisheye::CALIB_FIX_K1..4** Selected distortion coefficients are set to zeros and stay
    zero.
    @param criteria Termination criteria for the iterative optimization algorithm.

</member>
        <member name="M:cv.fisheye.estimateNewCameraMatrixForUndistortRectify(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Doubl">
@brief Estimates new camera matrix for undistortion or rectification.

    @param K Camera matrix \f$K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\f$.
    @param image_size
    @param D Input vector of distortion coefficients \f$(k_1, k_2, k_3, k_4)\f$.
    @param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3
    1-channel or 1x1 3-channel
    @param P New camera matrix (3x3) or new projection matrix (3x4)
    @param balance Sets the new focal length in range between the min focal length and the max focal
    length. Balance is in range of [0, 1].
    @param new_size
    @param fov_scale Divisor for new focal length.

</member>
        <member name="M:cv.fisheye.undistortImage(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Transforms an image to compensate for fisheye lens distortion.

    @param distorted image with fisheye lens distortion.
    @param undistorted Output image with compensated fisheye lens distortion.
    @param K Camera matrix \f$K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\f$.
    @param D Input vector of distortion coefficients \f$(k_1, k_2, k_3, k_4)\f$.
    @param Knew Camera matrix of the distorted image. By default, it is the identity matrix but you
    may additionally scale and shift the result by using a different matrix.
    @param new_size

    The function transforms an image to compensate radial and tangential lens distortion.

    The function is simply a combination of fisheye::initUndistortRectifyMap (with unity R ) and remap
    (with bilinear interpolation). See the former function for details of the transformation being
    performed.

    See below the results of undistortImage.
       -   a\) result of undistort of perspective camera model (all possible coefficients (k_1, k_2, k_3,
            k_4, k_5, k_6) of distortion were optimized under calibration)
        -   b\) result of fisheye::undistortImage of fisheye camera model (all possible coefficients (k_1, k_2,
            k_3, k_4) of fisheye distortion were optimized under calibration)
        -   c\) original image was captured with fisheye lens

    Pictures a) and b) almost the same. But if we consider points of image located far from the center
    of image, we can notice that on image a) these points are distorted.

    ![image](pics/fisheye_undistorted.jpg)

</member>
        <member name="M:cv.fisheye.initUndistortRectifyMap(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerS">
@brief Computes undistortion and rectification maps for image transform by cv::remap(). If D is empty zero
    distortion is used, if R or P is empty identity matrixes are used.

    @param K Camera matrix \f$K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\f$.
    @param D Input vector of distortion coefficients \f$(k_1, k_2, k_3, k_4)\f$.
    @param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3
    1-channel or 1x1 3-channel
    @param P New camera matrix (3x3) or new projection matrix (3x4)
    @param size Undistorted image size.
    @param m1type Type of the first output map that can be CV_32FC1 or CV_16SC2 . See convertMaps()
    for details.
    @param map1 The first output map.
    @param map2 The second output map.

</member>
        <member name="M:cv.fisheye.projectPoints(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!">
@overload 
</member>
        <member name="M:cv.StereoSGBM.create(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
@brief Creates StereoSGBM object

    @param minDisparity Minimum possible disparity value. Normally, it is zero but sometimes
    rectification algorithms can shift images, so this parameter needs to be adjusted accordingly.
    @param numDisparities Maximum disparity minus minimum disparity. The value is always greater than
    zero. In the current implementation, this parameter must be divisible by 16.
    @param blockSize Matched block size. It must be an odd number \&gt;=1 . Normally, it should be
    somewhere in the 3..11 range.
    @param P1 The first parameter controlling the disparity smoothness. See below.
    @param P2 The second parameter controlling the disparity smoothness. The larger the values are,
    the smoother the disparity is. P1 is the penalty on the disparity change by plus or minus 1
    between neighbor pixels. P2 is the penalty on the disparity change by more than 1 between neighbor
    pixels. The algorithm requires P2 \&gt; P1 . See stereo_match.cpp sample where some reasonably good
    P1 and P2 values are shown (like 8\*number_of_image_channels\*SADWindowSize\*SADWindowSize and
    32\*number_of_image_channels\*SADWindowSize\*SADWindowSize , respectively).
    @param disp12MaxDiff Maximum allowed difference (in integer pixel units) in the left-right
    disparity check. Set it to a non-positive value to disable the check.
    @param preFilterCap Truncation value for the prefiltered image pixels. The algorithm first
    computes x-derivative at each pixel and clips its value by [-preFilterCap, preFilterCap] interval.
    The result values are passed to the Birchfield-Tomasi pixel cost function.
    @param uniquenessRatio Margin in percentage by which the best (minimum) computed cost function
    value should "win" the second best value to consider the found match correct. Normally, a value
    within the 5-15 range is good enough.
    @param speckleWindowSize Maximum size of smooth disparity regions to consider their noise speckles
    and invalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in the
    50-200 range.
    @param speckleRange Maximum disparity variation within each connected component. If you do speckle
    filtering, set the parameter to a positive value, it will be implicitly multiplied by 16.
    Normally, 1 or 2 is good enough.
    @param mode Set it to StereoSGBM::MODE_HH to run the full-scale two-pass dynamic programming
    algorithm. It will consume O(W\*H\*numDisparities) bytes, which is large for 640x480 stereo and
    huge for HD-size pictures. By default, it is set to false .

    The first constructor initializes StereoSGBM with all the default parameters. So, you only have to
    set StereoSGBM::numDisparities at minimum. The second constructor enables you to set each parameter
    to a custom value.

</member>
        <member name="T:cv.StereoSGBM">
@brief The class implements the modified H. Hirschmuller algorithm @cite HH08 that differs from the original
one as follows:

-   By default, the algorithm is single-pass, which means that you consider only 5 directions
instead of 8. Set mode=StereoSGBM::MODE_HH in createStereoSGBM to run the full variant of the
algorithm but beware that it may consume a lot of memory.
-   The algorithm matches blocks, not individual pixels. Though, setting blockSize=1 reduces the
blocks to single pixels.
-   Mutual information cost function is not implemented. Instead, a simpler Birchfield-Tomasi
sub-pixel metric from @cite BT98 is used. Though, the color images are supported as well.
-   Some pre- and post- processing steps from K. Konolige algorithm StereoBM are included, for
example: pre-filtering (StereoBM::PREFILTER_XSOBEL type) and post-filtering (uniqueness
check, quadratic interpolation and speckle filtering).

@note
   -   (Python) An example illustrating the use of the StereoSGBM matching algorithm can be found
        at opencv_source_code/samples/python2/stereo_match.py

</member>
        <member name="M:cv.StereoBM.create(System.Int32,System.Int32)">
@brief Creates StereoBM object

    @param numDisparities the disparity search range. For each pixel algorithm will find the best
    disparity from 0 (default minimum disparity) to numDisparities. The search range can then be
    shifted by changing the minimum disparity.
    @param blockSize the linear size of the blocks compared by the algorithm. The size should be odd
    (as the block is centered at the current pixel). Larger block size implies smoother, though less
    accurate disparity map. Smaller block size gives more detailed disparity map, but there is higher
    chance for algorithm to find a wrong correspondence.

    The function create StereoBM object. You can then call StereoBM::compute() to compute disparity for
    a specific stereo pair.

</member>
        <member name="T:cv.StereoBM">
@brief Class for computing stereo correspondence using the block matching algorithm, introduced and
contributed to OpenCV by K. Konolige.

</member>
        <member name="M:cv.StereoMatcher.compute(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes disparity map for the specified stereo pair

    @param left Left 8-bit single-channel image.
    @param right Right image of the same size and the same type as the left one.
    @param disparity Output disparity map. It has the same size as the input images. Some algorithms,
    like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map (where each disparity value
    has 4 fractional bits), whereas other algorithms output 32-bit floating-point disparity map.

</member>
        <member name="T:cv.StereoMatcher">
@brief The base class for stereo correspondence algorithms.

</member>
        <member name="M:cv.decomposeHomographyMat(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Decompose a homography matrix to rotation(s), translation(s) and plane normal(s).

@param H The input homography matrix between two images.
@param K The input intrinsic camera calibration matrix.
@param rotations Array of rotation matrices.
@param translations Array of translation matrices.
@param normals Array of plane normal matrices.

This function extracts relative camera motion between two views observing a planar object from the
homography H induced by the plane. The intrinsic camera matrix K must also be provided. The function
may return up to four mathematical solution sets. At least two of the solutions may further be
invalidated if point correspondences are available by applying positive depth constraint (all points
must be in front of the camera). The decomposition method is described in detail in @cite Malis .

</member>
        <member name="M:cv.estimateAffine3D(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief Computes an optimal affine transformation between two 3D point sets.

@param src First input 3D point set.
@param dst Second input 3D point set.
@param out Output 3D affine transformation matrix \f$3 \times 4\f$ .
@param inliers Output vector indicating which points are inliers.
@param ransacThreshold Maximum reprojection error in the RANSAC algorithm to consider a point as
an inlier.
@param confidence Confidence level, between 0 and 1, for the estimated transformation. Anything
between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

The function estimates an optimal 3D affine transformation between two 3D point sets using the
RANSAC algorithm.

</member>
        <member name="M:cv.reprojectImageTo3D(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Int32)">
@brief Reprojects a disparity image to 3D space.

@param disparity Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit
floating-point disparity image.
@param _3dImage Output 3-channel floating-point image of the same size as disparity . Each
element of _3dImage(x,y) contains 3D coordinates of the point (x,y) computed from the disparity
map.
@param Q \f$4 \times 4\f$ perspective transformation matrix that can be obtained with stereoRectify.
@param handleMissingValues Indicates, whether the function should handle missing values (i.e.
points where the disparity was not computed). If handleMissingValues=true, then pixels with the
minimal disparity that corresponds to the outliers (see StereoMatcher::compute ) are transformed
to 3D points with a very large Z value (currently set to 10000).
@param ddepth The optional output array depth. If it is -1, the output image will have CV_32F
depth. ddepth can also be set to CV_16S, CV_32S or CV_32F.

The function transforms a single-channel disparity map to a 3-channel image representing a 3D
surface. That is, for each pixel (x,y) andthe corresponding disparity d=disparity(x,y) , it
computes:

\f[\begin{array}{l} [X \; Y \; Z \; W]^T =  \texttt{Q} *[x \; y \; \texttt{disparity} (x,y) \; 1]^T  \\ \texttt{\_3dImage} (x,y) = (X/W, \; Y/W, \; Z/W) \end{array}\f]

The matrix Q can be an arbitrary \f$4 \times 4\f$ matrix (for example, the one computed by
stereoRectify). To reproject a sparse set of points {(x,y,d),...} to 3D space, use
perspectiveTransform .

</member>
        <member name="M:cv.filterSpeckles(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32,System.Double,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Filters off small noise blobs (speckles) in the disparity map

@param img The input 16-bit signed disparity image
@param newVal The disparity value used to paint-off the speckles
@param maxSpeckleSize The maximum speckle size to consider it a speckle. Larger blobs are not
affected by the algorithm
@param maxDiff Maximum difference between neighbor disparity pixels to put them into the same
blob. Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point
disparity map, where disparity values are multiplied by 16, this scale factor should be taken into
account when specifying this parameter value.
@param buf The optional temporary buffer to avoid memory allocation within the function.

</member>
        <member name="M:cv.triangulatePoints(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Reconstructs points by triangulation.

@param projMatr1 3x4 projection matrix of the first camera.
@param projMatr2 3x4 projection matrix of the second camera.
@param projPoints1 2xN array of feature points in the first image. In case of c++ version it can
be also a vector of feature points or two-channel matrix of size 1xN or Nx1.
@param projPoints2 2xN array of corresponding points in the second image. In case of c++ version
it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.
@param points4D 4xN array of reconstructed points in homogeneous coordinates.

The function reconstructs 3-dimensional points (in homogeneous coordinates) by using their
observations with a stereo camera. Projections matrices can be obtained from stereoRectify.

@note
   Keep in mind that all input data should be of float type in order for this function to work.

@sa
   reprojectImageTo3D

</member>
        <member name="M:cv.decomposeEssentialMat(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Decompose an essential matrix to possible rotations and translation.

@param E The input essential matrix.
@param R1 One possible rotation matrix.
@param R2 Another possible rotation matrix.
@param t One possible translation.

This function decompose an essential matrix E using svd decomposition @cite HartleyZ00 . Generally 4
possible poses exists for a given E. They are \f$[R_1, t]\f$, \f$[R_1, -t]\f$, \f$[R_2, t]\f$, \f$[R_2, -t]\f$. By
decomposing E, you can only get the direction of the translation, so the function returns unit t.

</member>
        <member name="M:cv.findFundamentalMat(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,System.Double)">
@overload 
</member>
        <member name="M:cv.convertPointsHomogeneous(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Converts points to/from homogeneous coordinates.

@param src Input array or vector of 2D, 3D, or 4D points.
@param dst Output vector of 2D, 3D, or 4D points.

The function converts 2D or 3D points from/to homogeneous coordinates by calling either
convertPointsToHomogeneous or convertPointsFromHomogeneous.

@note The function is obsolete. Use one of the previous two functions instead.

</member>
        <member name="M:cv.convertPointsFromHomogeneous(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Converts points from homogeneous to Euclidean space.

@param src Input vector of N-dimensional points.
@param dst Output vector of N-1-dimensional points.

The function converts points homogeneous to Euclidean space using perspective projection. That is,
each point (x1, x2, ... x(n-1), xn) is converted to (x1/xn, x2/xn, ..., x(n-1)/xn). When xn=0, the
output point coordinates will be (0,0,0,...).

</member>
        <member name="M:cv.convertPointsToHomogeneous(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Converts points from Euclidean to homogeneous space.

@param src Input vector of N-dimensional points.
@param dst Output vector of N+1-dimensional points.

The function converts points from Euclidean to homogeneous space by appending 1's to the tuple of
point coordinates. That is, each point (x1, x2, ..., xn) is converted to (x1, x2, ..., xn, 1).

</member>
        <member name="M:cv.getOptimalNewCameraMatrix(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Double,cv.Size_&lt;System.Int32&gt;,cv.Rect_&lt;System.Int32&gt;*,System.Boolean)">
@brief Returns the new camera matrix based on the free scaling parameter.

@param cameraMatrix Input camera matrix.
@param distCoeffs Input vector of distortion coefficients
\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\f$ of 4, 5, 8 or 12 elements. If
the vector is NULL/empty, the zero distortion coefficients are assumed.
@param imageSize Original image size.
@param alpha Free scaling parameter between 0 (when all the pixels in the undistorted image are
valid) and 1 (when all the source image pixels are retained in the undistorted image). See
stereoRectify for details.
@param newImgSize Image size after rectification. By default,it is set to imageSize .
@param validPixROI Optional output rectangle that outlines all-good-pixels region in the
undistorted image. See roi1, roi2 description in stereoRectify .
@param centerPrincipalPoint Optional flag that indicates whether in the new camera matrix the
principal point should be at the image center or not. By default, the principal point is chosen to
best fit a subset of the source image (determined by alpha) to the corrected image.
@return new_camera_matrix Output new camera matrix.

The function computes and returns the optimal new camera matrix based on the free scaling parameter.
By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original
image pixels if there is valuable information in the corners alpha=1 , or get something in between.
When alpha\&gt;0 , the undistortion result is likely to have some black pixels corresponding to
"virtual" pixels outside of the captured distorted image. The original camera matrix, distortion
coefficients, the computed new camera matrix, and newImageSize should be passed to
initUndistortRectifyMap to produce the maps for remap .

</member>
        <member name="M:cv.stereoRectifyUncalibrated(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief Computes a rectification transform for an uncalibrated stereo camera.

@param points1 Array of feature points in the first image.
@param points2 The corresponding points in the second image. The same formats as in
findFundamentalMat are supported.
@param F Input fundamental matrix. It can be computed from the same set of point pairs using
findFundamentalMat .
@param imgSize Size of the image.
@param H1 Output rectification homography matrix for the first image.
@param H2 Output rectification homography matrix for the second image.
@param threshold Optional threshold used to filter out the outliers. If the parameter is greater
than zero, all the point pairs that do not comply with the epipolar geometry (that is, the points
for which \f$|\texttt{points2[i]}^T*\texttt{F}*\texttt{points1[i]}|&gt;\texttt{threshold}\f$ ) are
rejected prior to computing the homographies. Otherwise,all the points are considered inliers.

The function computes the rectification transformations without knowing intrinsic parameters of the
cameras and their relative position in the space, which explains the suffix "uncalibrated". Another
related difference from stereoRectify is that the function outputs not the rectification
transformations in the object (3D) space, but the planar perspective transformations encoded by the
homography matrices H1 and H2 . The function implements the algorithm @cite Hartley99 .

@note
   While the algorithm does not need to know the intrinsic parameters of the cameras, it heavily
    depends on the epipolar geometry. Therefore, if the camera lenses have a significant distortion,
    it would be better to correct it before computing the fundamental matrix and calling this
    function. For example, distortion coefficients can be estimated for each head of stereo camera
    separately by using calibrateCamera . Then, the images can be corrected using undistort , or
    just the point coordinates can be corrected with undistortPoints .

</member>
        <member name="M:cv.stereoCalibrate(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst">
@brief Calibrates the stereo camera.

@param objectPoints Vector of vectors of the calibration pattern points.
@param imagePoints1 Vector of vectors of the projections of the calibration pattern points,
observed by the first camera.
@param imagePoints2 Vector of vectors of the projections of the calibration pattern points,
observed by the second camera.
@param cameraMatrix1 Input/output first camera matrix:
\f$\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}\f$ , \f$j = 0,\, 1\f$ . If
any of CV_CALIB_USE_INTRINSIC_GUESS , CV_CALIB_FIX_ASPECT_RATIO ,
CV_CALIB_FIX_INTRINSIC , or CV_CALIB_FIX_FOCAL_LENGTH are specified, some or all of the
matrix components must be initialized. See the flags description for details.
@param distCoeffs1 Input/output vector of distortion coefficients
\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\f$ of 4, 5, 8 ot 12 elements. The
output vector length depends on the flags.
@param cameraMatrix2 Input/output second camera matrix. The parameter is similar to cameraMatrix1
@param distCoeffs2 Input/output lens distortion coefficients for the second camera. The parameter
is similar to distCoeffs1 .
@param imageSize Size of the image used only to initialize intrinsic camera matrix.
@param R Output rotation matrix between the 1st and the 2nd camera coordinate systems.
@param T Output translation vector between the coordinate systems of the cameras.
@param E Output essential matrix.
@param F Output fundamental matrix.
@param flags Different flags that may be zero or a combination of the following values:
-   **CV_CALIB_FIX_INTRINSIC** Fix cameraMatrix? and distCoeffs? so that only R, T, E , and F
matrices are estimated.
-   **CV_CALIB_USE_INTRINSIC_GUESS** Optimize some or all of the intrinsic parameters
according to the specified flags. Initial values are provided by the user.
-   **CV_CALIB_FIX_PRINCIPAL_POINT** Fix the principal points during the optimization.
-   **CV_CALIB_FIX_FOCAL_LENGTH** Fix \f$f^{(j)}_x\f$ and \f$f^{(j)}_y\f$ .
-   **CV_CALIB_FIX_ASPECT_RATIO** Optimize \f$f^{(j)}_y\f$ . Fix the ratio \f$f^{(j)}_x/f^{(j)}_y\f$
.
-   **CV_CALIB_SAME_FOCAL_LENGTH** Enforce \f$f^{(0)}_x=f^{(1)}_x\f$ and \f$f^{(0)}_y=f^{(1)}_y\f$ .
-   **CV_CALIB_ZERO_TANGENT_DIST** Set tangential distortion coefficients for each camera to
zeros and fix there.
-   **CV_CALIB_FIX_K1,...,CV_CALIB_FIX_K6** Do not change the corresponding radial
distortion coefficient during the optimization. If CV_CALIB_USE_INTRINSIC_GUESS is set,
the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.
-   **CV_CALIB_RATIONAL_MODEL** Enable coefficients k4, k5, and k6. To provide the backward
compatibility, this extra flag should be explicitly specified to make the calibration
function use the rational model and return 8 coefficients. If the flag is not set, the
function computes and returns only 5 distortion coefficients.
-   **CALIB_THIN_PRISM_MODEL** Coefficients s1, s2, s3 and s4 are enabled. To provide the
backward compatibility, this extra flag should be explicitly specified to make the
calibration function use the thin prism model and return 12 coefficients. If the flag is not
set, the function computes and returns only 5 distortion coefficients.
-   **CALIB_FIX_S1_S2_S3_S4** The thin prism distortion coefficients are not changed during
the optimization. If CV_CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the
supplied distCoeffs matrix is used. Otherwise, it is set to 0.
@param criteria Termination criteria for the iterative optimization algorithm.

The function estimates transformation between two cameras making a stereo pair. If you have a stereo
camera where the relative position and orientation of two cameras is fixed, and if you computed
poses of an object relative to the first camera and to the second camera, (R1, T1) and (R2, T2),
respectively (this can be done with solvePnP ), then those poses definitely relate to each other.
This means that, given ( \f$R_1\f$,\f$T_1\f$ ), it should be possible to compute ( \f$R_2\f$,\f$T_2\f$ ). You only
need to know the position and orientation of the second camera relative to the first camera. This is
what the described function does. It computes ( \f$R\f$,\f$T\f$ ) so that:

\f[R_2=R*R_1
T_2=R*T_1 + T,\f]

Optionally, it computes the essential matrix E:

\f[E= \vecthreethree{0}{-T_2}{T_1}{T_2}{0}{-T_0}{-T_1}{T_0}{0} *R\f]

where \f$T_i\f$ are components of the translation vector \f$T\f$ : \f$T=[T_0, T_1, T_2]^T\f$ . And the function
can also compute the fundamental matrix F:

\f[F = cameraMatrix2^{-T} E cameraMatrix1^{-1}\f]

Besides the stereo-related information, the function can also perform a full calibration of each of
two cameras. However, due to the high dimensionality of the parameter space and noise in the input
data, the function can diverge from the correct solution. If the intrinsic parameters can be
estimated with high accuracy for each of the cameras individually (for example, using
calibrateCamera ), you are recommended to do so and then pass CV_CALIB_FIX_INTRINSIC flag to the
function along with the computed intrinsic parameters. Otherwise, if all the parameters are
estimated at once, it makes sense to restrict some parameters, for example, pass
CV_CALIB_SAME_FOCAL_LENGTH and CV_CALIB_ZERO_TANGENT_DIST flags, which is usually a
reasonable assumption.

Similarly to calibrateCamera , the function minimizes the total re-projection error for all the
points in all the available views from both cameras. The function returns the final value of the
re-projection error.

</member>
        <member name="M:cv.calibrationMatrixValues(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Double&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes useful camera characteristics from the camera matrix.

@param cameraMatrix Input camera matrix that can be estimated by calibrateCamera or
stereoCalibrate .
@param imageSize Input image size in pixels.
@param apertureWidth Physical width in mm of the sensor.
@param apertureHeight Physical height in mm of the sensor.
@param fovx Output field of view in degrees along the horizontal sensor axis.
@param fovy Output field of view in degrees along the vertical sensor axis.
@param focalLength Focal length of the lens in mm.
@param principalPoint Principal point in mm.
@param aspectRatio \f$f_y/f_x\f$

The function computes various useful camera characteristics from the previously estimated camera
matrix.

@note
   Do keep in mind that the unity measure 'mm' stands for whatever unit of measure one chooses for
    the chessboard pitch (it can thus be any value).

</member>
        <member name="M:cv.drawChessboardCorners(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief Renders the detected chessboard corners.

@param image Destination image. It must be an 8-bit color image.
@param patternSize Number of inner corners per a chessboard row and column
(patternSize = cv::Size(points_per_row,points_per_column)).
@param corners Array of detected corners, the output of findChessboardCorners.
@param patternWasFound Parameter indicating whether the complete board was found or not. The
return value of findChessboardCorners should be passed here.

The function draws individual chessboard corners detected either as red circles if the board was not
found, or as colored corners connected with lines if the board was found.

</member>
        <member name="M:cv.initCameraMatrix2D(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Double)">
@brief Finds an initial camera matrix from 3D-2D point correspondences.

@param objectPoints Vector of vectors of the calibration pattern points in the calibration pattern
coordinate space. In the old interface all the per-view vectors are concatenated. See
calibrateCamera for details.
@param imagePoints Vector of vectors of the projections of the calibration pattern points. In the
old interface all the per-view vectors are concatenated.
@param imageSize Image size in pixels used to initialize the principal point.
@param aspectRatio If it is zero or negative, both \f$f_x\f$ and \f$f_y\f$ are estimated independently.
Otherwise, \f$f_x = f_y * \texttt{aspectRatio}\f$ .

The function estimates and returns an initial camera matrix for the camera calibration process.
Currently, the function only supports planar calibration patterns, which are patterns where each
object point has z-coordinate =0.

</member>
        <member name="M:cv.composeRT(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerSe">
@brief Combines two rotation-and-shift transformations.

@param rvec1 First rotation vector.
@param tvec1 First translation vector.
@param rvec2 Second rotation vector.
@param tvec2 Second translation vector.
@param rvec3 Output rotation vector of the superposition.
@param tvec3 Output translation vector of the superposition.
@param dr3dr1
@param dr3dt1
@param dr3dr2
@param dr3dt2
@param dt3dr1
@param dt3dt1
@param dt3dr2
@param dt3dt2 Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and
tvec2, respectively.

The functions compute:

\f[\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\f]

where \f$\mathrm{rodrigues}\f$ denotes a rotation vector to a rotation matrix transformation, and
\f$\mathrm{rodrigues}^{-1}\f$ denotes the inverse transformation. See Rodrigues for details.

Also, the functions can compute the derivatives of the output vectors with regards to the input
vectors (see matMulDeriv ). The functions are used inside stereoCalibrate but can also be used in
your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
function that contains a matrix multiplication.

</member>
        <member name="M:cv.matMulDeriv(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes partial derivatives of the matrix product for each multiplied matrix.

@param A First multiplied matrix.
@param B Second multiplied matrix.
@param dABdA First output derivative matrix d(A\*B)/dA of size
\f$\texttt{A.rows*B.cols} \times {A.rows*A.cols}\f$ .
@param dABdB Second output derivative matrix d(A\*B)/dB of size
\f$\texttt{A.rows*B.cols} \times {B.rows*B.cols}\f$ .

The function computes partial derivatives of the elements of the matrix product \f$A*B\f$ with regard to
the elements of each of the two input matrices. The function is used to compute the Jacobian
matrices in stereoCalibrate but can also be used in any other similar optimization function.

</member>
        <member name="M:cv.decomposeProjectionMatrix(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System">
@brief Decomposes a projection matrix into a rotation matrix and a camera matrix.

@param projMatrix 3x4 input projection matrix P.
@param cameraMatrix Output 3x3 camera matrix K.
@param rotMatrix Output 3x3 external rotation matrix R.
@param transVect Output 4x1 translation vector T.
@param rotMatrixX Optional 3x3 rotation matrix around x-axis.
@param rotMatrixY Optional 3x3 rotation matrix around y-axis.
@param rotMatrixZ Optional 3x3 rotation matrix around z-axis.
@param eulerAngles Optional three-element vector containing three Euler angles of rotation in
degrees.

The function computes a decomposition of a projection matrix into a calibration and a rotation
matrix and the position of a camera.

It optionally returns three rotation matrices, one for each axis, and three Euler angles that could
be used in OpenGL. Note, there is always more than one sequence of rotations about the three
principle axes that results in the same orientation of an object, eg. see @cite Slabaugh . Returned
tree rotation matrices and corresponding three Euler angules are only one of the possible solutions.

The function is based on RQDecomp3x3 .

</member>
        <member name="M:cv.RQDecomp3x3(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes an RQ decomposition of 3x3 matrices.

@param src 3x3 input matrix.
@param mtxR Output 3x3 upper-triangular matrix.
@param mtxQ Output 3x3 orthogonal matrix.
@param Qx Optional output 3x3 rotation matrix around x-axis.
@param Qy Optional output 3x3 rotation matrix around y-axis.
@param Qz Optional output 3x3 rotation matrix around z-axis.

The function computes a RQ decomposition using the given rotations. This function is used in
decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera
and a rotation matrix.

It optionally returns three rotation matrices, one for each axis, and the three Euler angles in
degrees (as the return value) that could be used in OpenGL. Note, there is always more than one
sequence of rotations about the three principle axes that results in the same orientation of an
object, eg. see @cite Slabaugh . Returned tree rotation matrices and corresponding three Euler angules
are only one of the possible solutions.

</member>
        <member name="M:cv.findHomography(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double)">
@overload 
</member>
        <member name="M:cv.Rodrigues(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Converts a rotation matrix to a rotation vector or vice versa.

@param src Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).
@param dst Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.
@param jacobian Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial
derivatives of the output array components with respect to the input array components.

\f[\begin{array}{l} \theta \leftarrow norm(r) \\ r  \leftarrow r/ \theta \\ R =  \cos{\theta} I + (1- \cos{\theta} ) r r^T +  \sin{\theta} \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} \end{array}\f]

Inverse transformation can be also done easily, since

\f[\sin ( \theta ) \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} = \frac{R - R^T}{2}\f]

A rotation vector is a convenient and most compact representation of a rotation matrix (since any
rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry
optimization procedures like calibrateCamera, stereoCalibrate, or solvePnP .

</member>
        <member name="T:CvHaarFeature">
@addtogroup objdetect_c
  @{

</member>
        <member name="M:cv.CascadeClassifier.detectMultiScale(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Rect_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32,System.Int32,cv.Size_&lt;System.Int32&gt;,cv.Size_&lt;System.Int32&gt;,System.Boolean)">
@overload
    if `outputRejectLevels` is `true` returns `rejectLevels` and `levelWeights`

</member>
        <member name="M:cv.CascadeClassifier.detectMultiScale(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Rect_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32,System.Int32,cv.Size_&lt;System.Int32&gt;,cv.Size_&lt;System.Int32&gt;)">
@overload
    @param image Matrix of the type CV_8U containing an image where objects are detected.
    @param objects Vector of rectangles where each rectangle contains the detected object, the
    rectangles may be partially outside the original image.
    @param numDetections Vector of detection numbers for the corresponding objects. An object's number
    of detections is the number of neighboring positively classified rectangles that were joined
    together to form the object.
    @param scaleFactor Parameter specifying how much the image size is reduced at each image scale.
    @param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have
    to retain it.
    @param flags Parameter with the same meaning for an old cascade as in the function
    cvHaarDetectObjects. It is not used for a new cascade.
    @param minSize Minimum possible object size. Objects smaller than that are ignored.
    @param maxSize Maximum possible object size. Objects larger than that are ignored.

</member>
        <member name="M:cv.CascadeClassifier.detectMultiScale(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Rect_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32,System.Int32,cv.Size_&lt;System.Int32&gt;,cv.Size_&lt;System.Int32&gt;)">
@brief Detects objects of different sizes in the input image. The detected objects are returned as a list
    of rectangles.

    @param image Matrix of the type CV_8U containing an image where objects are detected.
    @param objects Vector of rectangles where each rectangle contains the detected object, the
    rectangles may be partially outside the original image.
    @param scaleFactor Parameter specifying how much the image size is reduced at each image scale.
    @param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have
    to retain it.
    @param flags Parameter with the same meaning for an old cascade as in the function
    cvHaarDetectObjects. It is not used for a new cascade.
    @param minSize Minimum possible object size. Objects smaller than that are ignored.
    @param maxSize Maximum possible object size. Objects larger than that are ignored.

    The function is parallelized with the TBB library.

    @note
       -   (Python) A face detection example using cascade classifiers can be found at
            opencv_source_code/samples/python2/facedetect.py

</member>
        <member name="M:cv.CascadeClassifier.read(cv.FileNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Reads a classifier from a FileStorage node.

    @note The file may contain a new cascade classifier (trained traincascade application) only.

</member>
        <member name="M:cv.CascadeClassifier.load(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Loads a classifier from a file.

    @param filename Name of the file from which the classifier is loaded. The file may contain an old
    HAAR classifier trained by the haartraining application or a new cascade classifier trained by the
    traincascade application.

</member>
        <member name="M:cv.CascadeClassifier.empty">
@brief Checks whether the classifier has been loaded.

</member>
        <member name="M:cv.CascadeClassifier.#ctor(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Loads a classifier from a file.

    @param filename Name of the file from which the classifier is loaded.

</member>
        <member name="T:cv.CascadeClassifier">
@brief Cascade classifier class for object detection.

</member>
        <member name="M:cv.groupRectangles_meanshift(std.vector&lt;cv.Rect_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv.Size_&lt;System.Int32&gt;)">
@overload 
</member>
        <member name="M:cv.groupRectangles(std.vector&lt;cv.Rect_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double)">
@overload 
</member>
        <member name="M:cv.groupRectangles(std.vector&lt;cv.Rect_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,std.vector&lt;System.Int32&gt;*,std.vector&lt;System.Double&gt;*)">
@overload 
</member>
        <member name="M:cv.groupRectangles(std.vector&lt;cv.Rect_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double)">
@overload 
</member>
        <member name="M:cv.groupRectangles(std.vector&lt;cv.Rect_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double)">
@brief Groups the object candidate rectangles.

@param rectList Input/output vector of rectangles. Output vector includes retained and grouped
rectangles. (The Python list is not modified in place.)
@param groupThreshold Minimum possible number of rectangles minus 1. The threshold is used in a
group of rectangles to retain it.
@param eps Relative difference between sides of the rectangles to merge them into a group.

The function is a wrapper for the generic function partition . It clusters all the input rectangles
using the rectangle equivalence criteria that combines rectangles with similar sizes and similar
locations. The similarity is defined by eps. When eps=0 , no clustering is done at all. If
\f$\texttt{eps}\rightarrow +\inf\f$ , all the rectangles are put in one cluster. Then, the small
clusters containing less than or equal to groupThreshold rectangles are rejected. In each other
cluster, the average rectangle is computed and put into the output rectangle list.

</member>
        <member name="M:cv.BOWImgDescriptorExtractor.descriptorType">
@brief Returns an image descriptor type.

</member>
        <member name="M:cv.BOWImgDescriptorExtractor.descriptorSize">
@brief Returns an image descriptor size if the vocabulary is set. Otherwise, it returns 0.

</member>
        <member name="M:cv.BOWImgDescriptorExtractor.compute(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.vector&lt;System.Int32&gt;&gt;*)">
@overload
    @param keypointDescriptors Computed descriptors to match with vocabulary.
    @param imgDescriptor Computed output image descriptor.
    @param pointIdxsOfClusters Indices of keypoints that belong to the cluster. This means that
    pointIdxsOfClusters[i] are keypoint indices that belong to the i -th cluster (word of vocabulary)
    returned if it is non-zero.

</member>
        <member name="M:cv.BOWImgDescriptorExtractor.compute(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.vector&lt;System.Int32&gt;&gt;*,cv.Mat*)">
@brief Computes an image descriptor using the set visual vocabulary.

    @param image Image, for which the descriptor is computed.
    @param keypoints Keypoints detected in the input image.
    @param imgDescriptor Computed output image descriptor.
    @param pointIdxsOfClusters Indices of keypoints that belong to the cluster. This means that
    pointIdxsOfClusters[i] are keypoint indices that belong to the i -th cluster (word of vocabulary)
    returned if it is non-zero.
    @param descriptors Descriptors of the image keypoints that are returned if they are non-zero.

</member>
        <member name="M:cv.BOWImgDescriptorExtractor.getVocabulary">
@brief Returns the set vocabulary.

</member>
        <member name="M:cv.BOWImgDescriptorExtractor.setVocabulary(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Sets a visual vocabulary.

    @param vocabulary Vocabulary (can be trained using the inheritor of BOWTrainer ). Each row of the
    vocabulary is a visual word (cluster center).

</member>
        <member name="M:cv.BOWImgDescriptorExtractor.#ctor(cv.Ptr&lt;cv.DescriptorMatcher&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload 
</member>
        <member name="M:cv.BOWImgDescriptorExtractor.#ctor(cv.Ptr&lt;cv.Feature2D&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Ptr&lt;cv.DescriptorMatcher&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief The constructor.

    @param dextractor Descriptor extractor that is used to compute descriptors for an input image and
    its keypoints.
    @param dmatcher Descriptor matcher that is used to find the nearest word of the trained vocabulary
    for each keypoint descriptor of the image.

</member>
        <member name="T:cv.BOWImgDescriptorExtractor">
@brief Class to compute an image descriptor using the *bag of visual words*.

Such a computation consists of the following steps:

1.  Compute descriptors for a given image and its keypoints set.
2.  Find the nearest visual words from the vocabulary for each keypoint descriptor.
3.  Compute the bag-of-words image descriptor as is a normalized histogram of vocabulary words
encountered in the image. The i-th bin of the histogram is a frequency of i-th word of the
vocabulary in the given image.

</member>
        <member name="M:cv.BOWKMeansTrainer.#ctor(System.Int32,cv.TermCriteria!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief The constructor.

    @see cv::kmeans

</member>
        <member name="T:cv.BOWKMeansTrainer">
@brief kmeans -based class to train visual vocabulary using the *bag of visual words* approach. :

</member>
        <member name="M:cv.BOWTrainer.cluster(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Clusters train descriptors.

    @param descriptors Descriptors to cluster. Each row of the descriptors matrix is a descriptor.
    Descriptors are not added to the inner train descriptor set.

    The vocabulary consists of cluster centers. So, this method returns the vocabulary. In the first
    variant of the method, train descriptors stored in the object are clustered. In the second variant,
    input descriptors are clustered.

</member>
        <member name="M:cv.BOWTrainer.cluster">
@overload 
</member>
        <member name="M:cv.BOWTrainer.descriptorsCount">
@brief Returns the count of all descriptors stored in the training set.

</member>
        <member name="M:cv.BOWTrainer.getDescriptors">
@brief Returns a training set of descriptors.

</member>
        <member name="M:cv.BOWTrainer.add(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Adds descriptors to a training set.

    @param descriptors Descriptors to add to a training set. Each row of the descriptors matrix is a
    descriptor.

    The training set is clustered using clustermethod to construct the vocabulary.

</member>
        <member name="T:cv.BOWTrainer">
@brief Abstract base class for training the *bag of visual words* vocabulary from a set of descriptors.

For details, see, for example, *Visual Categorization with Bags of Keypoints* by Gabriella Csurka,
Christopher R. Dance, Lixin Fan, Jutta Willamowski, Cedric Bray, 2004. :

</member>
        <member name="M:cv.drawMatches(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.vector&lt;cv.DMatch&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Scalar_&lt;System.Double&gt;!System.Runtim">
@overload 
</member>
        <member name="M:cv.drawMatches(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.DMatch&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerSe">
@brief Draws the found matches of keypoints from two images.

@param img1 First source image.
@param keypoints1 Keypoints from the first source image.
@param img2 Second source image.
@param keypoints2 Keypoints from the second source image.
@param matches1to2 Matches from the first image to the second one, which means that keypoints1[i]
has a corresponding point in keypoints2[matches[i]] .
@param outImg Output image. Its content depends on the flags value defining what is drawn in the
output image. See possible flags bit values below.
@param matchColor Color of matches (lines and connected keypoints). If matchColor==Scalar::all(-1)
, the color is generated randomly.
@param singlePointColor Color of single keypoints (circles), which means that keypoints do not
have the matches. If singlePointColor==Scalar::all(-1) , the color is generated randomly.
@param matchesMask Mask determining which matches are drawn. If the mask is empty, all matches are
drawn.
@param flags Flags setting drawing features. Possible flags bit values are defined by
DrawMatchesFlags.

This function draws matches of keypoints from two images in the output image. Match is a line
connecting two keypoints (circles). See cv::DrawMatchesFlags.

</member>
        <member name="M:cv.drawKeypoints(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Draws keypoints.

@param image Source image.
@param keypoints Keypoints from the source image.
@param outImage Output image. Its content depends on the flags value defining what is drawn in the
output image. See possible flags bit values below.
@param color Color of keypoints.
@param flags Flags setting drawing features. Possible flags bit values are defined by
DrawMatchesFlags. See details above in drawMatches .

@note
For Python API, flags are modified as cv2.DRAW_MATCHES_FLAGS_DEFAULT,
cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS, cv2.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG,
cv2.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS

</member>
        <member name="T:cv.FlannBasedMatcher">
@brief Flann-based descriptor matcher.

This matcher trains flann::Index_ on a train descriptor collection and calls its nearest search
methods to find the best matches. So, this matcher may be faster when matching a large train
collection than the brute force matcher. FlannBasedMatcher does not support masking permissible
matches of descriptor sets because flann::Index does not support this. :

</member>
        <member name="M:cv.BFMatcher.#ctor(System.Int32,System.Boolean)">
@brief Brute-force matcher constructor.

    @param normType One of NORM_L1, NORM_L2, NORM_HAMMING, NORM_HAMMING2. L1 and L2 norms are
    preferable choices for SIFT and SURF descriptors, NORM_HAMMING should be used with ORB, BRISK and
    BRIEF, NORM_HAMMING2 should be used with ORB when WTA_K==3 or 4 (see ORB::ORB constructor
    description).
    @param crossCheck If it is false, this is will be default BFMatcher behaviour when it finds the k
    nearest neighbors for each query descriptor. If crossCheck==true, then the knnMatch() method with
    k=1 will only return pairs (i,j) such that for i-th query descriptor the j-th descriptor in the
    matcher's collection is the nearest and vice versa, i.e. the BFMatcher will only return consistent
    pairs. Such technique usually produces best results with minimal number of outliers when there are
    enough matches. This is alternative to the ratio test, used by D. Lowe in SIFT paper.

</member>
        <member name="T:cv.BFMatcher">
@brief Brute-force descriptor matcher.

For each descriptor in the first set, this matcher finds the closest descriptor in the second set
by trying each one. This descriptor matcher supports masking permissible matches of descriptor
sets.

</member>
        <member name="T:cv.DescriptorMatcher.DescriptorCollection">
Class to work with descriptors from several images as with one merged matrix.
It is used e.g. in FlannBasedMatcher.

</member>
        <member name="M:cv.DescriptorMatcher.create(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Creates a descriptor matcher of a given type with the default parameters (using default
    constructor).

    @param descriptorMatcherType Descriptor matcher type. Now the following matcher types are
    supported:
    -   `BruteForce` (it uses L2 )
    -   `BruteForce-L1`
    -   `BruteForce-Hamming`
    -   `BruteForce-Hamming(2)`
    -   `FlannBased`

</member>
        <member name="M:cv.DescriptorMatcher.clone(System.Boolean)">
@brief Clones the matcher.

    @param emptyTrainData If emptyTrainData is false, the method creates a deep copy of the object,
    that is, copies both parameters and train data. If emptyTrainData is true, the method creates an
    object copy with the current parameters but with empty train data.

</member>
        <member name="M:cv.DescriptorMatcher.radiusMatch(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.vector&lt;cv.DMatch&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@overload
    @param queryDescriptors Query set of descriptors.
    @param matches Found matches.
    @param maxDistance Threshold for the distance between matched descriptors. Distance means here
    metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured
    in Pixels)!
    @param masks Set of masks. Each masks[i] specifies permissible matches between the input query
    descriptors and stored train descriptors from the i-th image trainDescCollection[i].
    @param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is
    false, the matches vector has the same size as queryDescriptors rows. If compactResult is true,
    the matches vector does not contain matches for fully masked-out query descriptors.

</member>
        <member name="M:cv.DescriptorMatcher.knnMatch(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.vector&lt;cv.DMatch&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@overload
    @param queryDescriptors Query set of descriptors.
    @param matches Matches. Each matches[i] is k or less matches for the same query descriptor.
    @param k Count of best matches found per each query descriptor or less if a query descriptor has
    less than k possible matches in total.
    @param masks Set of masks. Each masks[i] specifies permissible matches between the input query
    descriptors and stored train descriptors from the i-th image trainDescCollection[i].
    @param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is
    false, the matches vector has the same size as queryDescriptors rows. If compactResult is true,
    the matches vector does not contain matches for fully masked-out query descriptors.

</member>
        <member name="M:cv.DescriptorMatcher.match(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.DMatch&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param queryDescriptors Query set of descriptors.
    @param matches Matches. If a query descriptor is masked out in mask , no match is added for this
    descriptor. So, matches size may be smaller than the query descriptors count.
    @param masks Set of masks. Each masks[i] specifies permissible matches between the input query
    descriptors and stored train descriptors from the i-th image trainDescCollection[i].

</member>
        <member name="M:cv.DescriptorMatcher.radiusMatch(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.vector&lt;cv.DMatch&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief For each query descriptor, finds the training descriptors not farther than the specified distance.

    @param queryDescriptors Query set of descriptors.
    @param trainDescriptors Train set of descriptors. This set is not added to the train descriptors
    collection stored in the class object.
    @param matches Found matches.
    @param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is
    false, the matches vector has the same size as queryDescriptors rows. If compactResult is true,
    the matches vector does not contain matches for fully masked-out query descriptors.
    @param maxDistance Threshold for the distance between matched descriptors. Distance means here
    metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured
    in Pixels)!
    @param mask Mask specifying permissible matches between an input query and train matrices of
    descriptors.

    For each query descriptor, the methods find such training descriptors that the distance between the
    query descriptor and the training descriptor is equal or smaller than maxDistance. Found matches are
    returned in the distance increasing order.

</member>
        <member name="M:cv.DescriptorMatcher.knnMatch(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.vector&lt;cv.DMatch&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief Finds the k best matches for each descriptor from a query set.

    @param queryDescriptors Query set of descriptors.
    @param trainDescriptors Train set of descriptors. This set is not added to the train descriptors
    collection stored in the class object.
    @param mask Mask specifying permissible matches between an input query and train matrices of
    descriptors.
    @param matches Matches. Each matches[i] is k or less matches for the same query descriptor.
    @param k Count of best matches found per each query descriptor or less if a query descriptor has
    less than k possible matches in total.
    @param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is
    false, the matches vector has the same size as queryDescriptors rows. If compactResult is true,
    the matches vector does not contain matches for fully masked-out query descriptors.

    These extended variants of DescriptorMatcher::match methods find several best matches for each query
    descriptor. The matches are returned in the distance increasing order. See DescriptorMatcher::match
    for the details about query and train descriptors.

</member>
        <member name="M:cv.DescriptorMatcher.train">
@brief Trains a descriptor matcher

    Trains a descriptor matcher (for example, the flann index). In all methods to match, the method
    train() is run every time before matching. Some descriptor matchers (for example, BruteForceMatcher)
    have an empty implementation of this method. Other matchers really train their inner structures (for
    example, FlannBasedMatcher trains flann::Index ).

</member>
        <member name="M:cv.DescriptorMatcher.isMaskSupported">
@brief Returns true if the descriptor matcher supports masking permissible matches.

</member>
        <member name="M:cv.DescriptorMatcher.empty">
@brief Returns true if there are no train descriptors in the both collections.

</member>
        <member name="M:cv.DescriptorMatcher.clear">
@brief Clears the train descriptor collections.

</member>
        <member name="M:cv.DescriptorMatcher.getTrainDescriptors">
@brief Returns a constant link to the train descriptor collection trainDescCollection .

</member>
        <member name="M:cv.DescriptorMatcher.add(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Adds descriptors to train a CPU(trainDescCollectionis) or GPU(utrainDescCollectionis) descriptor
    collection.

    If the collection is not empty, the new descriptors are added to existing train descriptors.

    @param descriptors Descriptors to add. Each descriptors[i] is a set of descriptors from the same
    train image.

</member>
        <member name="T:cv.DescriptorMatcher">
@brief Abstract base class for matching keypoint descriptors.

It has two groups of match methods: for matching descriptors of an image with another image or with
an image set.

</member>
        <member name="M:cv.AKAZE.create(System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.Int32)">
@brief The AKAZE constructor

    @param descriptor_type Type of the extracted descriptor: DESCRIPTOR_KAZE,
    DESCRIPTOR_KAZE_UPRIGHT, DESCRIPTOR_MLDB or DESCRIPTOR_MLDB_UPRIGHT.
    @param descriptor_size Size of the descriptor in bits. 0 -\&gt; Full size
    @param descriptor_channels Number of channels in the descriptor (1, 2, 3)
    @param threshold Detector response threshold to accept point
    @param nOctaves Maximum octave evolution of the image
    @param nOctaveLayers Default number of sublevels per scale level
    @param diffusivity Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or
    DIFF_CHARBONNIER

</member>
        <member name="T:cv.AKAZE">
@brief Class implementing the AKAZE keypoint detector and descriptor extractor, described in @cite ANB13 . :

@note AKAZE descriptors can only be used with KAZE or AKAZE keypoints. Try to avoid using *extract*
and *detect* instead of *operator()* due to performance reasons. .. [ANB13] Fast Explicit Diffusion
for Accelerated Features in Nonlinear Scale Spaces. Pablo F. Alcantarilla, JesĂşs Nuevo and Adrien
Bartoli. In British Machine Vision Conference (BMVC), Bristol, UK, September 2013.

</member>
        <member name="M:cv.KAZE.create(System.Boolean,System.Boolean,System.Single,System.Int32,System.Int32,System.Int32)">
@brief The KAZE constructor

    @param extended Set to enable extraction of extended (128-byte) descriptor.
    @param upright Set to enable use of upright descriptors (non rotation-invariant).
    @param threshold Detector response threshold to accept point
    @param nOctaves Maximum octave evolution of the image
    @param nOctaveLayers Default number of sublevels per scale level
    @param diffusivity Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or
    DIFF_CHARBONNIER

</member>
        <member name="T:cv.KAZE">
@brief Class implementing the KAZE keypoint detector and descriptor extractor, described in @cite ABD12 .

@note AKAZE descriptor can only be used with KAZE or AKAZE keypoints .. [ABD12] KAZE Features. Pablo
F. Alcantarilla, Adrien Bartoli and Andrew J. Davison. In European Conference on Computer Vision
(ECCV), Fiorenze, Italy, October 2012.

</member>
        <member name="T:cv.SimpleBlobDetector">
@brief Class for extracting blobs from an image. :

The class implements a simple algorithm for extracting blobs from an image:

1.  Convert the source image to binary images by applying thresholding with several thresholds from
    minThreshold (inclusive) to maxThreshold (exclusive) with distance thresholdStep between
    neighboring thresholds.
2.  Extract connected components from every binary image by findContours and calculate their
    centers.
3.  Group centers from several binary images by their coordinates. Close centers form one group that
    corresponds to one blob, which is controlled by the minDistBetweenBlobs parameter.
4.  From the groups, estimate final centers of blobs and their radiuses and return as locations and
    sizes of keypoints.

This class performs several filtrations of returned blobs. You should set filterBy\* to true/false
to turn on/off corresponding filtration. Available filtrations:

-   **By color**. This filter compares the intensity of a binary image at the center of a blob to
blobColor. If they differ, the blob is filtered out. Use blobColor = 0 to extract dark blobs
and blobColor = 255 to extract light blobs.
-   **By area**. Extracted blobs have an area between minArea (inclusive) and maxArea (exclusive).
-   **By circularity**. Extracted blobs have circularity
(\f$\frac{4*\pi*Area}{perimeter * perimeter}\f$) between minCircularity (inclusive) and
maxCircularity (exclusive).
-   **By ratio of the minimum inertia to maximum inertia**. Extracted blobs have this ratio
between minInertiaRatio (inclusive) and maxInertiaRatio (exclusive).
-   **By convexity**. Extracted blobs have convexity (area / area of blob convex hull) between
minConvexity (inclusive) and maxConvexity (exclusive).

Default values of parameters are tuned to extract dark circular blobs.

</member>
        <member name="T:cv.GFTTDetector">
@brief Wrapping class for feature detection using the goodFeaturesToTrack function. :

</member>
        <member name="T:cv.AgastFeatureDetector">
@brief Wrapping class for feature detection using the AGAST method. :

</member>
        <member name="M:cv.AGAST(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean,System.Int32)">
@brief Detects corners using the AGAST algorithm

@param image grayscale image where keypoints (corners) are detected.
@param keypoints keypoints detected on the image.
@param threshold threshold on difference between intensity of the central pixel and pixels of a
circle around this pixel.
@param nonmaxSuppression if true, non-maximum suppression is applied to detected corners
(keypoints).
@param type one of the four neighborhoods as defined in the paper:
AgastFeatureDetector::AGAST_5_8, AgastFeatureDetector::AGAST_7_12d,
AgastFeatureDetector::AGAST_7_12s, AgastFeatureDetector::OAST_9_16

Detects corners using the AGAST algorithm by @cite mair2010_agast .


</member>
        <member name="M:cv.AGAST(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
@overload 
</member>
        <member name="T:cv.FastFeatureDetector">
@brief Wrapping class for feature detection using the FAST method. :

</member>
        <member name="M:cv.FAST(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean,System.Int32)">
@brief Detects corners using the FAST algorithm

@param image grayscale image where keypoints (corners) are detected.
@param keypoints keypoints detected on the image.
@param threshold threshold on difference between intensity of the central pixel and pixels of a
circle around this pixel.
@param nonmaxSuppression if true, non-maximum suppression is applied to detected corners
(keypoints).
@param type one of the three neighborhoods as defined in the paper:
FastFeatureDetector::TYPE_9_16, FastFeatureDetector::TYPE_7_12,
FastFeatureDetector::TYPE_5_8

Detects corners using the FAST algorithm by @cite Rosten06 .

@note In Python API, types are given as cv2.FAST_FEATURE_DETECTOR_TYPE_5_8,
cv2.FAST_FEATURE_DETECTOR_TYPE_7_12 and cv2.FAST_FEATURE_DETECTOR_TYPE_9_16. For corner
detection, use cv2.FAST.detect() method.

</member>
        <member name="M:cv.FAST(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
@overload 
</member>
        <member name="M:cv.ORB.create(System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
@brief The ORB constructor

    @param nfeatures The maximum number of features to retain.
    @param scaleFactor Pyramid decimation ratio, greater than 1. scaleFactor==2 means the classical
    pyramid, where each next level has 4x less pixels than the previous, but such a big scale factor
    will degrade feature matching scores dramatically. On the other hand, too close to 1 scale factor
    will mean that to cover certain scale range you will need more pyramid levels and so the speed
    will suffer.
    @param nlevels The number of pyramid levels. The smallest level will have linear size equal to
    input_image_linear_size/pow(scaleFactor, nlevels).
    @param edgeThreshold This is size of the border where the features are not detected. It should
    roughly match the patchSize parameter.
    @param firstLevel It should be 0 in the current implementation.
    @param WTA_K The number of points that produce each element of the oriented BRIEF descriptor. The
    default value 2 means the BRIEF where we take a random point pair and compare their brightnesses,
    so we get 0/1 response. Other possible values are 3 and 4. For example, 3 means that we take 3
    random points (of course, those point coordinates are random, but they are generated from the
    pre-defined seed, so each element of BRIEF descriptor is computed deterministically from the pixel
    rectangle), find point of maximum brightness and output index of the winner (0, 1 or 2). Such
    output will occupy 2 bits, and therefore it will need a special variant of Hamming distance,
    denoted as NORM_HAMMING2 (2 bits per bin). When WTA_K=4, we take 4 random points to compute each
    bin (that will also occupy 2 bits with possible values 0, 1, 2 or 3).
    @param scoreType The default HARRIS_SCORE means that Harris algorithm is used to rank features
    (the score is written to KeyPoint::score and is used to retain best nfeatures features);
    FAST_SCORE is alternative value of the parameter that produces slightly less stable keypoints,
    but it is a little faster to compute.
    @param patchSize size of the patch used by the oriented BRIEF descriptor. Of course, on smaller
    pyramid layers the perceived image area covered by a feature will be larger.
    @param fastThreshold

</member>
        <member name="T:cv.ORB">
@brief Class implementing the ORB (*oriented BRIEF*) keypoint detector and descriptor extractor

described in @cite RRKB11 . The algorithm uses FAST in pyramids to detect stable keypoints, selects
the strongest features using FAST or Harris response, finds their orientation using first-order
moments and computes the descriptors using BRIEF (where the coordinates of random point pairs (or
k-tuples) are rotated according to the measured orientation).

</member>
        <member name="M:cv.BRISK.create(std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,std.vector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief The BRISK constructor for a custom pattern

    @param radiusList defines the radii (in pixels) where the samples around a keypoint are taken (for
    keypoint scale 1).
    @param numberList defines the number of sampling points on the sampling circle. Must be the same
    size as radiusList..
    @param dMax threshold for the short pairings used for descriptor formation (in pixels for keypoint
    scale 1).
    @param dMin threshold for the long pairings used for orientation determination (in pixels for
    keypoint scale 1).
    @param indexChange index remapping of the bits. 
</member>
        <member name="M:cv.BRISK.create(System.Int32,System.Int32,System.Single)">
@brief The BRISK constructor

    @param thresh AGAST detection threshold score.
    @param octaves detection octaves. Use 0 to do single scale.
    @param patternScale apply this scale to the pattern used for sampling the neighbourhood of a
    keypoint.

</member>
        <member name="T:cv.BRISK">
@brief Class implementing the BRISK keypoint detector and descriptor extractor, described in @cite LCS11 .

</member>
        <member name="D:cv.DescriptorExtractor">
Extractors of keypoint descriptors in OpenCV have wrappers with a common interface that enables you
to easily switch between different algorithms solving the same problem. This section is devoted to
computing descriptors represented as vectors in a multidimensional space. All objects that implement
the vector descriptor extractors inherit the DescriptorExtractor interface.

</member>
        <member name="D:cv.FeatureDetector">
Feature detectors in OpenCV have wrappers with a common interface that enables you to easily switch
between different algorithms solving the same problem. All objects that implement keypoint detectors
inherit the FeatureDetector interface. 
</member>
        <member name="M:cv.Feature2D.detectAndCompute(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Detects keypoints and computes the descriptors 
</member>
        <member name="M:cv.Feature2D.compute(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.vector&lt;cv.KeyPoint&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload

    @param images Image set.
    @param keypoints Input collection of keypoints. Keypoints for which a descriptor cannot be
    computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint
    with several dominant orientations (for each orientation).
    @param descriptors Computed descriptors. In the second variant of the method descriptors[i] are
    descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the
    descriptor for keypoint j-th keypoint.

</member>
        <member name="M:cv.Feature2D.compute(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes the descriptors for a set of keypoints detected in an image (first variant) or image set
    (second variant).

    @param image Image.
    @param keypoints Input collection of keypoints. Keypoints for which a descriptor cannot be
    computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint
    with several dominant orientations (for each orientation).
    @param descriptors Computed descriptors. In the second variant of the method descriptors[i] are
    descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the
    descriptor for keypoint j-th keypoint.

</member>
        <member name="M:cv.Feature2D.detect(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.vector&lt;cv.KeyPoint&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param images Image set.
    @param keypoints The detected keypoints. In the second variant of the method keypoints[i] is a set
    of keypoints detected in images[i] .
    @param masks Masks for each input image specifying where to look for keypoints (optional).
    masks[i] is a mask for images[i].

</member>
        <member name="M:cv.Feature2D.detect(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Detects keypoints in an image (first variant) or image set (second variant).

    @param image Image.
    @param keypoints The detected keypoints. In the second variant of the method keypoints[i] is a set
    of keypoints detected in images[i] .
    @param mask Mask specifying where to look for keypoints (optional). It must be a 8-bit integer
    matrix with non-zero values in the region of interest.

</member>
        <member name="T:cv.Feature2D">
@brief Abstract base class for 2D image feature detectors and descriptor extractors

</member>
        <member name="T:cv.KeyPointsFilter">
@brief A class filters a vector of keypoints.

 Because now it is difficult to provide a convenient interface for all usage scenarios of the
 keypoints filter class, it has only several needed by now static methods.

</member>
        <member name="M:cvCalcOpticalFlowPyrLK(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void*,CvPoint2D32f!System.Runtime.CompilerServices.IsConst*,CvPoint2D32f*,System.Int32,CvSize,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Single*,CvTermCriteria,System.Int32)">
@addtogroup video_c
  @{

</member>
        <member name="M:cv.createBackgroundSubtractorKNN(System.Int32,System.Double,System.Boolean)">
@brief Creates KNN Background Subtractor

@param history Length of the history.
@param dist2Threshold Threshold on the squared distance between the pixel and the sample to decide
whether a pixel is close to that sample. This parameter does not affect the background update.
@param detectShadows If true, the algorithm will detect shadows and mark them. It decreases the
speed a bit, so if you do not need this feature, set the parameter to false.

</member>
        <member name="M:cv.BackgroundSubtractorKNN.setShadowThreshold(System.Double)">
@brief Sets the shadow threshold

</member>
        <member name="M:cv.BackgroundSubtractorKNN.getShadowThreshold">
@brief Returns the shadow threshold

    A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in
    the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel
    is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiarra,
    *Detecting Moving Shadows...*, IEEE PAMI,2003.

</member>
        <member name="M:cv.BackgroundSubtractorKNN.setShadowValue(System.Int32)">
@brief Sets the shadow value

</member>
        <member name="M:cv.BackgroundSubtractorKNN.getShadowValue">
@brief Returns the shadow value

    Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0
    in the mask always means background, 255 means foreground.

</member>
        <member name="M:cv.BackgroundSubtractorKNN.setDetectShadows(System.Boolean)">
@brief Enables or disables shadow detection

</member>
        <member name="M:cv.BackgroundSubtractorKNN.getDetectShadows">
@brief Returns the shadow detection flag

    If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorKNN for
    details.

</member>
        <member name="M:cv.BackgroundSubtractorKNN.setkNNSamples(System.Int32)">
@brief Sets the k in the kNN. How many nearest neigbours need to match.

</member>
        <member name="M:cv.BackgroundSubtractorKNN.getkNNSamples">
@brief Returns the number of neighbours, the k in the kNN.

    K is the number of samples that need to be within dist2Threshold in order to decide that that
    pixel is matching the kNN background model.

</member>
        <member name="M:cv.BackgroundSubtractorKNN.setDist2Threshold(System.Double)">
@brief Sets the threshold on the squared distance

</member>
        <member name="M:cv.BackgroundSubtractorKNN.getDist2Threshold">
@brief Returns the threshold on the squared distance between the pixel and the sample

    The threshold on the squared distance between the pixel and the sample to decide whether a pixel is
    close to a data sample.

</member>
        <member name="M:cv.BackgroundSubtractorKNN.setNSamples(System.Int32)">
@brief Sets the number of data samples in the background model.

    The model needs to be reinitalized to reserve memory.

</member>
        <member name="M:cv.BackgroundSubtractorKNN.getNSamples">
@brief Returns the number of data samples in the background model

</member>
        <member name="M:cv.BackgroundSubtractorKNN.setHistory(System.Int32)">
@brief Sets the number of last frames that affect the background model

</member>
        <member name="M:cv.BackgroundSubtractorKNN.getHistory">
@brief Returns the number of last frames that affect the background model

</member>
        <member name="T:cv.BackgroundSubtractorKNN">
@brief K-nearest neigbours - based Background/Foreground Segmentation Algorithm.

The class implements the K-nearest neigbours background subtraction described in @cite Zivkovic2006 .
Very efficient if number of foreground pixels is low.

</member>
        <member name="M:cv.createBackgroundSubtractorMOG2(System.Int32,System.Double,System.Boolean)">
@brief Creates MOG2 Background Subtractor

@param history Length of the history.
@param varThreshold Threshold on the squared Mahalanobis distance between the pixel and the model
to decide whether a pixel is well described by the background model. This parameter does not
affect the background update.
@param detectShadows If true, the algorithm will detect shadows and mark them. It decreases the
speed a bit, so if you do not need this feature, set the parameter to false.

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.setShadowThreshold(System.Double)">
@brief Sets the shadow threshold

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.getShadowThreshold">
@brief Returns the shadow threshold

    A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in
    the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel
    is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiarra,
    *Detecting Moving Shadows...*, IEEE PAMI,2003.

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.setShadowValue(System.Int32)">
@brief Sets the shadow value

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.getShadowValue">
@brief Returns the shadow value

    Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0
    in the mask always means background, 255 means foreground.

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.setDetectShadows(System.Boolean)">
@brief Enables or disables shadow detection

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.getDetectShadows">
@brief Returns the shadow detection flag

    If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorMOG2 for
    details.

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold(System.Double)">
@brief Sets the complexity reduction threshold

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.setVarInit(System.Double)">
@brief Sets the initial variance of each gaussian component

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.getVarInit">
@brief Returns the initial variance of each gaussian component

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.setVarThresholdGen(System.Double)">
@brief Sets the variance threshold for the pixel-model match used for new mixture component generation

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.getVarThresholdGen">
@brief Returns the variance threshold for the pixel-model match used for new mixture component generation

    Threshold for the squared Mahalanobis distance that helps decide when a sample is close to the
    existing components (corresponds to Tg in the paper). If a pixel is not close to any component, it
    is considered foreground or added as a new component. 3 sigma =\&gt; Tg=3\*3=9 is default. A smaller Tg
    value generates more components. A higher Tg value may result in a small number of components but
    they can grow too large.

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.setVarThreshold(System.Double)">
@brief Sets the variance threshold for the pixel-model match

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.getVarThreshold">
@brief Returns the variance threshold for the pixel-model match

    The main threshold on the squared Mahalanobis distance to decide if the sample is well described by
    the background model or not. Related to Cthr from the paper.

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.setBackgroundRatio(System.Double)">
@brief Sets the "background ratio" parameter of the algorithm

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.getBackgroundRatio">
@brief Returns the "background ratio" parameter of the algorithm

    If a foreground pixel keeps semi-constant value for about backgroundRatio\*history frames, it's
    considered background and added to the model as a center of a new component. It corresponds to TB
    parameter in the paper.

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.setNMixtures(System.Int32)">
@brief Sets the number of gaussian components in the background model.

    The model needs to be reinitalized to reserve memory.

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.getNMixtures">
@brief Returns the number of gaussian components in the background model

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.setHistory(System.Int32)">
@brief Sets the number of last frames that affect the background model

</member>
        <member name="M:cv.BackgroundSubtractorMOG2.getHistory">
@brief Returns the number of last frames that affect the background model

</member>
        <member name="T:cv.BackgroundSubtractorMOG2">
@brief Gaussian Mixture-based Background/Foreground Segmentation Algorithm.

The class implements the Gaussian mixture model background subtraction described in @cite Zivkovic2004
and @cite Zivkovic2006 .

</member>
        <member name="M:cv.BackgroundSubtractor.getBackgroundImage(cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes a background image.

    @param backgroundImage The output background image.

    @note Sometimes the background image can be very blurry, as it contain the average background
    statistics.

</member>
        <member name="M:cv.BackgroundSubtractor.apply(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief Computes a foreground mask.

    @param image Next video frame.
    @param fgmask The output foreground mask as an 8-bit binary image.
    @param learningRate The value between 0 and 1 that indicates how fast the background model is
    learnt. Negative parameter value makes the algorithm to use some automatically chosen learning
    rate. 0 means that the background model is not updated at all, 1 means that the background model
    is completely reinitialized from the last frame.

</member>
        <member name="T:cv.BackgroundSubtractor">
@brief Base class for background/foreground segmentation. :

The class is only used to define the common interface for the whole family of background/foreground
segmentation algorithms.

</member>
        <member name="M:cv.createOptFlow_DualTVL1">
@brief Creates instance of cv::DenseOpticalFlow

</member>
        <member name="M:cv.DualTVL1OpticalFlow.setMedianFiltering(System.Int32)">
@copybrief getMedianFiltering @see getMedianFiltering 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getMedianFiltering">
@see setMedianFiltering 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.setScaleStep(System.Double)">
@copybrief getScaleStep @see getScaleStep 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getScaleStep">
@see setScaleStep 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.setUseInitialFlow(System.Boolean)">
@copybrief getUseInitialFlow @see getUseInitialFlow 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getUseInitialFlow">
@see setUseInitialFlow 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.setOuterIterations(System.Int32)">
@copybrief getOuterIterations @see getOuterIterations 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getOuterIterations">
@see setOuterIterations 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.setInnerIterations(System.Int32)">
@copybrief getInnerIterations @see getInnerIterations 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getInnerIterations">
@see setInnerIterations 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.setEpsilon(System.Double)">
@copybrief getEpsilon @see getEpsilon 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getEpsilon">
@see setEpsilon 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.setWarpingsNumber(System.Int32)">
@copybrief getWarpingsNumber @see getWarpingsNumber 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getWarpingsNumber">
@see setWarpingsNumber 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.setScalesNumber(System.Int32)">
@copybrief getScalesNumber @see getScalesNumber 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getScalesNumber">
@see setScalesNumber 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.setGamma(System.Double)">
@copybrief getGamma @see getGamma 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getGamma">
@see setGamma 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.setTheta(System.Double)">
@copybrief getTheta @see getTheta 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getTheta">
@see setTheta 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.setLambda(System.Double)">
@copybrief getLambda @see getLambda 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getLambda">
@see setLambda 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.setTau(System.Double)">
@copybrief getTau @see getTau 
</member>
        <member name="M:cv.DualTVL1OpticalFlow.getTau">
@see setTau 
</member>
        <member name="T:cv.DualTVL1OpticalFlow">
@brief "Dual TV L1" Optical Flow Algorithm.

The class implements the "Dual TV L1" optical flow algorithm described in @cite Zach2007 and
@cite Javier2012 .
Here are important members of the class that control the algorithm, which you can set after
constructing the class instance:

-   member double tau
    Time step of the numerical scheme.

-   member double lambda
    Weight parameter for the data term, attachment parameter. This is the most relevant
    parameter, which determines the smoothness of the output. The smaller this parameter is,
    the smoother the solutions we obtain. It depends on the range of motions of the images, so
    its value should be adapted to each image sequence.

-   member double theta
    Weight parameter for (u - v)\^2, tightness parameter. It serves as a link between the
    attachment and the regularization terms. In theory, it should have a small value in order
    to maintain both parts in correspondence. The method is stable for a large range of values
    of this parameter.

-   member int nscales
    Number of scales used to create the pyramid of images.

-   member int warps
    Number of warpings per scale. Represents the number of times that I1(x+u0) and grad(
    I1(x+u0) ) are computed per scale. This is a parameter that assures the stability of the
    method. It also affects the running time, so it is a compromise between speed and
    accuracy.

-   member double epsilon
    Stopping criterion threshold used in the numerical scheme, which is a trade-off between
    precision and running time. A small value will yield more accurate solutions at the
    expense of a slower convergence.

-   member int iterations
    Stopping criterion iterations number used in the numerical scheme.

C. Zach, T. Pock and H. Bischof, "A Duality Based Approach for Realtime TV-L1 Optical Flow".
Javier Sanchez, Enric Meinhardt-Llopis and Gabriele Facciolo. "TV-L1 Optical Flow Estimation".

</member>
        <member name="M:cv.DenseOpticalFlow.collectGarbage">
@brief Releases all inner buffers.

</member>
        <member name="M:cv.DenseOpticalFlow.calc(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates an optical flow.

    @param I0 first 8-bit single-channel input image.
    @param I1 second input image of the same size and the same type as prev.
    @param flow computed flow image that has the same size as prev and type CV_32FC2.

</member>
        <member name="M:cv.KalmanFilter.correct(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Updates the predicted state from the measurement.

    @param measurement The measured system parameters

</member>
        <member name="M:cv.KalmanFilter.predict(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes a predicted state.

    @param control The optional input control

</member>
        <member name="M:cv.KalmanFilter.init(System.Int32,System.Int32,System.Int32,System.Int32)">
@brief Re-initializes Kalman filter. The previous content is destroyed.

    @param dynamParams Dimensionality of the state.
    @param measureParams Dimensionality of the measurement.
    @param controlParams Dimensionality of the control vector.
    @param type Type of the created matrices that should be CV_32F or CV_64F.

</member>
        <member name="M:cv.KalmanFilter.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
@overload
    @param dynamParams Dimensionality of the state.
    @param measureParams Dimensionality of the measurement.
    @param controlParams Dimensionality of the control vector.
    @param type Type of the created matrices that should be CV_32F or CV_64F.

</member>
        <member name="M:cv.findTransformECC(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.TermCriteria,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Finds the geometric transform (warp) between two images in terms of the ECC criterion @cite EP08 .

@param templateImage single-channel template image; CV_8U or CV_32F array.
@param inputImage single-channel input image which should be warped with the final warpMatrix in
order to provide an image similar to templateImage, same type as temlateImage.
@param warpMatrix floating-point \f$2\times 3\f$ or \f$3\times 3\f$ mapping matrix (warp).
@param motionType parameter, specifying the type of motion:
 -   **MOTION_TRANSLATION** sets a translational motion model; warpMatrix is \f$2\times 3\f$ with
     the first \f$2\times 2\f$ part being the unity matrix and the rest two parameters being
     estimated.
 -   **MOTION_EUCLIDEAN** sets a Euclidean (rigid) transformation as motion model; three
     parameters are estimated; warpMatrix is \f$2\times 3\f$.
 -   **MOTION_AFFINE** sets an affine motion model (DEFAULT); six parameters are estimated;
     warpMatrix is \f$2\times 3\f$.
 -   **MOTION_HOMOGRAPHY** sets a homography as a motion model; eight parameters are
     estimated;\`warpMatrix\` is \f$3\times 3\f$.
@param criteria parameter, specifying the termination criteria of the ECC algorithm;
criteria.epsilon defines the threshold of the increment in the correlation coefficient between two
iterations (a negative criteria.epsilon makes criteria.maxcount the only termination criterion).
Default values are shown in the declaration above.
@param inputMask An optional mask to indicate valid values of inputImage.

The function estimates the optimum transformation (warpMatrix) with respect to ECC criterion
(@cite EP08), that is

\f[\texttt{warpMatrix} = \texttt{warpMatrix} = \arg\max_{W} \texttt{ECC}(\texttt{templateImage}(x,y),\texttt{inputImage}(x',y'))\f]

where

\f[\begin{bmatrix} x' \\ y' \end{bmatrix} = W \cdot \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}\f]

(the equation holds with homogeneous coordinates for homography). It returns the final enhanced
correlation coefficient, that is the correlation coefficient between the template image and the
final warped input image. When a \f$3\times 3\f$ matrix is given with motionType =0, 1 or 2, the third
row is ignored.

Unlike findHomography and estimateRigidTransform, the function findTransformECC implements an
area-based alignment that builds on intensity similarities. In essence, the function updates the
initial transformation that roughly aligns the images. If this information is missing, the identity
warp (unity matrix) should be given as input. Note that if images undergo strong
displacements/rotations, an initial transformation that roughly aligns the images is necessary
(e.g., a simple euclidean/similarity transform that allows for the images showing the same image
content approximately). Use inverse warping in the second image to take an image close to the first
one, i.e. use the flag WARP_INVERSE_MAP with warpAffine or warpPerspective. See also the OpenCV
sample image_alignment.cpp that demonstrates the use of the function. Note that the function throws
an exception if algorithm does not converges.

@sa
estimateRigidTransform, findHomography

</member>
        <member name="M:cv.calcOpticalFlowPyrLK(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Int32,cv.TermCriteria,System.Int32,">
@brief Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with
pyramids.

@param prevImg first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid.
@param nextImg second input image or pyramid of the same size and the same type as prevImg.
@param prevPts vector of 2D points for which the flow needs to be found; point coordinates must be
single-precision floating-point numbers.
@param nextPts output vector of 2D points (with single-precision floating-point coordinates)
containing the calculated new positions of input features in the second image; when
OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input.
@param status output status vector (of unsigned chars); each element of the vector is set to 1 if
the flow for the corresponding features has been found, otherwise, it is set to 0.
@param err output vector of errors; each element of the vector is set to an error for the
corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't
found then the error is not defined (use the status parameter to find such cases).
@param winSize size of the search window at each pyramid level.
@param maxLevel 0-based maximal pyramid level number; if set to 0, pyramids are not used (single
level), if set to 1, two levels are used, and so on; if pyramids are passed to input then
algorithm will use as many levels as pyramids have but no more than maxLevel.
@param criteria parameter, specifying the termination criteria of the iterative search algorithm
(after the specified maximum number of iterations criteria.maxCount or when the search window
moves by less than criteria.epsilon.
@param flags operation flags:
 -   **OPTFLOW_USE_INITIAL_FLOW** uses initial estimations, stored in nextPts; if the flag is
     not set, then prevPts is copied to nextPts and is considered the initial estimate.
 -   **OPTFLOW_LK_GET_MIN_EIGENVALS** use minimum eigen values as an error measure (see
     minEigThreshold description); if the flag is not set, then L1 distance between patches
     around the original and a moved point, divided by number of pixels in a window, is used as a
     error measure.
@param minEigThreshold the algorithm calculates the minimum eigen value of a 2x2 normal matrix of
optical flow equations (this matrix is called a spatial gradient matrix in @cite Bouguet00), divided
by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding
feature is filtered out and its flow is not processed, so it allows to remove bad points and get a
performance boost.

The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See
@cite Bouguet00 . The function is parallelized with the TBB library.

@note

-   An example using the Lucas-Kanade optical flow algorithm can be found at
    opencv_source_code/samples/cpp/lkdemo.cpp
-   (Python) An example using the Lucas-Kanade optical flow algorithm can be found at
    opencv_source_code/samples/python2/lk_track.py
-   (Python) An example using the Lucas-Kanade tracker for homography matching can be found at
    opencv_source_code/samples/python2/lk_homography.py

</member>
        <member name="M:cv.buildOpticalFlowPyramid(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Int32,System.Boolean,System.Int32,System.Int32,System.Boolean)">
@brief Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.

@param img 8-bit input image.
@param pyramid output pyramid.
@param winSize window size of optical flow algorithm. Must be not less than winSize argument of
calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels.
@param maxLevel 0-based maximal pyramid level number.
@param withDerivatives set to precompute gradients for the every pyramid level. If pyramid is
constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally.
@param pyrBorder the border mode for pyramid layers.
@param derivBorder the border mode for gradients.
@param tryReuseInputImage put ROI of input image into the pyramid if possible. You can pass false
to force data copying.
@return number of levels in constructed pyramid. Can be less than maxLevel.

</member>
        <member name="M:cv.meanShift(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Rect_&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.TermCriteria)">
@brief Finds an object on a back projection image.

@param probImage Back projection of the object histogram. See calcBackProject for details.
@param window Initial search window.
@param criteria Stop criteria for the iterative search algorithm.
returns
:   Number of iterations CAMSHIFT took to converge.
The function implements the iterative object search algorithm. It takes the input back projection of
an object and the initial position. The mass center in window of the back projection image is
computed and the search window center shifts to the mass center. The procedure is repeated until the
specified number of iterations criteria.maxCount is done or until the window center shifts by less
than criteria.epsilon. The algorithm is used inside CamShift and, unlike CamShift , the search
window size or orientation do not change during the search. You can simply pass the output of
calcBackProject to this function. But better results can be obtained if you pre-filter the back
projection and remove the noise. For example, you can do this by retrieving connected components
with findContours , throwing away contours with small area ( contourArea ), and rendering the
remaining contours with drawContours.

@note
-   A mean-shift tracking sample can be found at opencv_source_code/samples/cpp/camshiftdemo.cpp

</member>
        <member name="M:cv.CamShift(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Rect_&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.TermCriteria)">
@brief Finds an object center, size, and orientation.

@param probImage Back projection of the object histogram. See calcBackProject.
@param window Initial search window.
@param criteria Stop criteria for the underlying meanShift.
returns
(in old interfaces) Number of iterations CAMSHIFT took to converge
The function implements the CAMSHIFT object tracking algorithm @cite Bradski98 . First, it finds an
object center using meanShift and then adjusts the window size and finds the optimal rotation. The
function returns the rotated rectangle structure that includes the object position, size, and
orientation. The next position of the search window can be obtained with RotatedRect::boundingRect()

See the OpenCV sample camshiftdemo.c that tracks colored objects.

@note
-   (Python) A sample explaining the camshift tracking algorithm can be found at
    opencv_source_code/samples/python2/camshift.py

</member>
        <member name="T:InpaintingModes">
@addtogroup photo_c
  @{

</member>
        <member name="M:cv.stylization(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single)">
@brief Stylization aims to produce digital imagery with a wide variety of effects not focused on
photorealism. Edge-aware filters are ideal for stylization, as they can abstract regions of low
contrast while preserving, or enhancing, high-contrast features.

@param src Input 8-bit 3-channel image.
@param dst Output image with the same size and type as src.
@param sigma_s Range between 0 to 200.
@param sigma_r Range between 0 to 1.

</member>
        <member name="M:cv.pencilSketch(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single)">
@brief Pencil-like non-photorealistic line drawing

@param src Input 8-bit 3-channel image.
@param dst1 Output 8-bit 1-channel image.
@param dst2 Output image with the same size and type as src.
@param sigma_s Range between 0 to 200.
@param sigma_r Range between 0 to 1.
@param shade_factor Range between 0 to 0.1.

</member>
        <member name="M:cv.detailEnhance(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single)">
@brief This filter enhances the details of a particular image.

@param src Input 8-bit 3-channel image.
@param dst Output image with the same size and type as src.
@param sigma_s Range between 0 to 200.
@param sigma_r Range between 0 to 1.

</member>
        <member name="M:cv.edgePreservingFilter(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Single,System.Single)">
@brief Filtering is the fundamental operation in image and video processing. Edge-preserving smoothing
filters are used in many different applications @cite EM11 .

@param src Input 8-bit 3-channel image.
@param dst Output 8-bit 3-channel image.
@param flags Edge preserving filters:
-   **RECURS_FILTER** = 1
-   **NORMCONV_FILTER** = 2
@param sigma_s Range between 0 to 200.
@param sigma_r Range between 0 to 1.

</member>
        <member name="M:cv.textureFlattening(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Int32)">
@brief By retaining only the gradients at edge locations, before integrating with the Poisson solver, one
washes out the texture of the selected region, giving its contents a flat aspect. Here Canny Edge
Detector is used.

@param src Input 8-bit 3-channel image.
@param mask Input 8-bit 1 or 3-channel image.
@param dst Output image with the same size and type as src.
@param low_threshold Range from 0 to 100.
@param high_threshold Value \&gt; 100.
@param kernel_size The size of the Sobel kernel to be used.

**NOTE:**

The algorithm assumes that the color of the source image is close to that of the destination. This
assumption means that when the colors don't match, the source image color gets tinted toward the
color of the destination image.

</member>
        <member name="M:cv.illuminationChange(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single)">
@brief Applying an appropriate non-linear transformation to the gradient field inside the selection and
then integrating back with a Poisson solver, modifies locally the apparent illumination of an image.

@param src Input 8-bit 3-channel image.
@param mask Input 8-bit 1 or 3-channel image.
@param dst Output image with the same size and type as src.
@param alpha Value ranges between 0-2.
@param beta Value ranges between 0-2.

This is useful to highlight under-exposed foreground objects or to reduce specular reflections.

</member>
        <member name="M:cv.colorChange(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single)">
@brief Given an original color image, two differently colored versions of this image can be mixed
seamlessly.

@param src Input 8-bit 3-channel image.
@param mask Input 8-bit 1 or 3-channel image.
@param dst Output image with the same size and type as src .
@param red_mul R-channel multiply factor.
@param green_mul G-channel multiply factor.
@param blue_mul B-channel multiply factor.

Multiplication factor is between .5 to 2.5.

</member>
        <member name="M:cv.seamlessClone(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Image editing tasks concern either global changes (color/intensity corrections, filters,
deformations) or local changes concerned to a selection. Here we are interested in achieving local
changes, ones that are restricted to a region manually selected (ROI), in a seamless and effortless
manner. The extent of the changes ranges from slight distortions to complete replacement by novel
content @cite PM03 .

@param src Input 8-bit 3-channel image.
@param dst Input 8-bit 3-channel image.
@param mask Input 8-bit 1 or 3-channel image.
@param p Point in dst image where object is placed.
@param blend Output image with the same size and type as dst.
@param flags Cloning method that could be one of the following:
-   **NORMAL_CLONE** The power of the method is fully expressed when inserting objects with
complex outlines into a new background
-   **MIXED_CLONE** The classic method, color-based selection and alpha masking might be time
consuming and often leaves an undesirable halo. Seamless cloning, even averaged with the
original image, is not effective. Mixed seamless cloning based on a loose selection proves
effective.
-   **FEATURE_EXCHANGE** Feature exchange allows the user to easily replace certain features of
one object by alternative features.

</member>
        <member name="M:cv.decolor(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Transforms a color image to a grayscale image. It is a basic tool in digital printing, stylized
black-and-white photograph rendering, and in many single channel image processing applications
@cite CL12 .

@param src Input 8-bit 3-channel image.
@param grayscale Output 8-bit 1-channel image.
@param color_boost Output 8-bit 3-channel image.

This function is to be applied on color images.

</member>
        <member name="M:cv.createMergeRobertson">
@brief Creates MergeRobertson object

</member>
        <member name="T:cv.MergeRobertson">
@brief The resulting HDR image is calculated as weighted average of the exposures considering exposure
values and camera response.

For more information see @cite RB99 .

</member>
        <member name="M:cv.createMergeMertens(System.Single,System.Single,System.Single)">
@brief Creates MergeMertens object

@param contrast_weight contrast measure weight. See MergeMertens.
@param saturation_weight saturation measure weight
@param exposure_weight well-exposedness measure weight

</member>
        <member name="M:cv.MergeMertens.process(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Short version of process, that doesn't take extra arguments.

    @param src vector of input images
    @param dst result image

</member>
        <member name="T:cv.MergeMertens">
@brief Pixels are weighted using contrast, saturation and well-exposedness measures, than images are
combined using laplacian pyramids.

The resulting image weight is constructed as weighted average of contrast, saturation and
well-exposedness measures.

The resulting image doesn't require tonemapping and can be converted to 8-bit image by multiplying
by 255, but it's recommended to apply gamma correction and/or linear tonemapping.

For more information see @cite MK07 .

</member>
        <member name="M:cv.createMergeDebevec">
@brief Creates MergeDebevec object

</member>
        <member name="T:cv.MergeDebevec">
@brief The resulting HDR image is calculated as weighted average of the exposures considering exposure
values and camera response.

For more information see @cite DM97 .

</member>
        <member name="M:cv.MergeExposures.process(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Merges images.

    @param src vector of input images
    @param dst result image
    @param times vector of exposure time values for each image
    @param response 256x1 matrix with inverse camera response function for each pixel value, it should
    have the same number of channels as images.

</member>
        <member name="T:cv.MergeExposures">
@brief The base class algorithms that can merge exposure sequence to a single image.

</member>
        <member name="M:cv.createCalibrateRobertson(System.Int32,System.Single)">
@brief Creates CalibrateRobertson object

@param max_iter maximal number of Gauss-Seidel solver iterations.
@param threshold target difference between results of two successive steps of the minimization.

</member>
        <member name="T:cv.CalibrateRobertson">
@brief Inverse camera response function is extracted for each brightness value by minimizing an objective
function as linear system. This algorithm uses all image pixels.

For more information see @cite RB99 .

</member>
        <member name="M:cv.createCalibrateDebevec(System.Int32,System.Single,System.Boolean)">
@brief Creates CalibrateDebevec object

@param samples number of pixel locations to use
@param lambda smoothness term weight. Greater values produce smoother results, but can alter the
response.
@param random if true sample pixel locations are chosen at random, otherwise the form a
rectangular grid.

</member>
        <member name="T:cv.CalibrateDebevec">
@brief Inverse camera response function is extracted for each brightness value by minimizing an objective
function as linear system. Objective function is constructed using pixel values on the same position
in all images, extra term is added to make the result smoother.

For more information see @cite DM97 .

</member>
        <member name="M:cv.CalibrateCRF.process(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Recovers inverse camera response.

    @param src vector of input images
    @param dst 256x1 matrix with inverse camera response function
    @param times vector of exposure time values for each image

</member>
        <member name="T:cv.CalibrateCRF">
@brief The base class for camera response calibration algorithms.

</member>
        <member name="M:cv.createAlignMTB(System.Int32,System.Int32,System.Boolean)">
@brief Creates AlignMTB object

@param max_bits logarithm to the base 2 of maximal shift in each dimension. Values of 5 and 6 are
usually good enough (31 and 63 pixels shift respectively).
@param exclude_range range for exclusion bitmap that is constructed to suppress noise around the
median value.
@param cut if true cuts images, otherwise fills the new regions with zeros.

</member>
        <member name="M:cv.AlignMTB.computeBitmaps(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes median threshold and exclude bitmaps of given image.

    @param img input image
    @param tb median threshold bitmap
    @param eb exclude bitmap

</member>
        <member name="M:cv.AlignMTB.shiftMat(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst)">
@brief Helper function, that shift Mat filling new regions with zeros.

    @param src input image
    @param dst result image
    @param shift shift value

</member>
        <member name="M:cv.AlignMTB.calculateShift(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates shift between two images, i. e. how to shift the second image to correspond it with the
    first.

    @param img0 first image
    @param img1 second image

</member>
        <member name="M:cv.AlignMTB.process(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Mat&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Short version of process, that doesn't take extra arguments.

    @param src vector of input images
    @param dst vector of aligned images

</member>
        <member name="T:cv.AlignMTB">
@brief This algorithm converts images to median threshold bitmaps (1 for pixels brighter than median
luminance and 0 otherwise) and than aligns the resulting bitmaps using bit operations.

It is invariant to exposure, so exposure values and camera response are not necessary.

In this implementation new image regions are filled with zeros.

For more information see @cite GW03 .

</member>
        <member name="M:cv.AlignExposures.process(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Mat&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Aligns images

    @param src vector of input images
    @param dst vector of aligned images
    @param times vector of exposure time values for each image
    @param response 256x1 matrix with inverse camera response function for each pixel value, it should
    have the same number of channels as images.

</member>
        <member name="T:cv.AlignExposures">
@brief The base class for algorithms that align images of the same scene with different exposures

</member>
        <member name="M:cv.createTonemapMantiuk(System.Single,System.Single,System.Single)">
@brief Creates TonemapMantiuk object

@param gamma gamma value for gamma correction. See createTonemap
@param scale contrast scale factor. HVS response is multiplied by this parameter, thus compressing
dynamic range. Values from 0.6 to 0.9 produce best results.
@param saturation saturation enhancement value. See createTonemapDrago

</member>
        <member name="T:cv.TonemapMantiuk">
@brief This algorithm transforms image to contrast using gradients on all levels of gaussian pyramid,
transforms contrast values to HVS response and scales the response. After this the image is
reconstructed from new contrast values.

For more information see @cite MM06 .

</member>
        <member name="M:cv.createTonemapReinhard(System.Single,System.Single,System.Single,System.Single)">
@brief Creates TonemapReinhard object

@param gamma gamma value for gamma correction. See createTonemap
@param intensity result intensity in [-8, 8] range. Greater intensity produces brighter results.
@param light_adapt light adaptation in [0, 1] range. If 1 adaptation is based only on pixel
value, if 0 it's global, otherwise it's a weighted mean of this two cases.
@param color_adapt chromatic adaptation in [0, 1] range. If 1 channels are treated independently,
if 0 adaptation level is the same for each channel.

</member>
        <member name="T:cv.TonemapReinhard">
@brief This is a global tonemapping operator that models human visual system.

Mapping function is controlled by adaptation parameter, that is computed using light adaptation and
color adaptation.

For more information see @cite RD05 .

</member>
        <member name="M:cv.createTonemapDurand(System.Single,System.Single,System.Single,System.Single,System.Single)">
@brief Creates TonemapDurand object

@param gamma gamma value for gamma correction. See createTonemap
@param contrast resulting contrast on logarithmic scale, i. e. log(max / min), where max and min
are maximum and minimum luminance values of the resulting image.
@param saturation saturation enhancement value. See createTonemapDrago
@param sigma_space bilateral filter sigma in color space
@param sigma_color bilateral filter sigma in coordinate space

</member>
        <member name="T:cv.TonemapDurand">
@brief This algorithm decomposes image into two layers: base layer and detail layer using bilateral filter
and compresses contrast of the base layer thus preserving all the details.

This implementation uses regular bilateral filter from opencv.

Saturation enhancement is possible as in ocvTonemapDrago.

For more information see @cite DD02 .

</member>
        <member name="M:cv.createTonemapDrago(System.Single,System.Single,System.Single)">
@brief Creates TonemapDrago object

@param gamma gamma value for gamma correction. See createTonemap
@param saturation positive saturation enhancement value. 1.0 preserves saturation, values greater
than 1 increase saturation and values less than 1 decrease it.
@param bias value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best
results, default value is 0.85.

</member>
        <member name="T:cv.TonemapDrago">
@brief Adaptive logarithmic mapping is a fast global tonemapping algorithm that scales the image in
logarithmic domain.

Since it's a global operator the same function is applied to all the pixels, it is controlled by the
bias parameter.

Optional saturation enhancement is possible as described in @cite FL02 .

For more information see @cite DM03 .

</member>
        <member name="M:cv.Tonemap.process(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Tonemaps image

    @param src source image - 32-bit 3-channel Mat
    @param dst destination image - 32-bit 3-channel Mat with values in [0, 1] range

</member>
        <member name="T:cv.Tonemap">
@brief Base class for tonemapping algorithms - tools that are used to map HDR image to 8-bit range.

</member>
        <member name="M:cv.denoise_TVL1(std.vector&lt;cv.Mat&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32)">
@brief Primal-dual algorithm is an algorithm for solving special types of variational problems (that is,
finding a function to minimize some functional). As the image denoising, in particular, may be seen
as the variational problem, primal-dual algorithm then can be used to perform denoising and this is
exactly what is implemented.

It should be noted, that this implementation was taken from the July 2013 blog entry
@cite MA13 , which also contained (slightly more general) ready-to-use source code on Python.
Subsequently, that code was rewritten on C++ with the usage of openCV by Vadim Pisarevsky at the end
of July 2013 and finally it was slightly adapted by later authors.

Although the thorough discussion and justification of the algorithm involved may be found in
@cite ChambolleEtAl, it might make sense to skim over it here, following @cite MA13 . To begin
with, we consider the 1-byte gray-level images as the functions from the rectangular domain of
pixels (it may be seen as set
\f$\left\{(x,y)\in\mathbb{N}\times\mathbb{N}\mid 1\leq x\leq n,\;1\leq y\leq m\right\}\f$ for some
\f$m,\;n\in\mathbb{N}\f$) into \f$\{0,1,\dots,255\}\f$. We shall denote the noised images as \f$f_i\f$ and with
this view, given some image \f$x\f$ of the same size, we may measure how bad it is by the formula

\f[\left\|\left\|\nabla x\right\|\right\| + \lambda\sum_i\left\|\left\|x-f_i\right\|\right\|\f]

\f$\|\|\cdot\|\|\f$ here denotes \f$L_2\f$-norm and as you see, the first addend states that we want our
image to be smooth (ideally, having zero gradient, thus being constant) and the second states that
we want our result to be close to the observations we've got. If we treat \f$x\f$ as a function, this is
exactly the functional what we seek to minimize and here the Primal-Dual algorithm comes into play.

@param observations This array should contain one or more noised versions of the image that is to
be restored.
@param result Here the denoised image will be stored. There is no need to do pre-allocation of
storage space, as it will be automatically allocated, if necessary.
@param lambda Corresponds to \f$\lambda\f$ in the formulas above. As it is enlarged, the smooth
(blurred) images are treated more favorably than detailed (but maybe more noised) ones. Roughly
speaking, as it becomes smaller, the result will be more blur but more sever outliers will be
removed.
@param niters Number of iterations that the algorithm will run. Of course, as more iterations as
better, but it is hard to quantitatively refine this statement, so just use the default and
increase it if the results are poor.

</member>
        <member name="M:cv.fastNlMeansDenoisingColoredMulti(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
@brief Modification of fastNlMeansDenoisingMulti function for colored images sequences

@param srcImgs Input 8-bit 3-channel images sequence. All images should have the same type and
size.
@param imgToDenoiseIndex Target image to denoise index in srcImgs sequence
@param temporalWindowSize Number of surrounding images to use for target image denoising. Should
be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to
imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise
srcImgs[imgToDenoiseIndex] image.
@param dst Output image with the same size and type as srcImgs images.
@param templateWindowSize Size in pixels of the template patch that is used to compute weights.
Should be odd. Recommended value 7 pixels
@param searchWindowSize Size in pixels of the window that is used to compute weighted average for
given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
denoising time. Recommended value 21 pixels
@param h Parameter regulating filter strength for luminance component. Bigger h value perfectly
removes noise but also removes image details, smaller h value preserves details but also preserves
some noise.
@param hColor The same as h but for color components.

The function converts images to CIELAB colorspace and then separately denoise L and AB components
with given h parameters using fastNlMeansDenoisingMulti function.

</member>
        <member name="M:cv.fastNlMeansDenoisingColored(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Int32,System.Int32)">
@brief Modification of fastNlMeansDenoising function for colored images

@param src Input 8-bit 3-channel image.
@param dst Output image with the same size and type as src .
@param templateWindowSize Size in pixels of the template patch that is used to compute weights.
Should be odd. Recommended value 7 pixels
@param searchWindowSize Size in pixels of the window that is used to compute weighted average for
given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
denoising time. Recommended value 21 pixels
@param h Parameter regulating filter strength for luminance component. Bigger h value perfectly
removes noise but also removes image details, smaller h value preserves details but also preserves
some noise
@param hColor The same as h but for color components. For most images value equals 10
will be enough to remove colored noise and do not distort colors

The function converts image to CIELAB colorspace and then separately denoise L and AB components
with given h parameters using fastNlMeansDenoising function.

</member>
        <member name="M:cvDrawContours(System.Void*,CvSeq*,CvScalar,CvScalar,System.Int32,System.Int32,System.Int32,CvPoint)">
@brief Draws contour outlines or filled interiors on the image
@see cv::drawContours

</member>
        <member name="M:cvEllipse2Poly(CvPoint,CvSize,System.Int32,System.Int32,System.Int32,CvPoint*,System.Int32)">
@brief Returns the polygon points which make up the given ellipse.

The ellipse is define by the box of size 'axes' rotated 'angle' around the 'center'. A partial
sweep of the ellipse arc can be done by spcifying arc_start and arc_end to be something other than
0 and 360, respectively. The input array 'pts' must be large enough to hold the result. The total
number of points stored into 'pts' is returned by this function.
@see cv::ellipse2Poly

</member>
        <member name="M:cvColorToScalar(System.Double,System.Int32)">
@brief Unpacks color value

if arrtype is CV_8UC?, _color_ is treated as packed color value, otherwise the first channels
(depending on arrtype) of destination scalar are set to the same value = _color_

</member>
        <member name="M:cvGetTextSize(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,CvFont!System.Runtime.CompilerServices.IsConst*,CvSize*,System.Int32*)">
@brief Calculates bounding box of text stroke (useful for alignment)
@see cv::getTextSize

</member>
        <member name="M:cvPutText(System.Void*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,CvPoint,CvFont!System.Runtime.CompilerServices.IsConst*,CvScalar)">
@brief Renders text stroke with specified font and color at specified location.
   CvFont should be initialized with cvInitFont
@see cvInitFont, cvGetTextSize, cvFont, cv::putText

</member>
        <member name="M:cvInitFont(CvFont*,System.Int32,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
@brief Initializes font structure (OpenCV 1.x API).

The function initializes the font structure that can be passed to text rendering functions.

@param font Pointer to the font structure initialized by the function
@param font_face Font name identifier. See cv::HersheyFonts and corresponding old CV_* identifiers.
@param hscale Horizontal scale. If equal to 1.0f , the characters have the original width
depending on the font type. If equal to 0.5f , the characters are of half the original width.
@param vscale Vertical scale. If equal to 1.0f , the characters have the original height depending
on the font type. If equal to 0.5f , the characters are of half the original height.
@param shear Approximate tangent of the character slope relative to the vertical line. A zero
value means a non-italic font, 1.0f means about a 45 degree slope, etc.
@param thickness Thickness of the text strokes
@param line_type Type of the strokes, see line description

@sa cvPutText

</member>
        <member name="T:CvFont">
Font structure 
</member>
        <member name="M:cvInitLineIterator(System.Void!System.Runtime.CompilerServices.IsConst*,CvPoint,CvPoint,CvLineIterator*,System.Int32,System.Int32)">
@brief Initializes line iterator.

Initially, line_iterator-&gt;ptr will point to pt1 (or pt2, see left_to_right description) location in
the image. Returns the number of pixels on the line between the ending points.
@see cv::LineIterator

</member>
        <member name="M:cvPolyLine(System.Void*,CvPoint**,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,CvScalar,System.Int32,System.Int32,System.Int32)">
@brief Draws one or more polygonal curves
@see cv::polylines

</member>
        <member name="M:cvFillPoly(System.Void*,CvPoint**,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,CvScalar,System.Int32,System.Int32)">
@brief Fills an area bounded by one or more arbitrary polygons
@see cv::fillPoly

</member>
        <member name="M:cvFillConvexPoly(System.Void*,CvPoint!System.Runtime.CompilerServices.IsConst*,System.Int32,CvScalar,System.Int32,System.Int32)">
@brief Fills convex or monotonous polygon.
@see cv::fillConvexPoly

</member>
        <member name="M:cvEllipse(System.Void*,CvPoint,CvSize,System.Double,System.Double,System.Double,CvScalar,System.Int32,System.Int32,System.Int32)">
@brief Draws ellipse outline, filled ellipse, elliptic arc or filled elliptic sector

   depending on _thickness_, _start_angle_ and _end_angle_ parameters. The resultant figure
   is rotated by _angle_. All the angles are in degrees
@see cv::ellipse

</member>
        <member name="M:cvCircle(System.Void*,CvPoint,System.Int32,CvScalar,System.Int32,System.Int32,System.Int32)">
@brief Draws a circle with specified center and radius.

   Thickness works in the same way as with cvRectangle
@see cv::circle

</member>
        <member name="M:cvRectangleR(System.Void*,CvRect,CvScalar,System.Int32,System.Int32,System.Int32)">
@brief Draws a rectangle specified by a CvRect structure
@see cv::rectangle

</member>
        <member name="M:cvLine(System.Void*,CvPoint,CvPoint,CvScalar,System.Int32,System.Int32,System.Int32)">
@brief Draws 4-connected, 8-connected or antialiased line segment connecting two points
@see cv::line

</member>
        <member name="M:cvFitLine(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,System.Double,System.Double,System.Single*)">
@brief Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)
@see cv::fitLine

</member>
        <member name="M:cvHoughCircles(System.Void*,System.Void*,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
@brief Finds circles in the image
@see cv::HoughCircles

</member>
        <member name="M:cvHoughLines2(System.Void*,System.Void*,System.Int32,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double,System.Double)">
@brief Finds lines on binary image using one of several methods.

   line_storage is either memory storage or 1 x _max number of lines_ CvMat, its
   number of columns is changed by the function.
   method is one of CV_HOUGH_*;
   rho, theta and threshold are used for each of those methods;
   param1 ~ line length, param2 ~ line gap - for probabilistic,
   param1 ~ srn, param2 ~ stn - for multi-scale
@see cv::HoughLines

</member>
        <member name="M:cvGoodFeaturesToTrack(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void*,CvPoint2D32f*,System.Int32*,System.Double,System.Double,System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Double)">
@brief Finds a sparse set of points within the selected region
   that seem to be easy to track
@see cv::goodFeaturesToTrack

</member>
        <member name="M:cvFindCornerSubPix(System.Void!System.Runtime.CompilerServices.IsConst*,CvPoint2D32f*,System.Int32,CvSize,CvSize,CvTermCriteria)">
@brief Adjust corner position using some sort of gradient search
@see cv::cornerSubPix

</member>
        <member name="M:cvCornerHarris(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Int32,System.Double)">
@brief Harris corner detector:

   Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel
@see cv::cornerHarris

</member>
        <member name="M:cvCornerMinEigenVal(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Int32)">
@brief Calculates minimal eigenvalue for 2x2 gradient covariation matrix at
   every image pixel
@see cv::cornerMinEigenVal

</member>
        <member name="M:cvCornerEigenValsAndVecs(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Int32)">
@brief Calculates eigen values and vectors of 2x2
   gradient covariation matrix at every image pixel
@see cv::cornerEigenValsAndVecs

</member>
        <member name="M:cvPreCornerDetect(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
@brief Calculates constraint image for corner detection

   Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy.
   Applying threshold to the result gives coordinates of corners
@see cv::preCornerDetect

</member>
        <member name="M:cvCanny(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Double,System.Double,System.Int32)">
@brief Runs canny edge detector
@see cv::Canny

</member>
        <member name="M:cvFloodFill(System.Void*,CvPoint,CvScalar,CvScalar,CvScalar,CvConnectedComp*,System.Int32,System.Void*)">
@brief Fills the connected component until the color difference gets large enough
@see cv::floodFill

</member>
        <member name="M:cvAdaptiveThreshold(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Double,System.Int32,System.Int32,System.Int32,System.Double)">
@brief Applies adaptive threshold to grayscale image.

   The two parameters for methods CV_ADAPTIVE_THRESH_MEAN_C and
   CV_ADAPTIVE_THRESH_GAUSSIAN_C are:
   neighborhood size (3, 5, 7 etc.),
   and a constant subtracted from mean (...,-3,-2,-1,0,1,2,3,...)
@see cv::adaptiveThreshold

</member>
        <member name="M:cvThreshold(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Double,System.Double,System.Int32)">
@brief Applies fixed-level threshold to grayscale image.

   This is a basic operation applied before retrieving contours
@see cv::threshold

</member>
        <member name="M:cvDistTransform(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Int32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
@brief Applies distance transform to binary image
@see cv::distanceTransform

</member>
        <member name="M:cvEqualizeHist(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
@brief equalizes histogram of 8-bit single-channel image
@see cv::equalizeHist

</member>
        <member name="M:cvCalcProbDensity(CvHistogram!System.Runtime.CompilerServices.IsConst*,CvHistogram!System.Runtime.CompilerServices.IsConst*,CvHistogram*,System.Double)">
@brief Divides one histogram by another.

The function calculates the object probability density from two histograms as:

\f[\texttt{disthist} (I)= \forkthree{0}{if \(\texttt{hist1}(I)=0\)}{\texttt{scale}}{if \(\texttt{hist1}(I) \ne 0\) and \(\texttt{hist2}(I) &gt; \texttt{hist1}(I)\)}{\frac{\texttt{hist2}(I) \cdot \texttt{scale}}{\texttt{hist1}(I)}}{if \(\texttt{hist1}(I) \ne 0\) and \(\texttt{hist2}(I) \le \texttt{hist1}(I)\)}\f]

@param hist1 First histogram (the divisor).
@param hist2 Second histogram.
@param dst_hist Destination histogram.
@param scale Scale factor for the destination histogram.

</member>
        <member name="M:cvCalcArrBackProjectPatch(System.Void**,System.Void*,CvSize,CvHistogram*,System.Int32,System.Double)">
@brief Locates a template within an image by using a histogram comparison.

The function calculates the back projection by comparing histograms of the source image patches with
the given histogram. The function is similar to matchTemplate, but instead of comparing the raster
patch with all its possible positions within the search window, the function CalcBackProjectPatch
compares histograms. See the algorithm diagram below:

![image](pics/backprojectpatch.png)

@param image Source images (though, you may pass CvMat\*\* as well).
@param dst Destination image.
@param range
@param hist Histogram.
@param method Comparison method passed to cvCompareHist (see the function description).
@param factor Normalization factor for histograms that affects the normalization scale of the
destination image. Pass 1 if not sure.

@see cvCalcBackProjectPatch

</member>
        <member name="M:cvCalcArrBackProject(System.Void**,System.Void*,CvHistogram!System.Runtime.CompilerServices.IsConst*)">
@brief Calculates back project
@see cvCalcBackProject, cv::calcBackProject

</member>
        <member name="M:cvCalcHist(_IplImage**,CvHistogram*,System.Int32,System.Void!System.Runtime.CompilerServices.IsConst*)">
@overload 
</member>
        <member name="M:cvCalcArrHist(System.Void**,CvHistogram*,System.Int32,System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Calculates array histogram
@see cv::calcHist

</member>
        <member name="M:cvCalcBayesianProb(CvHistogram**,System.Int32,CvHistogram**)">
@brief Calculates bayesian probabilistic histograms
   (each or src and dst is an array of _number_ histograms 
</member>
        <member name="M:cvCopyHist(CvHistogram!System.Runtime.CompilerServices.IsConst*,CvHistogram**)">
@brief Copies a histogram.

The function makes a copy of the histogram. If the second histogram pointer \*dst is NULL, a new
histogram of the same size as src is created. Otherwise, both histograms must have equal types and
sizes. Then the function copies the bin values of the source histogram to the destination histogram
and sets the same bin value ranges as in src.

@param src Source histogram.
@param dst Pointer to the destination histogram.

</member>
        <member name="M:cvCompareHist(CvHistogram!System.Runtime.CompilerServices.IsConst*,CvHistogram!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Compares two histogram 
</member>
        <member name="M:cvThreshHist(CvHistogram*,System.Double)">
@brief Thresholds the histogram.

The function clears histogram bins that are below the specified threshold.

@param hist Pointer to the histogram.
@param threshold Threshold level.

</member>
        <member name="M:cvNormalizeHist(CvHistogram*,System.Double)">
@brief Normalizes the histogram.

The function normalizes the histogram bins by scaling them so that the sum of the bins becomes equal
to factor.

@param hist Pointer to the histogram.
@param factor Normalization factor.

</member>
        <member name="M:cvGetMinMaxHistValue(CvHistogram!System.Runtime.CompilerServices.IsConst*,System.Single*,System.Single*,System.Int32*,System.Int32*)">
@brief Finds the minimum and maximum histogram bins.

The function finds the minimum and maximum histogram bins and their positions. All of output
arguments are optional. Among several extremas with the same value the ones with the minimum index
(in the lexicographical order) are returned. In case of several maximums or minimums, the earliest
in the lexicographical order (extrema locations) is returned.

@param hist Histogram.
@param min_value Pointer to the minimum value of the histogram.
@param max_value Pointer to the maximum value of the histogram.
@param min_idx Pointer to the array of coordinates for the minimum.
@param max_idx Pointer to the array of coordinates for the maximum.

</member>
        <member name="M:cvClearHist(CvHistogram*)">
@brief Clears the histogram.

The function sets all of the histogram bins to 0 in case of a dense histogram and removes all
histogram bins in case of a sparse array.

@param hist Histogram.

</member>
        <member name="M:cvReleaseHist(CvHistogram**)">
@brief Releases the histogram.

The function releases the histogram (header and the data). The pointer to the histogram is cleared
by the function. If \*hist pointer is already NULL, the function does nothing.

@param hist Double pointer to the released histogram.

</member>
        <member name="M:cvMakeHistHeaderForArray(System.Int32,System.Int32*,CvHistogram*,System.Single*,System.Single**,System.Int32)">
@brief Makes a histogram out of an array.

The function initializes the histogram, whose header and bins are allocated by the user.
cvReleaseHist does not need to be called afterwards. Only dense histograms can be initialized this
way. The function returns hist.

@param dims Number of the histogram dimensions.
@param sizes Array of the histogram dimension sizes.
@param hist Histogram header initialized by the function.
@param data Array used to store histogram bins.
@param ranges Histogram bin ranges. See cvCreateHist for details.
@param uniform Uniformity flag. See cvCreateHist for details.

</member>
        <member name="M:cvSetHistBinRanges(CvHistogram*,System.Single**,System.Int32)">
@brief Sets the bounds of the histogram bins.

This is a standalone function for setting bin ranges in the histogram. For a more detailed
description of the parameters ranges and uniform, see the :ocvCalcHist function that can initialize
the ranges as well. Ranges for the histogram bins must be set before the histogram is calculated or
the backproject of the histogram is calculated.

@param hist Histogram.
@param ranges Array of bin ranges arrays. See :ocvCreateHist for details.
@param uniform Uniformity flag. See :ocvCreateHist for details.

</member>
        <member name="M:cvPointPolygonTest(System.Void!System.Runtime.CompilerServices.IsConst*,CvPoint2D32f,System.Int32)">
@brief Checks whether the point is inside polygon, outside, on an edge (at a vertex).

   Returns positive, negative or zero value, correspondingly.
   Optionally, measures a signed distance between
   the point and the nearest polygon edge (measure_dist=1)
@see cv::pointPolygonTest

</member>
        <member name="M:cvPointSeqFromMat(System.Int32,System.Void!System.Runtime.CompilerServices.IsConst*,CvContour*,CvSeqBlock*)">
@brief Initializes sequence header for a matrix (column or row vector) of points

   a wrapper for cvMakeSeqHeaderForArray (it does not initialize bounding rectangle!!!) 
</member>
        <member name="M:cvBoxPoints(CvBox2D,CvPoint2D32f*)">
@brief Finds coordinates of the box vertices 
</member>
        <member name="M:cvMaxRect(CvRect!System.Runtime.CompilerServices.IsConst*,CvRect!System.Runtime.CompilerServices.IsConst*)">
@brief Finds minimum rectangle containing two given rectangles 
</member>
        <member name="M:cvFitEllipse2(System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Fits ellipse into a set of 2d points
@see cv::fitEllipse

</member>
        <member name="M:cvConvexityDefects(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,CvMemStorage*)">
@brief Finds convexity defects for the contour
@see cv::convexityDefects

</member>
        <member name="M:cvCheckContourConvexity(System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Checks whether the contour is convex or not (returns 1 if convex, 0 if not)
@see cv::isContourConvex

</member>
        <member name="M:cvConvexHull2(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Int32)">
@brief Calculates exact convex hull of 2d point set
@see cv::convexHull

</member>
        <member name="M:cvMatchShapes(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)">
@brief Compares two contours by matching their moments
@see cv::matchShapes

</member>
        <member name="M:cvMinEnclosingCircle(System.Void!System.Runtime.CompilerServices.IsConst*,CvPoint2D32f*,System.Single*)">
@brief Finds minimum enclosing circle for a set of points
@see cv::minEnclosingCircle

</member>
        <member name="M:cvMinAreaRect2(System.Void!System.Runtime.CompilerServices.IsConst*,CvMemStorage*)">
@brief Finds minimum area rotated rectangle bounding a set of points
@see cv::minAreaRect

</member>
        <member name="M:cvContourArea(System.Void!System.Runtime.CompilerServices.IsConst*,CvSlice,System.Int32)">
@brief Calculates area of a contour or contour segment
@see cv::contourArea

</member>
        <member name="M:cvBoundingRect(System.Void*,System.Int32)">
@brief Calculates contour bounding rectangle (update=1) or
   just retrieves pre-calculated rectangle (update=0)
@see cv::boundingRect

</member>
        <member name="M:cvContourPerimeter(System.Void!System.Runtime.CompilerServices.IsConst*)">
same as cvArcLength for closed contour

</member>
        <member name="M:cvArcLength(System.Void!System.Runtime.CompilerServices.IsConst*,CvSlice,System.Int32)">
@brief Calculates perimeter of a contour or length of a part of contour
@see cv::arcLength

</member>
        <member name="M:cvApproxPoly(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,CvMemStorage*,System.Int32,System.Double,System.Int32)">
@brief Approximates a single polygonal curve (contour) or
   a tree of polygonal curves (contours)
@see cv::approxPolyDP

</member>
        <member name="M:cvReadChainPoint(CvChainPtReader*)">
@brief Retrieves the next chain point
@see cvApproxChains

</member>
        <member name="M:cvStartReadChainPoints(CvChain*,CvChainPtReader*)">
@brief Initializes Freeman chain reader.

   The reader is used to iteratively get coordinates of all the chain points.
   If the Freeman codes should be read as is, a simple sequence reader should be used
@see cvApproxChains

</member>
        <member name="M:cvApproxChains(CvSeq*,CvMemStorage*,System.Int32,System.Double,System.Int32,System.Int32)">
@brief Approximates Freeman chain(s) with a polygonal curve.

This is a standalone contour approximation routine, not represented in the new interface. When
cvFindContours retrieves contours as Freeman chains, it calls the function to get approximated
contours, represented as polygons.

@param src_seq Pointer to the approximated Freeman chain that can refer to other chains.
@param storage Storage location for the resulting polylines.
@param method Approximation method (see the description of the function :ocvFindContours ).
@param parameter Method parameter (not used now).
@param minimal_perimeter Approximates only those contours whose perimeters are not less than
minimal_perimeter . Other chains are removed from the resulting structure.
@param recursive Recursion flag. If it is non-zero, the function approximates all chains that can
be obtained from chain by using the h_next or v_next links. Otherwise, the single input chain is
approximated.
@see cvStartReadChainPoints, cvReadChainPoint

</member>
        <member name="M:cvEndFindContours(_CvContourScanner**)">
@brief Releases contour scanner and returns pointer to the first outer contour
@see cvFindContours

</member>
        <member name="M:cvSubstituteContour(_CvContourScanner*,CvSeq*)">
@brief Substitutes the last retrieved contour with the new one

   (if the substitutor is null, the last retrieved contour is removed from the tree)
@see cvFindContours

</member>
        <member name="M:cvFindNextContour(_CvContourScanner*)">
@brief Retrieves next contour
@see cvFindContours

</member>
        <member name="M:cvStartFindContours(System.Void*,CvMemStorage*,System.Int32,System.Int32,System.Int32,CvPoint)">
@brief Initializes contour retrieving process.

   Calls cvStartFindContours.
   Calls cvFindNextContour until null pointer is returned
   or some other condition becomes true.
   Calls cvEndFindContours at the end.
@see cvFindContours

</member>
        <member name="M:cvFindContours(System.Void*,CvMemStorage*,CvSeq**,System.Int32,System.Int32,System.Int32,CvPoint)">
@brief Retrieves outer and optionally inner boundaries of white (non-zero) connected
   components in the black (zero) background
@see cv::findContours, cvStartFindContours, cvFindNextContour, cvSubstituteContour, cvEndFindContours

</member>
        <member name="M:cvCalcEMD2(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,=FUNC:System.Single(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Void*),System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Single*,System.Void*)">
@brief Computes earth mover distance between
   two weighted point sets (called signatures)
@see cv::EMD

</member>
        <member name="M:cvMatchTemplate(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
@brief Measures similarity between template and overlapped windows in the source image
   and fills the resultant image with the measurements
@see cv::matchTemplate

</member>
        <member name="M:cvSampleLine(System.Void!System.Runtime.CompilerServices.IsConst*,CvPoint,CvPoint,System.Void*,System.Int32)">
@brief Fetches pixels that belong to the specified line segment and stores them to the buffer.

   Returns the number of retrieved points.
@see cv::LineSegmentDetector

</member>
        <member name="M:cvGetHuMoments(CvMoments*,CvHuMoments*)">
@brief Calculates 7 Hu's invariants from precalculated spatial and central moments
@see cv::HuMoments

</member>
        <member name="M:cvGetNormalizedCentralMoment(CvMoments*,System.Int32,System.Int32)">
@brief Retrieve normalized central moments 
</member>
        <member name="M:cvGetCentralMoment(CvMoments*,System.Int32,System.Int32)">
@brief Retrieve central moments 
</member>
        <member name="M:cvGetSpatialMoment(CvMoments*,System.Int32,System.Int32)">
@brief Retrieve spatial moments 
</member>
        <member name="M:cvMoments(System.Void!System.Runtime.CompilerServices.IsConst*,CvMoments*,System.Int32)">
@brief Calculates all spatial and central moments up to the 3rd order
@see cv::moments

</member>
        <member name="M:cvMorphologyEx(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void*,_IplConvKernel*,System.Int32,System.Int32)">
@brief Performs complex morphological transformation
@see cv::morphologyEx

</member>
        <member name="M:cvDilate(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,_IplConvKernel*,System.Int32)">
@brief dilates input image (applies maximum filter) one or more times.

   If element pointer is NULL, 3x3 rectangular element is used
@see cv::dilate

</member>
        <member name="M:cvErode(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,_IplConvKernel*,System.Int32)">
@brief erodes input image (applies minimum filter) one or more times.
   If element pointer is NULL, 3x3 rectangular element is used
@see cv::erode

</member>
        <member name="M:cvReleaseStructuringElement(_IplConvKernel**)">
@brief releases structuring element
@see cvCreateStructuringElementEx

</member>
        <member name="M:cvUndistortPoints(CvMat!System.Runtime.CompilerServices.IsConst*,CvMat*,CvMat!System.Runtime.CompilerServices.IsConst*,CvMat!System.Runtime.CompilerServices.IsConst*,CvMat!System.Runtime.CompilerServices.IsConst*,CvMat!System.Runtime.CompilerServices.IsConst*)">
@brief Computes the original (undistorted) feature coordinates
   from the observed (distorted) coordinates
@see cv::undistortPoints

</member>
        <member name="M:cvInitUndistortRectifyMap(CvMat!System.Runtime.CompilerServices.IsConst*,CvMat!System.Runtime.CompilerServices.IsConst*,CvMat!System.Runtime.CompilerServices.IsConst*,CvMat!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void*)">
@brief Computes undistortion+rectification map for a head of stereo camera
@see cv::initUndistortRectifyMap

</member>
        <member name="M:cvInitUndistortMap(CvMat!System.Runtime.CompilerServices.IsConst*,CvMat!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void*)">
@brief Computes transformation map from intrinsic camera parameters
   that can used by cvRemap

</member>
        <member name="M:cvUndistort2(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvMat!System.Runtime.CompilerServices.IsConst*,CvMat!System.Runtime.CompilerServices.IsConst*,CvMat!System.Runtime.CompilerServices.IsConst*)">
@brief Transforms the input image to compensate lens distortion
@see cv::undistort

</member>
        <member name="M:cvLinearPolar(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvPoint2D32f,System.Double,System.Int32)">
Performs forward or inverse linear-polar image transform
@see cv::linearPolar

</member>
        <member name="M:cvLogPolar(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvPoint2D32f,System.Double,System.Int32)">
@brief Performs forward or inverse log-polar image transform
@see cv::logPolar

</member>
        <member name="M:cvRemap(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,CvScalar)">
@brief Performs generic geometric transformation using the specified coordinate maps
@see cv::remap

</member>
        <member name="M:cvGetPerspectiveTransform(CvPoint2D32f!System.Runtime.CompilerServices.IsConst*,CvPoint2D32f!System.Runtime.CompilerServices.IsConst*,CvMat*)">
@brief Computes perspective transform matrix for mapping src[i] to dst[i] (i=0,1,2,3)
@see cv::getPerspectiveTransform

</member>
        <member name="M:cvWarpPerspective(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvMat!System.Runtime.CompilerServices.IsConst*,System.Int32,CvScalar)">
@brief Warps image with perspective (projective) transform
@see cv::warpPerspective

</member>
        <member name="M:cv2DRotationMatrix(CvPoint2D32f,System.Double,System.Double,CvMat*)">
@brief Computes rotation_matrix matrix
@see cv::getRotationMatrix2D

</member>
        <member name="M:cvGetAffineTransform(CvPoint2D32f!System.Runtime.CompilerServices.IsConst*,CvPoint2D32f!System.Runtime.CompilerServices.IsConst*,CvMat*)">
@brief Computes affine transform matrix for mapping src[i] to dst[i] (i=0,1,2)
@see cv::getAffineTransform

</member>
        <member name="M:cvWarpAffine(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvMat!System.Runtime.CompilerServices.IsConst*,System.Int32,CvScalar)">
@brief Warps image with affine transform
@note ::cvGetQuadrangleSubPix is similar to ::cvWarpAffine, but the outliers are extrapolated using
replication border mode.
@see cv::warpAffine

</member>
        <member name="M:cvResize(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
@brief Resizes image (input array is resized to fit the destination array)
@see cv::resize

</member>
        <member name="M:cvCvtColor(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
@brief Converts input array pixels from one color space to another
@see cv::cvtColor

</member>
        <member name="M:cvLaplace(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
@brief Calculates the image Laplacian: (d2/dx + d2/dy)I
@see cv::Laplacian

</member>
        <member name="M:cvSobel(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Int32,System.Int32)">
@brief Calculates an image derivative using generalized Sobel

   (aperture_size = 1,3,5,7) or Scharr (aperture_size = -1) operator.
   Scharr can be used only for the first dx or dy derivative
@see cv::Sobel

</member>
        <member name="M:cvWatershed(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
@brief Segments image using seed "markers"
@see cv::watershed

</member>
        <member name="M:cvPyrMeanShiftFiltering(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Double,System.Double,System.Int32,CvTermCriteria)">
@brief Filters image using meanshift algorithm
@see cv::pyrMeanShiftFiltering

</member>
        <member name="M:cvReleasePyramid(CvMat***,System.Int32)">
@brief Releases pyramid 
</member>
        <member name="M:cvCreatePyramid(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,CvSize!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Int32)">
@brief Builds pyramid for an image
@see buildPyramid

</member>
        <member name="M:cvPyrUp(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
@brief Up-samples image and smoothes the result with gaussian kernel.

   dst_width = src_width*2,
   dst_height = src_height*2
   @see cv::pyrUp

</member>
        <member name="M:cvPyrDown(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
@brief Smoothes the input image with gaussian kernel and then down-samples it.

   dst_width = floor(src_width/2)[+1],
   dst_height = floor(src_height/2)[+1]
   @see cv::pyrDown

</member>
        <member name="M:cvFilter2D(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvMat!System.Runtime.CompilerServices.IsConst*,CvPoint)">
@brief Convolves an image with the kernel.

@param src input image.
@param dst output image of the same size and the same number of channels as src.
@param kernel convolution kernel (or rather a correlation kernel), a single-channel floating point
matrix; if you want to apply different kernels to different channels, split the image into
separate color planes using split and process them individually.
@param anchor anchor of the kernel that indicates the relative position of a filtered point within
the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor
is at the kernel center.

@see cv::filter2D

</member>
        <member name="M:cvSmooth(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Int32,System.Int32,System.Double,System.Double)">
@brief Smooths the image in one of several ways.

@param src The source image
@param dst The destination image
@param smoothtype Type of the smoothing, see SmoothMethod_c
@param size1 The first parameter of the smoothing operation, the aperture width. Must be a
positive odd number (1, 3, 5, ...)
@param size2 The second parameter of the smoothing operation, the aperture height. Ignored by
CV_MEDIAN and CV_BILATERAL methods. In the case of simple scaled/non-scaled and Gaussian blur if
size2 is zero, it is set to size1. Otherwise it must be a positive odd number.
@param sigma1 In the case of a Gaussian parameter this parameter may specify Gaussian \f$\sigma\f$
(standard deviation). If it is zero, it is calculated from the kernel size:
\f[\sigma  = 0.3 (n/2 - 1) + 0.8  \quad   \text{where}   \quad  n= \begin{array}{l l} \mbox{\texttt{size1} for horizontal kernel} \\ \mbox{\texttt{size2} for vertical kernel} \end{array}\f]
Using standard sigma for small kernels ( \f$3\times 3\f$ to \f$7\times 7\f$ ) gives better speed. If
sigma1 is not zero, while size1 and size2 are zeros, the kernel size is calculated from the
sigma (to provide accurate enough operation).
@param sigma2 additional parameter for bilateral filtering

@see cv::GaussianBlur, cv::blur, cv::medianBlur, cv::bilateralFilter.

</member>
        <member name="M:cvCopyMakeBorder(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvPoint,System.Int32,CvScalar)">
Copies source 2D array inside of the larger destination array and
   makes a border of the specified type (IPL_BORDER_*) around the copied area. 
</member>
        <member name="M:cvRunningAvg(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Double,System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha
@see cv::accumulateWeighted

</member>
        <member name="M:cvMultiplyAcc(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Adds a product of two images to accumulator
@see cv::accumulateProduct

</member>
        <member name="M:cvSquareAcc(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Adds squared image to accumulator
@see cv::accumulateSquare

</member>
        <member name="M:cvAcc(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
@addtogroup imgproc_c
@{

@brief Adds image to accumulator
@see cv::accumulate

</member>
        <member name="T:CvConvexityDefect">
Convexity defect 
</member>
        <member name="T:ShapeMatchModes">
@brief Shape matching methods

\f$A\f$ denotes object1,\f$B\f$ denotes object2

\f$\begin{array}{l} m^A_i =  \mathrm{sign} (h^A_i)  \cdot \log{h^A_i} \\ m^B_i =  \mathrm{sign} (h^B_i)  \cdot \log{h^B_i} \end{array}\f$

and \f$h^A_i, h^B_i\f$ are the Hu moments of \f$A\f$ and \f$B\f$ , respectively.

</member>
        <member name="T:CvChainPtReader">
Freeman chain reader state 
</member>
        <member name="T:CvHuMoments">
Hu invariants 
</member>
        <member name="T:CvMoments">
Spatial and central moments 
</member>
        <member name="T:MorphShapes_c">
Shapes of a structuring element for morphological operations
@see cv::MorphShapes, cv::getStructuringElement

</member>
        <member name="T:SmoothMethod_c">
Image smooth methods 
</member>
        <member name="F:CV_BILATERAL">
bilateral filter with a \f$\texttt{size1}\times\texttt{size1}\f$ square aperture, color
    sigma= sigma1 and spatial sigma= sigma2. If size1=0, the aperture square side is set to
    cvRound(sigma2\*1.5)\*2+1. See cv::bilateralFilter 
</member>
        <member name="F:CV_MEDIAN">
median filter with a \f$\texttt{size1}\times\texttt{size1}\f$ square aperture 
</member>
        <member name="F:CV_GAUSSIAN">
linear convolution with a \f$\texttt{size1}\times\texttt{size2}\f$ Gaussian kernel 
</member>
        <member name="F:CV_BLUR">
linear convolution with \f$\texttt{size1}\times\texttt{size2}\f$ box kernel (all
    1's) with subsequent scaling by \f$1/(\texttt{size1}\cdot\texttt{size2})\f$ 
</member>
        <member name="F:CV_BLUR_NO_SCALE">
linear convolution with \f$\texttt{size1}\times\texttt{size2}\f$ box kernel (all 1's). If
    you want to smooth different pixels with different-size box kernels, you can use the integral
    image that is computed using integral 
</member>
        <member name="T:CvConnectedComp">
@addtogroup imgproc_c
  @{

Connected component structure 
</member>
        <member name="M:cv.LineIterator.pos">
@brief returns coordinates of the current pixel

</member>
        <member name="M:cv.LineIterator.op_Increment(System.Int32)">
@brief postfix increment operator (it++). shifts iterator to the next pixel

</member>
        <member name="M:cv.LineIterator.op_Increment">
@brief prefix increment operator (++it). shifts iterator to the next pixel

</member>
        <member name="M:cv.LineIterator.op_PointerDereference">
@brief returns pointer to the current pixel

</member>
        <member name="M:cv.LineIterator.#ctor(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,cv.Point_&lt;System.Int32&gt;,System.Int32,System.Boolean)">
@brief intializes the iterator

    creates iterators for the line connecting pt1 and pt2
    the line will be clipped on the image boundaries
    the line is 8-connected or 4-connected
    If leftToRight=true, then the iteration is always done
    from the left-most point to the right most,
    not to depend on the ordering of pt1 and pt2 parameters

</member>
        <member name="M:cv.putText(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,System.Int32,System.Double,cv.Scalar_&lt;System.Double&gt;,System.Int32,System.Int32,System.Boolean)">
@brief Draws a text string.

The function putText renders the specified text string in the image. Symbols that cannot be rendered
using the specified font are replaced by question marks. See getTextSize for a text rendering code
example.

@param img Image.
@param text Text string to be drawn.
@param org Bottom-left corner of the text string in the image.
@param fontFace Font type, see cv::HersheyFonts.
@param fontScale Font scale factor that is multiplied by the font-specific base size.
@param color Text color.
@param thickness Thickness of the lines used to draw a text.
@param lineType Line type. See the line for details.
@param bottomLeftOrigin When true, the image data origin is at the bottom-left corner. Otherwise,
it is at the top-left corner.

</member>
        <member name="M:cv.ellipse2Poly(cv.Point_&lt;System.Int32&gt;,cv.Size_&lt;System.Int32&gt;,System.Int32,System.Int32,System.Int32,System.Int32,std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Approximates an elliptic arc with a polyline.

The function ellipse2Poly computes the vertices of a polyline that approximates the specified
elliptic arc. It is used by cv::ellipse.

@param center Center of the arc.
@param axes Half of the size of the ellipse main axes. See the ellipse for details.
@param angle Rotation angle of the ellipse in degrees. See the ellipse for details.
@param arcStart Starting angle of the elliptic arc in degrees.
@param arcEnd Ending angle of the elliptic arc in degrees.
@param delta Angle between the subsequent polyline vertices. It defines the approximation
accuracy.
@param pts Output vector of polyline vertices.

</member>
        <member name="M:cv.clipLine(cv.Rect_&lt;System.Int32&gt;,cv.Point_&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
@param imgRect Image rectangle.
@param pt1 First line point.
@param pt2 Second line point.

</member>
        <member name="M:cv.clipLine(cv.Size_&lt;System.Int32&gt;,cv.Point_&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Clips the line against the image rectangle.

The functions clipLine calculate a part of the line segment that is entirely within the specified
rectangle. They return false if the line segment is completely outside the rectangle. Otherwise,
they return true .
@param imgSize Image size. The image rectangle is Rect(0, 0, imgSize.width, imgSize.height) .
@param pt1 First line point.
@param pt2 Second line point.

</member>
        <member name="M:cv.polylines(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
@brief Draws several polygonal curves.

@param img Image.
@param pts Array of polygonal curves.
@param isClosed Flag indicating whether the drawn polylines are closed or not. If they are closed,
the function draws a line from the last vertex of each curve to its first vertex.
@param color Polyline color.
@param thickness Thickness of the polyline edges.
@param lineType Type of the line segments. See the line description.
@param shift Number of fractional bits in the vertex coordinates.

The function polylines draws one or more polygonal curves.

</member>
        <member name="M:cv.polylines(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Boolean,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
@overload 
</member>
        <member name="M:cv.fillPoly(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,cv.Point_&lt;System.Int32&gt;)">
@brief Fills the area bounded by one or more polygons.

The function fillPoly fills an area bounded by several polygonal contours. The function can fill
complex areas, for example, areas with holes, contours with self-intersections (some of their
parts), and so forth.

@param img Image.
@param pts Array of polygons where each polygon is represented as an array of points.
@param color Polygon color.
@param lineType Type of the polygon boundaries. See the line description.
@param shift Number of fractional bits in the vertex coordinates.
@param offset Optional offset of all points of the contours.

</member>
        <member name="M:cv.fillPoly(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst**,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,cv.Point_&lt;System.Int32&gt;)">
@overload 
</member>
        <member name="M:cv.fillConvexPoly(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief Fills a convex polygon.

The function fillConvexPoly draws a filled convex polygon. This function is much faster than the
function cv::fillPoly . It can fill not only convex polygons but any monotonic polygon without
self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line)
twice at the most (though, its top-most and/or the bottom edge could be horizontal).

@param img Image.
@param points Polygon vertices.
@param color Polygon color.
@param lineType Type of the polygon boundaries. See the line description.
@param shift Number of fractional bits in the vertex coordinates.

</member>
        <member name="M:cv.fillConvexPoly(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,System.Int32,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@overload 
</member>
        <member name="M:cv.ellipse(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.RotatedRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@overload
@param img Image.
@param box Alternative ellipse representation via RotatedRect. This means that the function draws
an ellipse inscribed in the rotated rectangle.
@param color Ellipse color.
@param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
a filled ellipse sector is to be drawn.
@param lineType Type of the ellipse boundary. See the line description.

</member>
        <member name="M:cv.ellipse(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,cv.Size_&lt;System.Int32&gt;,System.Double,System.Double,System.Double,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
@brief Draws a simple or thick elliptic arc or fills an ellipse sector.

The functions ellipse with less parameters draw an ellipse outline, a filled ellipse, an elliptic
arc, or a filled ellipse sector. A piecewise-linear curve is used to approximate the elliptic arc
boundary. If you need more control of the ellipse rendering, you can retrieve the curve using
ellipse2Poly and then render it with polylines or fill it with fillPoly . If you use the first
variant of the function and want to draw the whole ellipse, not an arc, pass startAngle=0 and
endAngle=360 . The figure below explains the meaning of the parameters.

![Parameters of Elliptic Arc](pics/ellipse.png)

@param img Image.
@param center Center of the ellipse.
@param axes Half of the size of the ellipse main axes.
@param angle Ellipse rotation angle in degrees.
@param startAngle Starting angle of the elliptic arc in degrees.
@param endAngle Ending angle of the elliptic arc in degrees.
@param color Ellipse color.
@param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
a filled ellipse sector is to be drawn.
@param lineType Type of the ellipse boundary. See the line description.
@param shift Number of fractional bits in the coordinates of the center and values of axes.

</member>
        <member name="M:cv.circle(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,System.Int32,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
@brief Draws a circle.

The function circle draws a simple or filled circle with a given center and radius.
@param img Image where the circle is drawn.
@param center Center of the circle.
@param radius Radius of the circle.
@param color Circle color.
@param thickness Thickness of the circle outline, if positive. Negative thickness means that a
filled circle is to be drawn.
@param lineType Type of the circle boundary. See the line description.
@param shift Number of fractional bits in the coordinates of the center and in the radius value.

</member>
        <member name="M:cv.rectangle(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Rect_&lt;System.Int32&gt;,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
@overload

use `rec` parameter as alternative specification of the drawn rectangle: `r.tl() and
r.br()-Point(1,1)` are opposite corners

</member>
        <member name="M:cv.rectangle(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,cv.Point_&lt;System.Int32&gt;,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
@brief Draws a simple, thick, or filled up-right rectangle.

The function rectangle draws a rectangle outline or a filled rectangle whose two opposite corners
are pt1 and pt2.

@param img Image.
@param pt1 Vertex of the rectangle.
@param pt2 Vertex of the rectangle opposite to pt1 .
@param color Rectangle color or brightness (grayscale image).
@param thickness Thickness of lines that make up the rectangle. Negative values, like CV_FILLED ,
mean that the function has to draw a filled rectangle.
@param lineType Type of the line. See the line description.
@param shift Number of fractional bits in the point coordinates.

</member>
        <member name="M:cv.arrowedLine(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,cv.Point_&lt;System.Int32&gt;,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32,System.Double)">
@brief Draws a arrow segment pointing from the first point to the second one.

The function arrowedLine draws an arrow between pt1 and pt2 points in the image. See also cv::line.

@param img Image.
@param pt1 The point the arrow starts from.
@param pt2 The point the arrow points to.
@param color Line color.
@param thickness Line thickness.
@param line_type Type of the line, see cv::LineTypes
@param shift Number of fractional bits in the point coordinates.
@param tipLength The length of the arrow tip in relation to the arrow length

</member>
        <member name="M:cv.line(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,cv.Point_&lt;System.Int32&gt;,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
@brief Draws a line segment connecting two points.

The function line draws the line segment between pt1 and pt2 points in the image. The line is
clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected
or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased
lines are drawn using Gaussian filtering.

@param img Image.
@param pt1 First point of the line segment.
@param pt2 Second point of the line segment.
@param color Line color.
@param thickness Line thickness.
@param lineType Type of the line, see cv::LineTypes.
@param shift Number of fractional bits in the point coordinates.

</member>
        <member name="M:cv.applyColorMap(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Applies a GNU Octave/MATLAB equivalent colormap on a given image.

@param src The source image, grayscale or colored does not matter.
@param dst The result is the colormapped source image. Note: Mat::create is called on dst.
@param colormap The colormap to apply, see cv::ColormapTypes

</member>
        <member name="M:cv.pointPolygonTest(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Single&gt;,System.Boolean)">
@brief Performs a point-in-contour test.

The function determines whether the point is inside a contour, outside, or lies on an edge (or
coincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge)
value, correspondingly. When measureDist=false , the return value is +1, -1, and 0, respectively.
Otherwise, the return value is a signed distance between the point and the nearest contour edge.

See below a sample output of the function where each image pixel is tested against the contour:

![sample output](pics/pointpolygon.png)

@param contour Input contour.
@param pt Point tested against the contour.
@param measureDist If true, the function estimates the signed distance from the point to the
nearest contour edge. Otherwise, the function only checks if the point is inside a contour or not.

</member>
        <member name="M:cv.convexityDefects(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Finds the convexity defects of a contour.

The figure below displays convexity defects of a hand contour:

![image](pics/defects.png)

@param contour Input contour.
@param convexhull Convex hull obtained using convexHull that should contain indices of the contour
points that make the hull.
@param convexityDefects The output vector of convexity defects. In C++ and the new Python/Java
interface each convexity defect is represented as 4-element integer vector (a.k.a. cv::Vec4i):
(start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices
in the original contour of the convexity defect beginning, end and the farthest point, and
fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the
farthest contour point and the hull. That is, to get the floating-point value of the depth will be
fixpt_depth/256.0.

</member>
        <member name="M:cv.matchShapes(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double)">
@brief Compares two shapes.

The function compares two shapes. All three implemented methods use the Hu invariants (see cv::HuMoments)

@param contour1 First contour or grayscale image.
@param contour2 Second contour or grayscale image.
@param method Comparison method, see ::ShapeMatchModes
@param parameter Method-specific parameter (not supported now).

</member>
        <member name="M:cv.boxPoints(cv.RotatedRect,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.

The function finds the four vertices of a rotated rectangle. This function is useful to draw the
rectangle. In C++, instead of using this function, you can directly use box.points() method. Please
visit the [tutorial on bounding
rectangle](http://docs.opencv.org/doc/tutorials/imgproc/shapedescriptors/bounding_rects_circles/bounding_rects_circles.html#bounding-rects-circles)
for more information.

@param box The input rotated rectangle. It may be the output of
@param points The output array of four vertices of rectangles.

</member>
        <member name="M:cv.boundingRect(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates the up-right bounding rectangle of a point set.

The function calculates and returns the minimal up-right bounding rectangle for the specified point set.

@param points Input 2D point set, stored in std::vector or Mat.

</member>
        <member name="M:cv.arcLength(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief Calculates a contour perimeter or a curve length.

The function computes a curve length or a closed contour perimeter.

@param curve Input vector of 2D points, stored in std::vector or Mat.
@param closed Flag indicating whether the curve is closed or not.

</member>
        <member name="M:cv.findContours(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,cv.Point_&lt;System.Int32&gt;)">
@overload 
</member>
        <member name="M:cv.findContours(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,cv.Point_&lt;System.Int32&gt;)">
@brief Finds contours in a binary image.

The function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contours
are a useful tool for shape analysis and object detection and recognition. See squares.c in the
OpenCV sample directory.

@note Source image is modified by this function. Also, the function does not take into account
1-pixel border of the image (it's filled with 0's and used for neighbor analysis in the algorithm),
therefore the contours touching the image border will be clipped.

@param image Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero
pixels remain 0's, so the image is treated as binary . You can use compare , inRange , threshold ,
adaptiveThreshold , Canny , and others to create a binary image out of a grayscale or color one.
The function modifies the image while extracting the contours. If mode equals to RETR_CCOMP
or RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).
@param contours Detected contours. Each contour is stored as a vector of points.
@param hierarchy Optional output vector, containing information about the image topology. It has
as many elements as the number of contours. For each i-th contour contours[i] , the elements
hierarchy[i][0] , hiearchy[i][1] , hiearchy[i][2] , and hiearchy[i][3] are set to 0-based indices
in contours of the next and previous contours at the same hierarchical level, the first child
contour and the parent contour, respectively. If for the contour i there are no next, previous,
parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.
@param mode Contour retrieval mode, see cv::RetrievalModes
@param method Contour approximation method, see cv::ContourApproximationModes
@param offset Optional offset by which every contour point is shifted. This is useful if the
contours are extracted from the image ROI and then they should be analyzed in the whole image
context.

</member>
        <member name="M:cv.connectedComponentsWithStats(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@overload
@param image the image to be labeled
@param labels destination labeled image
@param stats statistics output for each label, including the background label, see below for
available statistics. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
cv::ConnectedComponentsTypes
@param centroids floating point centroid (x,y) output for each label, including the background label
@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively
@param ltype output image label type. Currently CV_32S and CV_16U are supported.

</member>
        <member name="M:cv.connectedComponents(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief computes the connected components labeled image of boolean image

image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
represents the background label. ltype specifies the output label image type, an important
consideration based on the total number of labels or alternatively the total number of pixels in
the source image.

@param image the image to be labeled
@param labels destination labeled image
@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively
@param ltype output image label type. Currently CV_32S and CV_16U are supported.

</member>
        <member name="M:cv.matchTemplate(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Compares a template against overlapped image regions.

The function slides through image , compares the overlapped patches of size \f$w \times h\f$ against
templ using the specified method and stores the comparison results in result . Here are the formulae
for the available comparison methods ( \f$I\f$ denotes image, \f$T\f$ template, \f$R\f$ result ). The summation
is done over template and/or the image patch: \f$x' = 0...w-1, y' = 0...h-1\f$

After the function finishes the comparison, the best matches can be found as global minimums (when
TM_SQDIFF was used) or maximums (when TM_CCORR or TM_CCOEFF was used) using the
minMaxLoc function. In case of a color image, template summation in the numerator and each sum in
the denominator is done over all of the channels and separate mean values are used for each channel.
That is, the function can take a color template and a color image. The result will still be a
single-channel image, which is easier to analyze.

@param image Image where the search is running. It must be 8-bit or 32-bit floating-point.
@param templ Searched template. It must be not greater than the source image and have the same
data type.
@param result Map of comparison results. It must be single-channel 32-bit floating-point. If image
is \f$W \times H\f$ and templ is \f$w \times h\f$ , then result is \f$(W-w+1) \times (H-h+1)\f$ .
@param method Parameter specifying the comparison method, see cv::TemplateMatchModes
@param mask Mask of searched template. It must have the same datatype and size with templ. It is
not set by default.

</member>
        <member name="M:cv.HuMoments(cv.Moments!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload 
</member>
        <member name="M:cv.moments(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief Calculates all of the moments up to the third order of a polygon or rasterized shape.

The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The
results are returned in the structure cv::Moments.

@param array Raster image (single-channel, 8-bit or floating-point 2D array) or an array (
\f$1 \times N\f$ or \f$N \times 1\f$ ) of 2D points (Point or Point2f ).
@param binaryImage If it is true, all non-zero image pixels are treated as 1's. The parameter is
used for images only.
@returns moments.

@sa  contourArea, arcLength

</member>
        <member name="M:cv.cvtColor(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief Converts an image from one color space to another.

The function converts an input image from one color space to another. In case of a transformation
to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note
that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the
bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue
component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and
sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.

The conventional ranges for R, G, and B channel values are:
-   0 to 255 for CV_8U images
-   0 to 65535 for CV_16U images
-   0 to 1 for CV_32F images

In case of linear transformations, the range does not matter. But in case of a non-linear
transformation, an input RGB image should be normalized to the proper value range to get the correct
results, for example, for RGB \f$\rightarrow\f$ L\*u\*v\* transformation. For example, if you have a
32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will
have the 0..255 value range instead of 0..1 assumed by the function. So, before calling cvtColor ,
you need first to scale the image down:
@code
    img *= 1./255;
    cvtColor(img, img, COLOR_BGR2Luv);
@endcode
If you use cvtColor with 8-bit images, the conversion will have some information lost. For many
applications, this will not be noticeable but it is recommended to use 32-bit images in applications
that need the full range of colors or that convert an image before an operation and then convert
back.

If conversion adds the alpha channel, its value will set to the maximum of corresponding channel
range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.

@param src input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision
floating-point.
@param dst output image of the same size and depth as src.
@param code color space conversion code (see cv::ColorConversionCodes).
@param dstCn number of channels in the destination image; if the parameter is 0, the number of the
channels is derived automatically from src and code.

@see @ref imgproc_color_conversions

</member>
        <member name="M:cv.floodFill(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,cv.Scalar_&lt;System.Double&gt;,cv.Rect_&lt;System.Int32&gt;*,cv.Scalar_&lt;System.Double&gt;,cv.Scalar_&lt;System.Double&gt;,System.Int32)">
@example ffilldemo.cpp
  An example using the FloodFill technique

@overload

variant without `mask` parameter

</member>
        <member name="M:cv.distanceTransform(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
@overload
@param src 8-bit, single-channel (binary) source image.
@param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
single-channel image of the same size as src .
@param distanceType Type of distance, see cv::DistanceTypes
@param maskSize Size of the distance transform mask, see cv::DistanceTransformMasks. In case of the
DIST_L1 or DIST_C distance type, the parameter is forced to 3 because a \f$3\times 3\f$ mask gives
the same result as \f$5\times 5\f$ or any larger aperture.
@param dstType Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for
the first variant of the function and distanceType == DIST_L1.

</member>
        <member name="M:cv.distanceTransform(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
@example distrans.cpp
An example on using the distance transform

@brief Calculates the distance to the closest zero pixel for each pixel of the source image.

The functions distanceTransform calculate the approximate or precise distance from every binary
image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.

When maskSize == DIST_MASK_PRECISE and distanceType == DIST_L2 , the function runs the
algorithm described in @cite Felzenszwalb04 . This algorithm is parallelized with the TBB library.

In other cases, the algorithm @cite Borgefors86 is used. This means that for a pixel the function
finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical,
diagonal, or knight's move (the latest is available for a \f$5\times 5\f$ mask). The overall
distance is calculated as a sum of these basic distances. Since the distance function should be
symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all
the diagonal shifts must have the same cost (denoted as `b`), and all knight's moves must have the
same cost (denoted as `c`). For the cv::DIST_C and cv::DIST_L1 types, the distance is calculated
precisely, whereas for cv::DIST_L2 (Euclidean distance) the distance can be calculated only with a
relative error (a \f$5\times 5\f$ mask gives more accurate results). For `a`,`b`, and `c`, OpenCV
uses the values suggested in the original paper:
- DIST_L1: `a = 1, b = 2`
- DIST_L2:
    - `3 x 3`: `a=0.955, b=1.3693`
    - `5 x 5`: `a=1, b=1.4, c=2.1969`
- DIST_C: `a = 1, b = 1`

Typically, for a fast, coarse distance estimation DIST_L2, a \f$3\times 3\f$ mask is used. For a
more accurate distance estimation DIST_L2, a \f$5\times 5\f$ mask or the precise algorithm is used.
Note that both the precise and the approximate algorithms are linear on the number of pixels.

This variant of the function does not only compute the minimum distance for each pixel \f$(x, y)\f$
but also identifies the nearest connected component consisting of zero pixels
(labelType==DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==DIST_LABEL_PIXEL). Index of the
component/pixel is stored in `labels(x, y)`. When labelType==DIST_LABEL_CCOMP, the function
automatically finds connected components of zero pixels in the input image and marks them with
distinct labels. When labelType==DIST_LABEL_CCOMP, the function scans through the input image and
marks all the zero pixels with distinct labels.

In this mode, the complexity is still linear. That is, the function provides a very fast way to
compute the Voronoi diagram for a binary image. Currently, the second variant can use only the
approximate distance transform algorithm, i.e. maskSize=DIST_MASK_PRECISE is not supported
yet.

@param src 8-bit, single-channel (binary) source image.
@param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
single-channel image of the same size as src.
@param labels Output 2D array of labels (the discrete Voronoi diagram). It has the type
CV_32SC1 and the same size as src.
@param distanceType Type of distance, see cv::DistanceTypes
@param maskSize Size of the distance transform mask, see cv::DistanceTransformMasks.
DIST_MASK_PRECISE is not supported by this variant. In case of the DIST_L1 or DIST_C distance type,
the parameter is forced to 3 because a \f$3\times 3\f$ mask gives the same result as \f$5\times
5\f$ or any larger aperture.
@param labelType Type of the label array to build, see cv::DistanceTransformLabelTypes.

</member>
        <member name="M:cv.grabCut(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Rect_&lt;System.Int32&gt;,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@example grabcut.cpp
An example using the GrabCut algorithm

@brief Runs the GrabCut algorithm.

The function implements the [GrabCut image segmentation algorithm](http://en.wikipedia.org/wiki/GrabCut).

@param img Input 8-bit 3-channel image.
@param mask Input/output 8-bit single-channel mask. The mask is initialized by the function when
mode is set to GC_INIT_WITH_RECT. Its elements may have one of the cv::GrabCutClasses.
@param rect ROI containing a segmented object. The pixels outside of the ROI are marked as
"obvious background". The parameter is only used when mode==GC_INIT_WITH_RECT .
@param bgdModel Temporary array for the background model. Do not modify it while you are
processing the same image.
@param fgdModel Temporary arrays for the foreground model. Do not modify it while you are
processing the same image.
@param iterCount Number of iterations the algorithm should make before returning the result. Note
that the result can be refined with further calls with mode==GC_INIT_WITH_MASK or
mode==GC_EVAL .
@param mode Operation mode that could be one of the cv::GrabCutModes

</member>
        <member name="M:cv.watershed(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@example watershed.cpp
An example using the watershed algorithm

@brief Performs a marker-based image segmentation using the watershed algorithm.

The function implements one of the variants of watershed, non-parametric marker-based segmentation
algorithm, described in @cite Meyer92 .

Before passing the image to the function, you have to roughly outline the desired regions in the
image markers with positive (\&gt;0) indices. So, every region is represented as one or more connected
components with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary
mask using findContours and drawContours (see the watershed.cpp demo). The markers are "seeds" of
the future image regions. All the other pixels in markers , whose relation to the outlined regions
is not known and should be defined by the algorithm, should be set to 0's. In the function output,
each pixel in markers is set to a value of the "seed" components or to -1 at boundaries between the
regions.

@note Any two neighbor connected components are not necessarily separated by a watershed boundary
(-1's pixels); for example, they can touch each other in the initial marker image passed to the
function.

@param image Input 8-bit 3-channel image.
@param markers Input/output 32-bit single-channel image (map) of markers. It should have the same
size as image .

@sa findContours

@ingroup imgproc_misc

</member>
        <member name="M:cv.EMD(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes the "minimal work" distance between two weighted point configurations.

The function computes the earth mover distance and/or a lower boundary of the distance between the
two weighted point configurations. One of the applications described in @cite RubnerSept98,
@cite Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation
problem that is solved using some modification of a simplex algorithm, thus the complexity is
exponential in the worst case, though, on average it is much faster. In the case of a real metric
the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used
to determine roughly whether the two signatures are far enough so that they cannot relate to the
same object.

@param signature1 First signature, a \f$\texttt{size1}\times \texttt{dims}+1\f$ floating-point matrix.
Each row stores the point weight followed by the point coordinates. The matrix is allowed to have
a single column (weights only) if the user-defined cost matrix is used.
@param signature2 Second signature of the same format as signature1 , though the number of rows
may be different. The total weights may be different. In this case an extra "dummy" point is added
to either signature1 or signature2 .
@param distType Used metric. See cv::DistanceTypes.
@param cost User-defined \f$\texttt{size1}\times \texttt{size2}\f$ cost matrix. Also, if a cost matrix
is used, lower boundary lowerBound cannot be calculated because it needs a metric function.
@param lowerBound Optional input/output parameter: lower boundary of a distance between the two
signatures that is a distance between mass centers. The lower boundary may not be calculated if
the user-defined cost matrix is used, the total weights of point configurations are not equal, or
if the signatures consist of weights only (the signature matrices have a single column). You
**must** initialize \*lowerBound . If the calculated distance between mass centers is greater or
equal to \*lowerBound (it means that the signatures are far enough), the function does not
calculate EMD. In any case \*lowerBound is set to the calculated distance between mass centers on
return. Thus, if you want to calculate both distance between mass centers and EMD, \*lowerBound
should be set to 0.
@param flow Resultant \f$\texttt{size1} \times \texttt{size2}\f$ flow matrix: \f$\texttt{flow}_{i,j}\f$ is
a flow from \f$i\f$ -th point of signature1 to \f$j\f$ -th point of signature2 .

</member>
        <member name="M:cv.compareHist(cv.SparseMat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.SparseMat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@overload 
</member>
        <member name="M:cv.compareHist(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Compares two histograms.

The function compare two dense or two sparse histograms using the specified method.

The function returns \f$d(H_1, H_2)\f$ .

While the function works well with 1-, 2-, 3-dimensional dense histograms, it may not be suitable
for high-dimensional sparse histograms. In such histograms, because of aliasing and sampling
problems, the coordinates of non-zero histogram bins can slightly shift. To compare such histograms
or more general sparse configurations of weighted points, consider using the cv::EMD function.

@param H1 First compared histogram.
@param H2 Second compared histogram of the same size as H1 .
@param method Comparison method, see cv::HistCompMethods

</member>
        <member name="M:cv.calcBackProject(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@overload 
</member>
        <member name="M:cv.calcBackProject(cv.Mat!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,cv.SparseMat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst**,System.Double,System.Boolean)">
@overload 
</member>
        <member name="M:cv.calcBackProject(cv.Mat!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst**,System.Double,System.Boolean)">
@brief Calculates the back projection of a histogram.

The functions calcBackProject calculate the back project of the histogram. That is, similarly to
cv::calcHist , at each location (x, y) the function collects the values from the selected channels
in the input images and finds the corresponding histogram bin. But instead of incrementing it, the
function reads the bin value, scales it by scale , and stores in backProject(x,y) . In terms of
statistics, the function computes probability of each element value in respect with the empirical
probability distribution represented by the histogram. See how, for example, you can find and track
a bright-colored object in a scene:

- Before tracking, show the object to the camera so that it covers almost the whole frame.
Calculate a hue histogram. The histogram may have strong maximums, corresponding to the dominant
colors in the object.

- When tracking, calculate a back projection of a hue plane of each input video frame using that
pre-computed histogram. Threshold the back projection to suppress weak colors. It may also make
sense to suppress pixels with non-sufficient color saturation and too dark or too bright pixels.

- Find connected components in the resulting picture and choose, for example, the largest
component.

This is an approximate algorithm of the CamShift color object tracker.

@param images Source arrays. They all should have the same depth, CV_8U or CV_32F , and the same
size. Each of them can have an arbitrary number of channels.
@param nimages Number of source images.
@param channels The list of channels used to compute the back projection. The number of channels
must match the histogram dimensionality. The first array channels are numerated from 0 to
images[0].channels()-1 , the second array channels are counted from images[0].channels() to
images[0].channels() + images[1].channels()-1, and so on.
@param hist Input histogram that can be dense or sparse.
@param backProject Destination back projection array that is a single-channel array of the same
size and depth as images[0] .
@param ranges Array of arrays of the histogram bin boundaries in each dimension. See calcHist .
@param scale Optional scale factor for the output back projection.
@param uniform Flag indicating whether the histogram is uniform or not (see above).

@sa cv::calcHist, cv::compareHist

</member>
        <member name="M:cv.calcHist(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@overload 
</member>
        <member name="M:cv.calcHist(cv.Mat!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.SparseMat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst**,System.Boolean,System.Boolean)">
@overload

this variant uses cv::SparseMat for output

</member>
        <member name="M:cv.undistortPoints(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes the ideal point coordinates from the observed point coordinates.

The function is similar to cv::undistort and cv::initUndistortRectifyMap but it operates on a
sparse set of points instead of a raster image. Also the function performs a reverse transformation
to projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a
planar object, it does, up to a translation vector, if the proper R is specified.
@code
    // (u,v) is the input point, (u', v') is the output point
    // camera_matrix=[fx 0 cx; 0 fy cy; 0 0 1]
    // P=[fx' 0 cx' tx; 0 fy' cy' ty; 0 0 1 tz]
    x" = (u - cx)/fx
    y" = (v - cy)/fy
    (x',y') = undistort(x",y",dist_coeffs)
    [X,Y,W]T = R*[x' y' 1]T
    x = X/W, y = Y/W
    // only performed if P=[fx' 0 cx' [tx]; 0 fy' cy' [ty]; 0 0 1 [tz]] is specified
    u' = x*fx' + cx'
    v' = y*fy' + cy',
@endcode
where cv::undistort is an approximate iterative algorithm that estimates the normalized original
point coordinates out of the normalized distorted point coordinates ("normalized" means that the
coordinates do not depend on the camera matrix).

The function can be used for both a stereo camera head or a monocular camera (when R is empty).

@param src Observed point coordinates, 1xN or Nx1 2-channel (CV_32FC2 or CV_64FC2).
@param dst Output ideal point coordinates after undistortion and reverse perspective
transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.
@param cameraMatrix Camera matrix \f$\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\f$ .
@param distCoeffs Input vector of distortion coefficients
\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])\f$ of 4, 5, or 8 elements. If the vector is
NULL/empty, the zero distortion coefficients are assumed.
@param R Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by
cv::stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.
@param P New camera matrix (3x3) or new projection matrix (3x4). P1 or P2 computed by
cv::stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.

</member>
        <member name="M:cv.initUndistortRectifyMap(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Int32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes the undistortion and rectification transformation map.

The function computes the joint undistortion and rectification transformation and represents the
result in the form of maps for remap. The undistorted image looks like original, as if it is
captured with a camera using the camera matrix =newCameraMatrix and zero distortion. In case of a
monocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by
cv::getOptimalNewCameraMatrix for a better control over scaling. In case of a stereo camera,
newCameraMatrix is normally set to P1 or P2 computed by cv::stereoRectify .

Also, this new camera is oriented differently in the coordinate space, according to R. That, for
example, helps to align two heads of a stereo camera so that the epipolar lines on both images
become horizontal and have the same y- coordinate (in case of a horizontally aligned stereo camera).

The function actually builds the maps for the inverse mapping algorithm that is used by remap. That
is, for each pixel \f$(u, v)\f$ in the destination (corrected and rectified) image, the function
computes the corresponding coordinates in the source image (that is, in the original image from
camera). The following process is applied:
\f[\begin{array}{l} x  \leftarrow (u - {c'}_x)/{f'}_x  \\ y  \leftarrow (v - {c'}_y)/{f'}_y  \\{[X\,Y\,W]} ^T  \leftarrow R^{-1}*[x \, y \, 1]^T  \\ x'  \leftarrow X/W  \\ y'  \leftarrow Y/W  \\ x"  \leftarrow x' (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + 2p_1 x' y' + p_2(r^2 + 2 x'^2)  \\ y"  \leftarrow y' (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + p_1 (r^2 + 2 y'^2) + 2 p_2 x' y'  \\ map_x(u,v)  \leftarrow x" f_x + c_x  \\ map_y(u,v)  \leftarrow y" f_y + c_y \end{array}\f]
where \f$(k_1, k_2, p_1, p_2[, k_3])\f$ are the distortion coefficients.

In case of a stereo camera, this function is called twice: once for each camera head, after
stereoRectify, which in its turn is called after cv::stereoCalibrate. But if the stereo camera
was not calibrated, it is still possible to compute the rectification transformations directly from
the fundamental matrix using cv::stereoRectifyUncalibrated. For each camera, the function computes
homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D
space. R can be computed from H as
\f[\texttt{R} = \texttt{cameraMatrix} ^{-1} \cdot \texttt{H} \cdot \texttt{cameraMatrix}\f]
where cameraMatrix can be chosen arbitrarily.

@param cameraMatrix Input camera matrix \f$A=\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\f$ .
@param distCoeffs Input vector of distortion coefficients
\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])\f$ of 4, 5, or 8 elements. If the vector is
NULL/empty, the zero distortion coefficients are assumed.
@param R Optional rectification transformation in the object space (3x3 matrix). R1 or R2 ,
computed by stereoRectify can be passed here. If the matrix is empty, the identity transformation
is assumed. In cvInitUndistortMap R assumed to be an identity matrix.
@param newCameraMatrix New camera matrix \f$A'=\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\f$.
@param size Undistorted image size.
@param m1type Type of the first output map that can be CV_32FC1 or CV_16SC2, see cv::convertMaps
@param map1 The first output map.
@param map2 The second output map.

</member>
        <member name="M:cv.undistort(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Transforms an image to compensate for lens distortion.

The function transforms an image to compensate radial and tangential lens distortion.

The function is simply a combination of cv::initUndistortRectifyMap (with unity R ) and cv::remap
(with bilinear interpolation). See the former function for details of the transformation being
performed.

Those pixels in the destination image, for which there is no correspondent pixels in the source
image, are filled with zeros (black color).

A particular subset of the source image that will be visible in the corrected image can be regulated
by newCameraMatrix. You can use cv::getOptimalNewCameraMatrix to compute the appropriate
newCameraMatrix depending on your requirements.

The camera matrix and the distortion parameters can be determined using cv::calibrateCamera. If
the resolution of images is different from the resolution used at the calibration stage, \f$f_x,
f_y, c_x\f$ and \f$c_y\f$ need to be scaled accordingly, while the distortion coefficients remain
the same.

@param src Input (distorted) image.
@param dst Output (corrected) image that has the same size and type as src .
@param cameraMatrix Input camera matrix \f$A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\f$ .
@param distCoeffs Input vector of distortion coefficients
\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])\f$ of 4, 5, or 8 elements. If the vector is
NULL/empty, the zero distortion coefficients are assumed.
@param newCameraMatrix Camera matrix of the distorted image. By default, it is the same as
cameraMatrix but you may additionally scale and shift the result by using a different matrix.

</member>
        <member name="M:cv.buildPyramid(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief Constructs the Gaussian pyramid for an image.

The function constructs a vector of images and builds the Gaussian pyramid by recursively applying
pyrDown to the previously built pyramid layers, starting from `dst[0]==src`.

@param src Source image. Check pyrDown for the list of supported types.
@param dst Destination vector of maxlevel+1 images of the same type as src. dst[0] will be the
same as src. dst[1] is the next pyramid layer, a smoothed and down-sized src, and so on.
@param maxlevel 0-based index of the last (the smallest) pyramid layer. It must be non-negative.
@param borderType Pixel extrapolation method, see cv::BorderTypes (BORDER_CONSTANT isn't supported)

</member>
        <member name="M:cv.pyrUp(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Upsamples an image and then blurs it.

By default, size of the output image is computed as `Size(src.cols\*2, (src.rows\*2)`, but in any
case, the following conditions should be satisfied:

\f[\begin{array}{l} | \texttt{dstsize.width} -src.cols*2| \leq  ( \texttt{dstsize.width}   \mod  2)  \\ | \texttt{dstsize.height} -src.rows*2| \leq  ( \texttt{dstsize.height}   \mod  2) \end{array}\f]

The function performs the upsampling step of the Gaussian pyramid construction, though it can
actually be used to construct the Laplacian pyramid. First, it upsamples the source image by
injecting even zero rows and columns and then convolves the result with the same kernel as in
pyrDown multiplied by 4.

@param src input image.
@param dst output image. It has the specified size and the same type as src .
@param dstsize size of the output image.
@param borderType Pixel extrapolation method, see cv::BorderTypes (only BORDER_DEFAULT is supported)

</member>
        <member name="M:cv.adaptiveThreshold(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32,System.Int32,System.Int32,System.Double)">
@brief Applies an adaptive threshold to an array.

The function transforms a grayscale image to a binary image according to the formulae:
-   **THRESH_BINARY**
    \f[dst(x,y) =  \fork{\texttt{maxValue}}{if \(src(x,y) &gt; T(x,y)\)}{0}{otherwise}\f]
-   **THRESH_BINARY_INV**
    \f[dst(x,y) =  \fork{0}{if \(src(x,y) &gt; T(x,y)\)}{\texttt{maxValue}}{otherwise}\f]
where \f$T(x,y)\f$ is a threshold calculated individually for each pixel (see adaptiveMethod parameter).

The function can process the image in-place.

@param src Source 8-bit single-channel image.
@param dst Destination image of the same size and the same type as src.
@param maxValue Non-zero value assigned to the pixels for which the condition is satisfied
@param adaptiveMethod Adaptive thresholding algorithm to use, see cv::AdaptiveThresholdTypes
@param thresholdType Thresholding type that must be either THRESH_BINARY or THRESH_BINARY_INV,
see cv::ThresholdTypes.
@param blockSize Size of a pixel neighborhood that is used to calculate a threshold value for the
pixel: 3, 5, 7, and so on.
@param C Constant subtracted from the mean or weighted mean (see the details below). Normally, it
is positive but may be zero or negative as well.

@sa  threshold, blur, GaussianBlur

</member>
        <member name="M:cv.threshold(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Int32)">
@brief Applies a fixed-level threshold to each array element.

The function applies fixed-level thresholding to a single-channel array. The function is typically
used to get a bi-level (binary) image out of a grayscale image ( cv::compare could be also used for
this purpose) or for removing a noise, that is, filtering out pixels with too small or too large
values. There are several types of thresholding supported by the function. They are determined by
type parameter.

Also, the special values cv::THRESH_OTSU or cv::THRESH_TRIANGLE may be combined with one of the
above values. In these cases, the function determines the optimal threshold value using the Otsu's
or Triangle algorithm and uses it instead of the specified thresh . The function returns the
computed threshold value. Currently, the Otsu's and Triangle methods are implemented only for 8-bit
images.

@param src input array (single-channel, 8-bit or 32-bit floating point).
@param dst output array of the same size and type as src.
@param thresh threshold value.
@param maxval maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding
types.
@param type thresholding type (see the cv::ThresholdTypes).

@sa  adaptiveThreshold, findContours, compare, min, max

</member>
        <member name="M:cv.createHanningWindow(cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Int32)">
@brief This function computes a Hanning window coefficients in two dimensions.

See (http://en.wikipedia.org/wiki/Hann_function) and (http://en.wikipedia.org/wiki/Window_function)
for more information.

An example is shown below:
@code
    // create hanning window of size 100x100 and type CV_32F
    Mat hann;
    createHanningWindow(hann, Size(100, 100), CV_32F);
@endcode
@param dst Destination array to place Hann coefficients in
@param winSize The window size specifications
@param type Created array type

</member>
        <member name="M:cv.accumulateWeighted(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Updates a running average.

The function calculates the weighted sum of the input image src and the accumulator dst so that dst
becomes a running average of a frame sequence:

\f[\texttt{dst} (x,y)  \leftarrow (1- \texttt{alpha} )  \cdot \texttt{dst} (x,y) +  \texttt{alpha} \cdot \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]

That is, alpha regulates the update speed (how fast the accumulator "forgets" about earlier images).
The function supports multi-channel images. Each channel is processed independently.

@param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
@param dst %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
floating-point.
@param alpha Weight of the input image.
@param mask Optional operation mask.

@sa  accumulate, accumulateSquare, accumulateProduct

</member>
        <member name="M:cv.accumulateProduct(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Adds the per-element product of two input images to the accumulator.

The function adds the product of two images or their selected regions to the accumulator dst :

\f[\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src1} (x,y)  \cdot \texttt{src2} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]

The function supports multi-channel images. Each channel is processed independently.

@param src1 First input image, 1- or 3-channel, 8-bit or 32-bit floating point.
@param src2 Second input image of the same type and the same size as src1 .
@param dst %Accumulator with the same number of channels as input images, 32-bit or 64-bit
floating-point.
@param mask Optional operation mask.

@sa  accumulate, accumulateSquare, accumulateWeighted

</member>
        <member name="M:cv.accumulateSquare(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Adds the square of a source image to the accumulator.

The function adds the input image src or its selected region, raised to a power of 2, to the
accumulator dst :

\f[\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)^2  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]

The function supports multi-channel images. Each channel is processed independently.

@param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
@param dst %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
floating-point.
@param mask Optional operation mask.

@sa  accumulateSquare, accumulateProduct, accumulateWeighted

</member>
        <member name="M:cv.accumulate(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Adds an image to the accumulator.

The function adds src or some of its elements to dst :

\f[\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]

The function supports multi-channel images. Each channel is processed independently.

The functions accumulate\* can be used, for example, to collect statistics of a scene background
viewed by a still camera and for the further foreground-background segmentation.

@param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
@param dst %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
floating-point.
@param mask Optional operation mask.

@sa  accumulateSquare, accumulateProduct, accumulateWeighted

</member>
        <member name="M:cv.integral(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@overload 
</member>
        <member name="M:cv.integral(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@overload 
</member>
        <member name="M:cv.linearPolar(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Single&gt;,System.Double,System.Int32)">
@brief Remaps an image to polar space.

transforms the source image using the following transformation:
\f[dst( \phi , \rho ) = src(x,y)\f]
where
\f[\rho = (src.width/maxRadius)  \cdot \sqrt{x^2 + y^2} , \phi =atan(y/x)\f]

The function can not operate in-place.

@param src Source image
@param dst Destination image
@param center The transformation center;
@param maxRadius Inverse magnitude scale parameter
@param flags A combination of interpolation methods, see cv::InterpolationFlags

</member>
        <member name="M:cv.logPolar(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Single&gt;,System.Double,System.Int32)">
@example polar_transforms.cpp
An example using the cv::linearPolar and cv::logPolar operations

@brief Remaps an image to log-polar space.

transforms the source image using the following transformation:
\f[dst( \phi , \rho ) = src(x,y)\f]
where
\f[\rho = M  \cdot \log{\sqrt{x^2 + y^2}} , \phi =atan(y/x)\f]

The function emulates the human "foveal" vision and can be used for fast scale and
rotation-invariant template matching, for object tracking and so forth. The function can not operate
in-place.

@param src Source image
@param dst Destination image
@param center The transformation center; where the output precision is maximal
@param M Magnitude scale parameter.
@param flags A combination of interpolation methods, see cv::InterpolationFlags

</member>
        <member name="M:cv.getRectSubPix(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,cv.Point_&lt;System.Single&gt;,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Retrieves a pixel rectangle from an image with sub-pixel accuracy.

The function getRectSubPix extracts pixels from src:

\f[dst(x, y) = src(x +  \texttt{center.x} - ( \texttt{dst.cols} -1)*0.5, y +  \texttt{center.y} - ( \texttt{dst.rows} -1)*0.5)\f]

where the values of the pixels at non-integer coordinates are retrieved using bilinear
interpolation. Every channel of multi-channel images is processed independently. While the center of
the rectangle must be inside the image, parts of the rectangle may be outside. In this case, the
replication border mode (see cv::BorderTypes) is used to extrapolate the pixel values outside of
the image.

@param image Source image.
@param patchSize Size of the extracted patch.
@param center Floating point coordinates of the center of the extracted rectangle within the
source image. The center must be inside the image.
@param patch Extracted patch that has the size patchSize and the same number of channels as src .
@param patchType Depth of the extracted pixels. By default, they have the same depth as src .

@sa  warpAffine, warpPerspective

</member>
        <member name="M:cv.getPerspectiveTransform(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates a perspective transform from four pairs of the corresponding points.

The function calculates the \f$3 \times 3\f$ matrix of a perspective transform so that:

\f[\begin{bmatrix} t_i x'_i \\ t_i y'_i \\ t_i \end{bmatrix} = \texttt{map\_matrix} \cdot \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}\f]

where

\f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3\f]

@param src Coordinates of quadrangle vertices in the source image.
@param dst Coordinates of the corresponding quadrangle vertices in the destination image.

@sa  findHomography, warpPerspective, perspectiveTransform

</member>
        <member name="M:cv.getAffineTransform(cv.Point_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*,cv.Point_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*)">
@brief Calculates an affine transform from three pairs of the corresponding points.

The function calculates the \f$2 \times 3\f$ matrix of an affine transform so that:

\f[\begin{bmatrix} x'_i \\ y'_i \end{bmatrix} = \texttt{map\_matrix} \cdot \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}\f]

where

\f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2\f]

@param src Coordinates of triangle vertices in the source image.
@param dst Coordinates of the corresponding triangle vertices in the destination image.

@sa  warpAffine, transform

</member>
        <member name="M:cv.convertMaps(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
@brief Converts image transformation maps from one representation to another.

The function converts a pair of maps for remap from one representation to another. The following
options ( (map1.type(), map2.type()) \f$\rightarrow\f$ (dstmap1.type(), dstmap2.type()) ) are
supported:

- \f$\texttt{(CV\_32FC1, CV\_32FC1)} \rightarrow \texttt{(CV\_16SC2, CV\_16UC1)}\f$. This is the
most frequently used conversion operation, in which the original floating-point maps (see remap )
are converted to a more compact and much faster fixed-point representation. The first output array
contains the rounded coordinates and the second array (created only when nninterpolation=false )
contains indices in the interpolation tables.

- \f$\texttt{(CV\_32FC2)} \rightarrow \texttt{(CV\_16SC2, CV\_16UC1)}\f$. The same as above but
the original maps are stored in one 2-channel matrix.

- Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same
as the originals.

@param map1 The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 .
@param map2 The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix),
respectively.
@param dstmap1 The first output map that has the type dstmap1type and the same size as src .
@param dstmap2 The second output map.
@param dstmap1type Type of the first output map that should be CV_16SC2, CV_32FC1, or
CV_32FC2 .
@param nninterpolation Flag indicating whether the fixed-point maps are used for the
nearest-neighbor or for a more complex interpolation.

@sa  remap, undistort, initUndistortRectifyMap

</member>
        <member name="M:cv.remap(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Applies a generic geometrical transformation to an image.

The function remap transforms the source image using the specified map:

\f[\texttt{dst} (x,y) =  \texttt{src} (map_x(x,y),map_y(x,y))\f]

where values of pixels with non-integer coordinates are computed using one of available
interpolation methods. \f$map_x\f$ and \f$map_y\f$ can be encoded as separate floating-point maps
in \f$map_1\f$ and \f$map_2\f$ respectively, or interleaved floating-point maps of \f$(x,y)\f$ in
\f$map_1\f$, or fixed-point maps created by using convertMaps. The reason you might want to
convert from floating to fixed-point representations of a map is that they can yield much faster
(\~2x) remapping operations. In the converted case, \f$map_1\f$ contains pairs (cvFloor(x),
cvFloor(y)) and \f$map_2\f$ contains indices in a table of interpolation coefficients.

This function cannot operate in-place.

@param src Source image.
@param dst Destination image. It has the same size as map1 and the same type as src .
@param map1 The first map of either (x,y) points or just x values having the type CV_16SC2 ,
CV_32FC1, or CV_32FC2. See convertMaps for details on converting a floating point
representation to fixed-point for speed.
@param map2 The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map
if map1 is (x,y) points), respectively.
@param interpolation Interpolation method (see cv::InterpolationFlags). The method INTER_AREA is
not supported by this function.
@param borderMode Pixel extrapolation method (see cv::BorderTypes). When
borderMode=BORDER_TRANSPARENT, it means that the pixels in the destination image that
corresponds to the "outliers" in the source image are not modified by the function.
@param borderValue Value used in case of a constant border. By default, it is 0.

</member>
        <member name="M:cv.warpPerspective(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Int32,System.Int32,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Applies a perspective transformation to an image.

The function warpPerspective transforms the source image using the specified matrix:

\f[\texttt{dst} (x,y) =  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,
     \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )\f]

when the flag WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert
and then put in the formula above instead of M. The function cannot operate in-place.

@param src input image.
@param dst output image that has the size dsize and the same type as src .
@param M \f$3\times 3\f$ transformation matrix.
@param dsize size of the output image.
@param flags combination of interpolation methods (INTER_LINEAR or INTER_NEAREST) and the
optional flag WARP_INVERSE_MAP, that sets M as the inverse transformation (
\f$\texttt{dst}\rightarrow\texttt{src}\f$ ).
@param borderMode pixel extrapolation method (BORDER_CONSTANT or BORDER_REPLICATE).
@param borderValue value used in case of a constant border; by default, it equals 0.

@sa  warpAffine, resize, remap, getRectSubPix, perspectiveTransform

</member>
        <member name="M:cv.warpAffine(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Int32,System.Int32,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Applies an affine transformation to an image.

The function warpAffine transforms the source image using the specified matrix:

\f[\texttt{dst} (x,y) =  \texttt{src} ( \texttt{M} _{11} x +  \texttt{M} _{12} y +  \texttt{M} _{13}, \texttt{M} _{21} x +  \texttt{M} _{22} y +  \texttt{M} _{23})\f]

when the flag WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted
with cv::invertAffineTransform and then put in the formula above instead of M. The function cannot
operate in-place.

@param src input image.
@param dst output image that has the size dsize and the same type as src .
@param M \f$2\times 3\f$ transformation matrix.
@param dsize size of the output image.
@param flags combination of interpolation methods (see cv::InterpolationFlags) and the optional
flag WARP_INVERSE_MAP that means that M is the inverse transformation (
\f$\texttt{dst}\rightarrow\texttt{src}\f$ ).
@param borderMode pixel extrapolation method (see cv::BorderTypes); when
borderMode=BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to
the "outliers" in the source image are not modified by the function.
@param borderValue value used in case of a constant border; by default, it is 0.

@sa  warpPerspective, resize, remap, getRectSubPix, transform

</member>
        <member name="M:cv.resize(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Double,System.Double,System.Int32)">
@brief Resizes an image.

The function resize resizes the image src down to or up to the specified size. Note that the
initial dst type or size are not taken into account. Instead, the size and type are derived from
the `src`,`dsize`,`fx`, and `fy`. If you want to resize src so that it fits the pre-created dst,
you may call the function as follows:
@code
    // explicitly specify dsize=dst.size(); fx and fy will be computed from that.
    resize(src, dst, dst.size(), 0, 0, interpolation);
@endcode
If you want to decimate the image by factor of 2 in each direction, you can call the function this
way:
@code
    // specify fx and fy and let the function compute the destination image size.
    resize(src, dst, Size(), 0.5, 0.5, interpolation);
@endcode
To shrink an image, it will generally look best with CV_INTER_AREA interpolation, whereas to
enlarge an image, it will generally look best with CV_INTER_CUBIC (slow) or CV_INTER_LINEAR
(faster but still looks OK).

@param src input image.
@param dst output image; it has the size dsize (when it is non-zero) or the size computed from
src.size(), fx, and fy; the type of dst is the same as of src.
@param dsize output image size; if it equals zero, it is computed as:
 \f[\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\f]
 Either dsize or both fx and fy must be non-zero.
@param fx scale factor along the horizontal axis; when it equals 0, it is computed as
\f[\texttt{(double)dsize.width/src.cols}\f]
@param fy scale factor along the vertical axis; when it equals 0, it is computed as
\f[\texttt{(double)dsize.height/src.rows}\f]
@param interpolation interpolation method, see cv::InterpolationFlags

@sa  warpAffine, warpPerspective, remap

</member>
        <member name="M:cv.morphologyEx(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,System.Int32,System.Int32,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Performs advanced morphological transformations.

The function can perform advanced morphological transformations using an erosion and dilation as
basic operations.

Any of the operations can be done in-place. In case of multi-channel images, each channel is
processed independently.

@param src Source image. The number of channels can be arbitrary. The depth should be one of
CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
@param dst Destination image of the same size and type as  src\` .
@param kernel Structuring element. It can be created using getStructuringElement.
@param anchor Anchor position with the kernel. Negative values mean that the anchor is at the
kernel center.
@param op Type of a morphological operation, see cv::MorphTypes
@param iterations Number of times erosion and dilation are applied.
@param borderType Pixel extrapolation method, see cv::BorderTypes
@param borderValue Border value in case of a constant border. The default value has a special
meaning.
@sa  dilate, erode, getStructuringElement

</member>
        <member name="M:cv.dilate(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,System.Int32,System.Int32,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Dilates an image by using a specific structuring element.

The function dilates the source image using the specified structuring element that determines the
shape of a pixel neighborhood over which the maximum is taken:
\f[\texttt{dst} (x,y) =  \max _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\f]

The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
case of multi-channel images, each channel is processed independently.

@param src input image; the number of channels can be arbitrary, but the depth should be one of
CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
@param dst output image of the same size and type as src\`.
@param kernel structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular
structuring element is used. Kernel can be created using getStructuringElement
@param anchor position of the anchor within the element; default value (-1, -1) means that the
anchor is at the element center.
@param iterations number of times dilation is applied.
@param borderType pixel extrapolation method, see cv::BorderTypes
@param borderValue border value in case of a constant border
@sa  erode, morphologyEx, getStructuringElement

</member>
        <member name="M:cv.erode(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,System.Int32,System.Int32,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@example morphology2.cpp
  An example using the morphological operations

@brief Erodes an image by using a specific structuring element.

The function erodes the source image using the specified structuring element that determines the
shape of a pixel neighborhood over which the minimum is taken:

\f[\texttt{dst} (x,y) =  \min _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\f]

The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In
case of multi-channel images, each channel is processed independently.

@param src input image; the number of channels can be arbitrary, but the depth should be one of
CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
@param dst output image of the same size and type as src.
@param kernel structuring element used for erosion; if `element=Mat()`, a `3 x 3` rectangular
structuring element is used. Kernel can be created using getStructuringElement.
@param anchor position of the anchor within the element; default value (-1, -1) means that the
anchor is at the element center.
@param iterations number of times erosion is applied.
@param borderType pixel extrapolation method, see cv::BorderTypes
@param borderValue border value in case of a constant border
@sa  dilate, morphologyEx, getStructuringElement

</member>
        <member name="M:cv.goodFeaturesToTrack(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,System.Double,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean,System.Double)">
@brief Determines strong corners on an image.

The function finds the most prominent corners in the image or in the specified image region, as
described in @cite Shi94

-   Function calculates the corner quality measure at every source image pixel using the
    cornerMinEigenVal or cornerHarris .
-   Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are
    retained).
-   The corners with the minimal eigenvalue less than
    \f$\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)\f$ are rejected.
-   The remaining corners are sorted by the quality measure in the descending order.
-   Function throws away each corner for which there is a stronger corner at a distance less than
    maxDistance.

The function can be used to initialize a point-based tracker of an object.

@note If the function is called with different values A and B of the parameter qualityLevel , and
A \&gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector
with qualityLevel=B .

@param image Input 8-bit or floating-point 32-bit, single-channel image.
@param corners Output vector of detected corners.
@param maxCorners Maximum number of corners to return. If there are more corners than are found,
the strongest of them is returned.
@param qualityLevel Parameter characterizing the minimal accepted quality of image corners. The
parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
(see cornerMinEigenVal ) or the Harris function response (see cornerHarris ). The corners with the
quality measure less than the product are rejected. For example, if the best corner has the
quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
less than 15 are rejected.
@param minDistance Minimum possible Euclidean distance between the returned corners.
@param mask Optional region of interest. If the image is not empty (it needs to have the type
CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.
@param blockSize Size of an average block for computing a derivative covariation matrix over each
pixel neighborhood. See cornerEigenValsAndVecs .
@param useHarrisDetector Parameter indicating whether to use a Harris detector (see cornerHarris)
or cornerMinEigenVal.
@param k Free parameter of the Harris detector.

@sa  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,

</member>
        <member name="M:cv.cornerSubPix(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,cv.Size_&lt;System.Int32&gt;,cv.TermCriteria)">
@brief Refines the corner locations.

The function iterates to find the sub-pixel accurate location of corners or radial saddle points, as
shown on the figure below.

![image](pics/cornersubpix.png)

Sub-pixel accurate corner locator is based on the observation that every vector from the center \f$q\f$
to a point \f$p\f$ located within a neighborhood of \f$q\f$ is orthogonal to the image gradient at \f$p\f$
subject to image and measurement noise. Consider the expression:

\f[\epsilon _i = {DI_{p_i}}^T  \cdot (q - p_i)\f]

where \f${DI_{p_i}}\f$ is an image gradient at one of the points \f$p_i\f$ in a neighborhood of \f$q\f$ . The
value of \f$q\f$ is to be found so that \f$\epsilon_i\f$ is minimized. A system of equations may be set up
with \f$\epsilon_i\f$ set to zero:

\f[\sum _i(DI_{p_i}  \cdot {DI_{p_i}}^T) -  \sum _i(DI_{p_i}  \cdot {DI_{p_i}}^T  \cdot p_i)\f]

where the gradients are summed within a neighborhood ("search window") of \f$q\f$ . Calling the first
gradient term \f$G\f$ and the second gradient term \f$b\f$ gives:

\f[q = G^{-1}  \cdot b\f]

The algorithm sets the center of the neighborhood window at this new center \f$q\f$ and then iterates
until the center stays within a set threshold.

@param image Input image.
@param corners Initial coordinates of the input corners and refined coordinates provided for
output.
@param winSize Half of the side length of the search window. For example, if winSize=Size(5,5) ,
then a \f$5*2+1 \times 5*2+1 = 11 \times 11\f$ search window is used.
@param zeroZone Half of the size of the dead region in the middle of the search zone over which
the summation in the formula below is not done. It is used sometimes to avoid possible
singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such
a size.
@param criteria Criteria for termination of the iterative process of corner refinement. That is,
the process of corner position refinement stops either after criteria.maxCount iterations or when
the corner position moves by less than criteria.epsilon on some iteration.

</member>
        <member name="M:cv.preCornerDetect(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief Calculates a feature map for corner detection.

The function calculates the complex spatial derivative-based function of the source image

\f[\texttt{dst} = (D_x  \texttt{src} )^2  \cdot D_{yy}  \texttt{src} + (D_y  \texttt{src} )^2  \cdot D_{xx}  \texttt{src} - 2 D_x  \texttt{src} \cdot D_y  \texttt{src} \cdot D_{xy}  \texttt{src}\f]

where \f$D_x\f$,\f$D_y\f$ are the first image derivatives, \f$D_{xx}\f$,\f$D_{yy}\f$ are the second image
derivatives, and \f$D_{xy}\f$ is the mixed derivative.

The corners can be found as local maximums of the functions, as shown below:
@code
    Mat corners, dilated_corners;
    preCornerDetect(image, corners, 3);
    // dilation with 3x3 rectangular structuring element
    dilate(corners, dilated_corners, Mat(), 1);
    Mat corner_mask = corners == dilated_corners;
@endcode

@param src Source single-channel 8-bit of floating-point image.
@param dst Output image that has the type CV_32F and the same size as src .
@param ksize %Aperture size of the Sobel .
@param borderType Pixel extrapolation method. See cv::BorderTypes.

</member>
        <member name="M:cv.cornerHarris(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Double,System.Int32)">
@brief Harris corner detector.

The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and
cornerEigenValsAndVecs , for each pixel \f$(x, y)\f$ it calculates a \f$2\times2\f$ gradient covariance
matrix \f$M^{(x,y)}\f$ over a \f$\texttt{blockSize} \times \texttt{blockSize}\f$ neighborhood. Then, it
computes the following characteristic:

\f[\texttt{dst} (x,y) =  \mathrm{det} M^{(x,y)} - k  \cdot \left ( \mathrm{tr} M^{(x,y)} \right )^2\f]

Corners in the image can be found as the local maxima of this response map.

@param src Input single-channel 8-bit or floating-point image.
@param dst Image to store the Harris detector responses. It has the type CV_32FC1 and the same
size as src .
@param blockSize Neighborhood size (see the details on cornerEigenValsAndVecs ).
@param ksize Aperture parameter for the Sobel operator.
@param k Harris detector free parameter. See the formula below.
@param borderType Pixel extrapolation method. See cv::BorderTypes.

</member>
        <member name="M:cv.cornerMinEigenVal(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
@brief Calculates the minimal eigenvalue of gradient matrices for corner detection.

The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal
eigenvalue of the covariance matrix of derivatives, that is, \f$\min(\lambda_1, \lambda_2)\f$ in terms
of the formulae in the cornerEigenValsAndVecs description.

@param src Input single-channel 8-bit or floating-point image.
@param dst Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as
src .
@param blockSize Neighborhood size (see the details on cornerEigenValsAndVecs ).
@param ksize Aperture parameter for the Sobel operator.
@param borderType Pixel extrapolation method. See cv::BorderTypes.

</member>
        <member name="M:cv.Laplacian(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Double,System.Double,System.Int32)">
@example laplace.cpp
  An example using Laplace transformations for edge detection

@brief Calculates the Laplacian of an image.

The function calculates the Laplacian of the source image by adding up the second x and y
derivatives calculated using the Sobel operator:

\f[\texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2}\f]

This is done when `ksize &gt; 1`. When `ksize == 1`, the Laplacian is computed by filtering the image
with the following \f$3 \times 3\f$ aperture:

\f[\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\f]

@param src Source image.
@param dst Destination image of the same size and the same number of channels as src .
@param ddepth Desired depth of the destination image.
@param ksize Aperture size used to compute the second-derivative filters. See getDerivKernels for
details. The size must be positive and odd.
@param scale Optional scale factor for the computed Laplacian values. By default, no scaling is
applied. See getDerivKernels for details.
@param delta Optional delta value that is added to the results prior to storing them in dst .
@param borderType Pixel extrapolation method, see cv::BorderTypes
@sa  Sobel, Scharr

</member>
        <member name="M:cv.Scharr(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32)">
@brief Calculates the first x- or y- image derivative using Scharr operator.

The function computes the first x- or y- spatial image derivative using the Scharr operator. The
call

\f[\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\f]

is equivalent to

\f[\texttt{Sobel(src, dst, ddepth, dx, dy, CV\_SCHARR, scale, delta, borderType)} .\f]

@param src input image.
@param dst output image of the same size and the same number of channels as src.
@param ddepth output image depth, see @ref filter_depths "combinations"
@param dx order of the derivative x.
@param dy order of the derivative y.
@param scale optional scale factor for the computed derivative values; by default, no scaling is
applied (see getDerivKernels for details).
@param delta optional delta value that is added to the results prior to storing them in dst.
@param borderType pixel extrapolation method, see cv::BorderTypes
@sa  cartToPolar

</member>
        <member name="M:cv.Sobel(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32)">
@brief Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

In all cases except one, the \f$\texttt{ksize} \times \texttt{ksize}\f$ separable kernel is used to
calculate the derivative. When \f$\texttt{ksize = 1}\f$, the \f$3 \times 1\f$ or \f$1 \times 3\f$
kernel is used (that is, no Gaussian smoothing is done). `ksize = 1` can only be used for the first
or the second x- or y- derivatives.

There is also the special value `ksize = CV_SCHARR (-1)` that corresponds to the \f$3\times3\f$ Scharr
filter that may give more accurate results than the \f$3\times3\f$ Sobel. The Scharr aperture is

\f[\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\f]

for the x-derivative, or transposed for the y-derivative.

The function calculates an image derivative by convolving the image with the appropriate kernel:

\f[\texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}\f]

The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less
resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)
or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first
case corresponds to a kernel of:

\f[\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\f]

The second case corresponds to a kernel of:

\f[\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\f]

@param src input image.
@param dst output image of the same size and the same number of channels as src .
@param ddepth output image depth, see @ref filter_depths "combinations"; in the case of
    8-bit input images it will result in truncated derivatives.
@param dx order of the derivative x.
@param dy order of the derivative y.
@param ksize size of the extended Sobel kernel; it must be 1, 3, 5, or 7.
@param scale optional scale factor for the computed derivative values; by default, no scaling is
applied (see cv::getDerivKernels for details).
@param delta optional delta value that is added to the results prior to storing them in dst.
@param borderType pixel extrapolation method, see cv::BorderTypes
@sa  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar

</member>
        <member name="M:cv.sepFilter2D(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;,System.Double,System.Int32)">
@brief Applies a separable linear filter to an image.

The function applies a separable linear filter to the image. That is, first, every row of src is
filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D
kernel kernelY. The final result shifted by delta is stored in dst .

@param src Source image.
@param dst Destination image of the same size and the same number of channels as src .
@param ddepth Destination image depth, see @ref filter_depths "combinations"
@param kernelX Coefficients for filtering each row.
@param kernelY Coefficients for filtering each column.
@param anchor Anchor position within the kernel. The default value \f$(-1,-1)\f$ means that the anchor
is at the kernel center.
@param delta Value added to the filtered results before storing them.
@param borderType Pixel extrapolation method, see cv::BorderTypes
@sa  filter2D, Sobel, GaussianBlur, boxFilter, blur

</member>
        <member name="M:cv.sqrBoxFilter(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.Size_&lt;System.Int32&gt;,cv.Point_&lt;System.Int32&gt;,System.Boolean,System.Int32)">
@brief Calculates the normalized sum of squares of the pixel values overlapping the filter.

For every pixel \f$ (x, y) \f$ in the source image, the function calculates the sum of squares of those neighboring
pixel values which overlap the filter placed over the pixel \f$ (x, y) \f$.

The unnormalized square box filter can be useful in computing local image statistics such as the the local
variance and standard deviation around the neighborhood of a pixel.

@param _src input image
@param _dst output image of the same size and type as _src
@param ddepth the output image depth (-1 to use src.depth())
@param ksize kernel size
@param anchor kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel
center.
@param normalize flag, specifying whether the kernel is to be normalized by it's area or not.
@param borderType border mode used to extrapolate pixels outside of the image, see cv::BorderTypes
@sa boxFilter

</member>
        <member name="M:cv.GaussianBlur(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Double,System.Double,System.Int32)">
@brief Blurs an image using a Gaussian filter.

The function convolves the source image with the specified Gaussian kernel. In-place filtering is
supported.

@param src input image; the image can have any number of channels, which are processed
independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
@param dst output image of the same size and type as src.
@param ksize Gaussian kernel size. ksize.width and ksize.height can differ but they both must be
positive and odd. Or, they can be zero's and then they are computed from sigma.
@param sigmaX Gaussian kernel standard deviation in X direction.
@param sigmaY Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be
equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,
respectively (see cv::getGaussianKernel for details); to fully control the result regardless of
possible future modifications of all this semantics, it is recommended to specify all of ksize,
sigmaX, and sigmaY.
@param borderType pixel extrapolation method, see cv::BorderTypes

@sa  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur

</member>
        <member name="M:cv.medianBlur(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Blurs an image using the median filter.

The function smoothes an image using the median filter with the \f$\texttt{ksize} \times
\texttt{ksize}\f$ aperture. Each channel of a multi-channel image is processed independently.
In-place operation is supported.

@param src input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be
CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.
@param dst destination array of the same size and type as src.
@param ksize aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...
@sa  bilateralFilter, blur, boxFilter, GaussianBlur

</member>
        <member name="M:cv.getStructuringElement(System.Int32,cv.Size_&lt;System.Int32&gt;,cv.Point_&lt;System.Int32&gt;)">
@brief Returns a structuring element of the specified size and shape for morphological operations.

The function constructs and returns the structuring element that can be further passed to cv::erode,
cv::dilate or cv::morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as
the structuring element.

@param shape Element shape that could be one of cv::MorphShapes
@param ksize Size of the structuring element.
@param anchor Anchor position within the element. The default value \f$(-1, -1)\f$ means that the
anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor
position. In other cases the anchor just regulates how much the result of the morphological
operation is shifted.

</member>
        <member name="M:cv.getGaborKernel(cv.Size_&lt;System.Int32&gt;,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32)">
@brief Returns Gabor filter coefficients.

For more details about gabor filter equations and parameters, see: [Gabor
Filter](http://en.wikipedia.org/wiki/Gabor_filter).

@param ksize Size of the filter returned.
@param sigma Standard deviation of the gaussian envelope.
@param theta Orientation of the normal to the parallel stripes of a Gabor function.
@param lambd Wavelength of the sinusoidal factor.
@param gamma Spatial aspect ratio.
@param psi Phase offset.
@param ktype Type of filter coefficients. It can be CV_32F or CV_64F .

</member>
        <member name="M:cv.getDerivKernels(cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32)">
@brief Returns filter coefficients for computing spatial image derivatives.

The function computes and returns the filter coefficients for spatial image derivatives. When
`ksize=CV_SCHARR`, the Scharr \f$3 \times 3\f$ kernels are generated (see cv::Scharr). Otherwise, Sobel
kernels are generated (see cv::Sobel). The filters are normally passed to sepFilter2D or to

@param kx Output matrix of row filter coefficients. It has the type ktype .
@param ky Output matrix of column filter coefficients. It has the type ktype .
@param dx Derivative order in respect of x.
@param dy Derivative order in respect of y.
@param ksize Aperture size. It can be CV_SCHARR, 1, 3, 5, or 7.
@param normalize Flag indicating whether to normalize (scale down) the filter coefficients or not.
Theoretically, the coefficients should have the denominator \f$=2^{ksize*2-dx-dy-2}\f$. If you are
going to filter floating-point images, you are likely to use the normalized kernels. But if you
compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve
all the fractional bits, you may want to set normalize=false .
@param ktype Type of filter coefficients. It can be CV_32f or CV_64F .

</member>
        <member name="M:cv.getGaussianKernel(System.Int32,System.Double,System.Int32)">
@brief Returns Gaussian filter coefficients.

The function computes and returns the \f$\texttt{ksize} \times 1\f$ matrix of Gaussian filter
coefficients:

\f[G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma}^2)},\f]

where \f$i=0..\texttt{ksize}-1\f$ and \f$\alpha\f$ is the scale factor chosen so that \f$\sum_i G_i=1\f$.

Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize
smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly.
You may also use the higher-level GaussianBlur.
@param ksize Aperture size. It should be odd ( \f$\texttt{ksize} \mod 2 = 1\f$ ) and positive.
@param sigma Gaussian standard deviation. If it is non-positive, it is computed from ksize as
`sigma = 0.3\*((ksize-1)\*0.5 - 1) + 0.8`.
@param ktype Type of filter coefficients. It can be CV_32F or CV_64F .
@sa  sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur

</member>
        <member name="M:cv.createLineSegmentDetector(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32)">
@brief Creates a smart pointer to a LineSegmentDetector object and initializes it.

The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
to edit those, as to tailor it for their own application.

@param _refine The way found lines will be refined, see cv::LineSegmentDetectorModes
@param _scale The scale of the image that will be used to find the lines. Range (0..1].
@param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale.
@param _quant Bound to the quantization error on the gradient norm.
@param _ang_th Gradient angle tolerance in degrees.
@param _log_eps Detection threshold: -log10(NFA) \&gt; log_eps. Used only when advancent refinement
is chosen.
@param _density_th Minimal density of aligned region points in the enclosing rectangle.
@param _n_bins Number of bins in pseudo-ordering of gradient modulus.

</member>
        <member name="M:cv.LineSegmentDetector.compareSegments(cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Draws two groups of lines in blue and red, counting the non overlapping (mismatching) pixels.

    @param size The size of the image, where lines1 and lines2 were found.
    @param lines1 The first group of lines that needs to be drawn. It is visualized in blue color.
    @param lines2 The second group of lines. They visualized in red color.
    @param _image Optional image, where the lines will be drawn. The image should be color(3-channel)
    in order for lines1 and lines2 to be drawn in the above mentioned colors.

</member>
        <member name="M:cv.LineSegmentDetector.drawSegments(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Draws the line segments on a given image.
    @param _image The image, where the liens will be drawn. Should be bigger or equal to the image,
    where the lines were found.
    @param lines A vector of the lines that needed to be drawn.

</member>
        <member name="M:cv.LineSegmentDetector.detect(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Finds lines in the input image.

    This is the output of the default parameters of the algorithm on the above shown image.

    ![image](pics/building_lsd.png)

    @param _image A grayscale (CV_8UC1) input image. If only a roi needs to be selected, use:
    `lsd_ptr-\&gt;detect(image(roi), lines, ...); lines += Scalar(roi.x, roi.y, roi.x, roi.y);`
    @param _lines A vector of Vec4i or Vec4f elements specifying the beginning and ending point of a line. Where
    Vec4i/Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. Returned lines are strictly
    oriented depending on the gradient.
    @param width Vector of widths of the regions, where the lines are found. E.g. Width of line.
    @param prec Vector of precisions with which the lines are found.
    @param nfa Vector containing number of false alarms in the line region, with precision of 10%. The
    bigger the value, logarithmically better the detection.
    - -1 corresponds to 10 mean false alarms
    - 0 corresponds to 1 mean false alarm
    - 1 corresponds to 0.1 mean false alarms
    This vector will be calculated only when the objects type is LSD_REFINE_ADV.

</member>
        <member name="T:cv.LineSegmentDetector">
@example lsd_lines.cpp
An example using the LineSegmentDetector

@brief Line segment detector class

following the algorithm described at @cite Rafael12 .

</member>
        <member name="T:cv.RectanglesIntersectTypes">
types of intersection between rectangles
@ingroup imgproc_shape

</member>
        <member name="T:cv.ColorConversionCodes">
the color conversion code
@see @ref imgproc_color_conversions
@ingroup imgproc_misc

</member>
        <member name="T:cv.HistCompMethods">
Histogram comparison methods
  @ingroup imgproc_hist

</member>
        <member name="F:HISTCMP_KL_DIV">
Kullback-Leibler divergence
    \f[d(H_1,H_2) = \sum _I H_1(I) \log \left(\frac{H_1(I)}{H_2(I)}\right)\f] 
</member>
        <member name="F:HISTCMP_CHISQR_ALT">
Alternative Chi-Square
    \f[d(H_1,H_2) =  2 * \sum _I  \frac{\left(H_1(I)-H_2(I)\right)^2}{H_1(I)+H_2(I)}\f]
    This alternative formula is regularly used for texture comparison. See e.g. @cite Puzicha1997 
</member>
        <member name="F:HISTCMP_BHATTACHARYYA">
Bhattacharyya distance
    (In fact, OpenCV computes Hellinger distance, which is related to Bhattacharyya coefficient.)
    \f[d(H_1,H_2) =  \sqrt{1 - \frac{1}{\sqrt{\bar{H_1} \bar{H_2} N^2}} \sum_I \sqrt{H_1(I) \cdot H_2(I)}}\f] 
</member>
        <member name="F:HISTCMP_INTERSECT">
Intersection
    \f[d(H_1,H_2) =  \sum _I  \min (H_1(I), H_2(I))\f] 
</member>
        <member name="F:HISTCMP_CHISQR">
Chi-Square
    \f[d(H_1,H_2) =  \sum _I  \frac{\left(H_1(I)-H_2(I)\right)^2}{H_1(I)}\f] 
</member>
        <member name="F:HISTCMP_CORREL">
Correlation
    \f[d(H_1,H_2) =  \frac{\sum_I (H_1(I) - \bar{H_1}) (H_2(I) - \bar{H_2})}{\sqrt{\sum_I(H_1(I) - \bar{H_1})^2 \sum_I(H_2(I) - \bar{H_2})^2}}\f]
    where
    \f[\bar{H_k} =  \frac{1}{N} \sum _J H_k(J)\f]
    and \f$N\f$ is a total number of histogram bins. 
</member>
        <member name="F:HOUGH_MULTI_SCALE">
multi-scale variant of the classical Hough transform. The lines are encoded the same way as
    HOUGH_STANDARD. 
</member>
        <member name="F:HOUGH_PROBABILISTIC">
probabilistic Hough transform (more efficient in case if the picture contains a few long
    linear segments). It returns line segments rather than the whole line. Each segment is
    represented by starting and ending points, and the matrix must be (the created sequence will
    be) of the CV_32SC4 type. 
</member>
        <member name="F:HOUGH_STANDARD">
classical or standard Hough transform. Every line is represented by two floating-point
    numbers \f$(\rho, \theta)\f$ , where \f$\rho\f$ is a distance between (0,0) point and the line,
    and \f$\theta\f$ is the angle between x-axis and the normal to the line. Thus, the matrix must
    be (the created sequence will be) of CV_32FC2 type 
</member>
        <member name="F:CHAIN_APPROX_TC89_KCOS">
applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 
</member>
        <member name="F:CHAIN_APPROX_TC89_L1">
applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 
</member>
        <member name="F:CHAIN_APPROX_SIMPLE">
compresses horizontal, vertical, and diagonal segments and leaves only their end points.
    For example, an up-right rectangular contour is encoded with 4 points. 
</member>
        <member name="F:CHAIN_APPROX_NONE">
stores absolutely all the contour points. That is, any 2 subsequent points (x1,y1) and
    (x2,y2) of the contour will be either horizontal, vertical or diagonal neighbors, that is,
    max(abs(x1-x2),abs(y2-y1))==1. 
</member>
        <member name="F:RETR_TREE">
retrieves all of the contours and reconstructs a full hierarchy of nested contours.
</member>
        <member name="F:RETR_CCOMP">
retrieves all of the contours and organizes them into a two-level hierarchy. At the top
    level, there are external boundaries of the components. At the second level, there are
    boundaries of the holes. If there is another contour inside a hole of a connected component, it
    is still put at the top level. 
</member>
        <member name="F:RETR_LIST">
retrieves all of the contours without establishing any hierarchical relationships. 
</member>
        <member name="F:RETR_EXTERNAL">
retrieves only the extreme outer contours. It sets `hierarchy[i][2]=hierarchy[i][3]=-1` for
    all the contours. 
</member>
        <member name="F:FLOODFILL_MASK_ONLY">
If set, the function does not change the image ( newVal is ignored), and only fills the
    mask with the value specified in bits 8-16 of flags as described above. This option only make
    sense in function variants that have the mask parameter. 
</member>
        <member name="F:FLOODFILL_FIXED_RANGE">
If set, the difference between the current pixel and seed pixel is considered. Otherwise,
    the difference between neighbor pixels is considered (that is, the range is floating). 
</member>
        <member name="F:DIST_LABEL_PIXEL">
each zero pixel (and all the non-zero pixels closest to it) gets its own label. 
</member>
        <member name="F:DIST_LABEL_CCOMP">
each connected component of zeros in src (as well as all the non-zero pixels closest to the
    connected component) will be assigned the same label 
</member>
        <member name="F:GC_EVAL">
The value means that the algorithm should just resume. 
</member>
        <member name="F:GC_INIT_WITH_MASK">
The function initializes the state using the provided mask. Note that GC_INIT_WITH_RECT
    and GC_INIT_WITH_MASK can be combined. Then, all the pixels outside of the ROI are
    automatically initialized with GC_BGD .
</member>
        <member name="F:GC_INIT_WITH_RECT">
The function initializes the state and the mask using the provided rectangle. After that it
    runs iterCount iterations of the algorithm. 
</member>
        <member name="F:ADAPTIVE_THRESH_GAUSSIAN_C">
the threshold value \f$T(x, y)\f$ is a weighted sum (cross-correlation with a Gaussian
    window) of the \f$\texttt{blockSize} \times \texttt{blockSize}\f$ neighborhood of \f$(x, y)\f$
    minus C . The default sigma (standard deviation) is used for the specified blockSize . See
    cv::getGaussianKernel
</member>
        <member name="F:ADAPTIVE_THRESH_MEAN_C">
the threshold value \f$T(x,y)\f$ is a mean of the \f$\texttt{blockSize} \times
    \texttt{blockSize}\f$ neighborhood of \f$(x, y)\f$ minus C 
</member>
        <member name="F:WARP_INVERSE_MAP">
flag, inverse transformation

    For example, polar transforms:
    - flag is __not__ set: \f$dst( \phi , \rho ) = src(x,y)\f$
    - flag is set: \f$dst(x,y) = src( \phi , \rho )\f$

</member>
        <member name="F:WARP_FILL_OUTLIERS">
flag, fills all of the destination image pixels. If some of them correspond to outliers in the
    source image, they are set to zero 
</member>
        <member name="F:INTER_MAX">
mask for interpolation codes 
</member>
        <member name="F:INTER_LANCZOS4">
Lanczos interpolation over 8x8 neighborhood 
</member>
        <member name="F:INTER_AREA">
resampling using pixel area relation. It may be a preferred method for image decimation, as
    it gives moire'-free results. But when the image is zoomed, it is similar to the INTER_NEAREST
    method. 
</member>
        <member name="F:INTER_CUBIC">
bicubic interpolation 
</member>
        <member name="F:INTER_LINEAR">
bilinear interpolation 
</member>
        <member name="F:INTER_NEAREST">
nearest neighbor interpolation 
</member>
        <member name="T:cv.MorphTypes">
@addtogroup imgproc
@{

</member>
        <member name="M:cv.ConjGradSolver.create(cv.Ptr&lt;cv.MinProblemSolver.Function&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.TermCriteria)">
@brief This function returns the reference to the ready-to-use ConjGradSolver object.

    All the parameters are optional, so this procedure can be called even without parameters at
    all. In this case, the default values will be used. As default value for terminal criteria are
    the only sensible ones, MinProblemSolver::setFunction() should be called upon the obtained
    object, if the function was not given to create(). Otherwise, the two ways (submit it to
    create() or miss it out and call the MinProblemSolver::setFunction()) are absolutely equivalent
    (and will drop the same errors in the same way, should invalid input be detected).
    @param f Pointer to the function that will be minimized, similarly to the one you submit via
    MinProblemSolver::setFunction.
    @param termcrit Terminal criteria to the algorithm, similarly to the one you submit via
    MinProblemSolver::setTermCriteria.

</member>
        <member name="M:cv.DownhillSolver.create(cv.Ptr&lt;cv.MinProblemSolver.Function&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.TermCriteria)">
@brief This function returns the reference to the ready-to-use DownhillSolver object.

    All the parameters are optional, so this procedure can be called even without parameters at
    all. In this case, the default values will be used. As default value for terminal criteria are
    the only sensible ones, MinProblemSolver::setFunction() and DownhillSolver::setInitStep()
    should be called upon the obtained object, if the respective parameters were not given to
    create(). Otherwise, the two ways (give parameters to createDownhillSolver() or miss them out
    and call the MinProblemSolver::setFunction() and DownhillSolver::setInitStep()) are absolutely
    equivalent (and will drop the same errors in the same way, should invalid input be detected).
    @param f Pointer to the function that will be minimized, similarly to the one you submit via
    MinProblemSolver::setFunction.
    @param initStep Initial step, that will be used to construct the initial simplex, similarly to the one
    you submit via MinProblemSolver::setInitStep.
    @param termcrit Terminal criteria to the algorithm, similarly to the one you submit via
    MinProblemSolver::setTermCriteria.

</member>
        <member name="M:cv.DownhillSolver.getInitStep(cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Returns the initial step that will be used in downhill simplex algorithm.

    @param step Initial step that will be used in algorithm. Note, that although corresponding setter
    accepts column-vectors as well as row-vectors, this method will return a row-vector.
    @see DownhillSolver::setInitStep

</member>
        <member name="M:cv.MinProblemSolver.minimize(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief actually runs the algorithm and performs the minimization.

    The sole input parameter determines the centroid of the starting simplex (roughly, it tells
    where to start), all the others (terminal criteria, initial step, function to be minimized) are
    supposed to be set via the setters before the call to this method or the default values (not
    always sensible) will be used.

    @param x The initial point, that will become a centroid of an initial simplex. After the algorithm
    will terminate, it will be setted to the point where the algorithm stops, the point of possible
    minimum.
    @return The value of a function at the point found.

</member>
        <member name="M:cv.MinProblemSolver.setTermCriteria(cv.TermCriteria!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set terminal criteria for solver.

    This method *is not necessary* to be called before the first call to minimize(), as the default
    value is sensible.

    Algorithm stops when the number of function evaluations done exceeds termcrit.maxCount, when
    the function values at the vertices of simplex are within termcrit.epsilon range or simplex
    becomes so small that it can enclosed in a box with termcrit.epsilon sides, whatever comes
    first.
    @param termcrit Terminal criteria to be used, represented as cv::TermCriteria structure.

</member>
        <member name="M:cv.MinProblemSolver.getTermCriteria">
@brief Getter for the previously set terminal criteria for this algorithm.

    @return Deep copy of the terminal criteria used at the moment.

</member>
        <member name="M:cv.MinProblemSolver.setFunction(cv.Ptr&lt;cv.MinProblemSolver.Function&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Setter for the optimized function.

    *It should be called at least once before the call to* minimize(), as default value is not usable.

    @param f The new function to optimize.

</member>
        <member name="M:cv.MinProblemSolver.getFunction">
@brief Getter for the optimized function.

    The optimized function is represented by Function interface, which requires derivatives to
    implement the sole method calc(double*) to evaluate the function.

    @return Smart-pointer to an object that implements Function interface - it represents the
    function that is being optimized. It can be empty, if no function was given so far.

</member>
        <member name="T:cv.MinProblemSolver.Function">
@brief Represents function being optimized

</member>
        <member name="T:cv.MinProblemSolver">
@addtogroup core_optim
The algorithms in this section minimize or maximize function value within specified constraints or
without any constraints.
@{

@brief Basic interface for all solvers

</member>
        <member name="M:cvGuiBoxReport(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Void*)">
Output to MessageBox(WIN32) 
</member>
        <member name="M:cvStdErrReport(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Void*)">
Output to console(fprintf(stderr,...)) 
</member>
        <member name="M:cvNulDevReport(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Void*)">
Output nothing 
</member>
        <member name="M:cvRedirectError(=FUNC:System.Int32(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Void*),System.Void*,System.Void**)">
Assigns a new error-handling function 
</member>
        <member name="M:cvErrorFromIppStatus(System.Int32)">
Maps IPP error codes to the counterparts from OpenCV 
</member>
        <member name="M:cvGetErrInfo(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**,System.Int32*)">
Retrieves detailed information about the last error occured 
</member>
        <member name="M:cvErrorStr(System.Int32)">
Retrieves textual description of the error given its code 
</member>
        <member name="M:cvError(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Sets error status and performs some additonal actions (displaying message box,
 writing message to stderr, terminating application etc.)
 depending on the current error mode 
</member>
        <member name="M:cvSetErrMode(System.Int32)">
Sets error processing mode, returns previously used mode 
</member>
        <member name="M:cvGetErrMode">
Retrives current error processing mode 
</member>
        <member name="M:cvSetErrStatus(System.Int32)">
Sets error status silently 
</member>
        <member name="M:cvGetErrStatus">
Get current OpenCV error status 
</member>
        <member name="M:cvGetThreadNum">
get index of the thread being executed 
</member>
        <member name="M:cvGetNumThreads">
retrieve/set the number of threads used in OpenMP implementations 
</member>
        <member name="M:cvGetTickCount">
helper functions for RNG initialization and accurate time measurement:
   uses internal clock counter on x86 
</member>
        <member name="M:cvLoad(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,CvMemStorage*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**)">
@brief Loads an object from a file.

The function loads an object from a file. It basically reads the specified file, find the first
top-level node and calls cvRead for that node. If the file node does not have type information or
the type information can not be found by the type name, the function returns NULL. After the object
is loaded, the file storage is closed and all the temporary buffers are deleted. Thus, to load a
dynamic structure, such as a sequence, contour, or graph, one should pass a valid memory storage
destination to the function.
@param filename File name
@param memstorage Memory storage for dynamic structures, such as CvSeq or CvGraph . It is not used
for matrices or images.
@param name Optional object name. If it is NULL, the first top-level object in the storage will be
loaded.
@param real_name Optional output parameter that will contain the name of the loaded object
(useful if name=NULL )

</member>
        <member name="M:cvSave(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,CvAttrList)">
@brief Saves an object to a file.

The function saves an object to a file. It provides a simple interface to cvWrite .
@param filename File name
@param struct_ptr Object to save
@param name Optional object name. If it is NULL, the name will be formed from filename .
@param comment Optional comment to put in the beginning of the file
@param attributes Optional attributes passed to cvWrite

</member>
        <member name="M:cvClone(System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Makes a clone of an object.

The function finds the type of a given object and calls clone with the passed object. Of course, if
you know the object type, for example, struct_ptr is CvMat\*, it is faster to call the specific
function, like cvCloneMat.
@param struct_ptr The object to clone

</member>
        <member name="M:cvRelease(System.Void**)">
@brief Releases an object.

The function finds the type of a given object and calls release with the double pointer.
@param struct_ptr Double pointer to the object

</member>
        <member name="M:cvTypeOf(System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Returns the type of an object.

The function finds the type of a given object. It iterates through the list of registered types and
calls the is_instance function/method for every type info structure with that object until one of
them returns non-zero or until the whole list has been traversed. In the latter case, the function
returns NULL.
@param struct_ptr The object pointer

</member>
        <member name="M:cvFindType(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief Finds a type by its name.

The function finds a registered type by its name. It returns NULL if there is no type with the
specified name.
@param type_name Type name

</member>
        <member name="M:cvFirstType">
@brief Returns the beginning of a type list.

The function returns the first type in the list of registered types. Navigation through the list can
be done via the prev and next fields of the CvTypeInfo structure.

</member>
        <member name="M:cvUnregisterType(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief Unregisters the type.

The function unregisters a type with a specified name. If the name is unknown, it is possible to
locate the type info by an instance of the type using cvTypeOf or by iterating the type list,
starting from cvFirstType, and then calling cvUnregisterType(info-\&gt;typeName).
@param type_name Name of an unregistered type

</member>
        <member name="M:cvRegisterType(CvTypeInfo!System.Runtime.CompilerServices.IsConst*)">
@brief Registers a new type.

The function registers a new type, which is described by info . The function creates a copy of the
structure, so the user should delete it after calling the function.
@param info Type info structure

</member>
        <member name="M:cvGetFileNodeName(CvFileNode!System.Runtime.CompilerServices.IsConst*)">
@brief Returns the name of a file node.

The function returns the name of a file node or NULL, if the file node does not have a name or if
node is NULL.
@param node File node

</member>
        <member name="M:cvWriteFileNode(CvFileStorage*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,CvFileNode!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Writes a file node to another file storage.

The function writes a copy of a file node to file storage. Possible applications of the function are
merging several file storages into one and conversion between XML and YAML formats.
@param fs Destination file storage
@param new_node_name New name of the file node in the destination file storage. To keep the
existing name, use cvcvGetFileNodeName
@param node The written node
@param embed If the written node is a collection and this parameter is not zero, no extra level of
hierarchy is created. Instead, all the elements of node are written into the currently written
structure. Of course, map elements can only be embedded into another map, and sequence elements
can only be embedded into another sequence.

</member>
        <member name="M:cvReadRawData(CvFileStorage!System.Runtime.CompilerServices.IsConst*,CvFileNode!System.Runtime.CompilerServices.IsConst*,System.Void*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief Reads multiple numbers.

The function reads elements from a file node that represents a sequence of scalars.
@param fs File storage
@param src The file node (a sequence) to read numbers from
@param dst Pointer to the destination array
@param dt Specification of each array element. It has the same format as in cvWriteRawData .

</member>
        <member name="M:cvReadRawDataSlice(CvFileStorage!System.Runtime.CompilerServices.IsConst*,CvSeqReader*,System.Int32,System.Void*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief Initializes file node sequence reader.

The function reads one or more elements from the file node, representing a sequence, to a
user-specified array. The total number of read sequence elements is a product of total and the
number of components in each array element. For example, if dt=2if, the function will read total\*3
sequence elements. As with any sequence, some parts of the file node sequence can be skipped or read
repeatedly by repositioning the reader using cvSetSeqReaderPos.
@param fs File storage
@param reader The sequence reader. Initialize it with cvStartReadRawData .
@param count The number of elements to read
@param dst Pointer to the destination array
@param dt Specification of each array element. It has the same format as in cvWriteRawData .

</member>
        <member name="M:cvStartReadRawData(CvFileStorage!System.Runtime.CompilerServices.IsConst*,CvFileNode!System.Runtime.CompilerServices.IsConst*,CvSeqReader*)">
@brief Initializes the file node sequence reader.

The function initializes the sequence reader to read data from a file node. The initialized reader
can be then passed to cvReadRawDataSlice.
@param fs File storage
@param src The file node (a sequence) to read numbers from
@param reader Pointer to the sequence reader

</member>
        <member name="M:cvReadByName(CvFileStorage*,CvFileNode!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,CvAttrList*)">
@brief Finds an object by name and decodes it.

The function is a simple superposition of cvGetFileNodeByName and cvRead.
@param fs File storage
@param map The parent map. If it is NULL, the function searches a top-level node.
@param name The node name
@param attributes Unused parameter

</member>
        <member name="M:cvRead(CvFileStorage*,CvFileNode*,CvAttrList*)">
@brief Decodes an object and returns a pointer to it.

The function decodes a user object (creates an object in a native representation from the file
storage subtree) and returns it. The object to be decoded must be an instance of a registered type
that supports the read method (see CvTypeInfo). The type of the object is determined by the type
name that is encoded in the file. If the object is a dynamic structure, it is created either in
memory storage and passed to cvOpenFileStorage or, if a NULL pointer was passed, in temporary
memory storage, which is released when cvReleaseFileStorage is called. Otherwise, if the object is
not a dynamic structure, it is created in a heap and should be released with a specialized function
or by using the generic cvRelease.
@param fs File storage
@param node The root object node
@param attributes Unused parameter

</member>
        <member name="M:cvReadStringByName(CvFileStorage!System.Runtime.CompilerServices.IsConst*,CvFileNode!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief Finds a file node by its name and returns its value.

The function is a simple superposition of cvGetFileNodeByName and cvReadString .
@param fs File storage
@param map The parent map. If it is NULL, the function searches a top-level node.
@param name The node name
@param default_value The value that is returned if the file node is not found

</member>
        <member name="M:cvReadString(CvFileNode!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief Retrieves a text string from a file node.

The function returns a text string that is represented by the file node. If the file node is NULL,
the default_value is returned (thus, it is convenient to call the function right after
cvGetFileNode without checking for a NULL pointer). If the file node has type CV_NODE_STR , then
node-:math:\&gt;data.str.ptr is returned. Otherwise the result is not determined.
@param node File node
@param default_value The value that is returned if node is NULL

</member>
        <member name="M:cvReadRealByName(CvFileStorage!System.Runtime.CompilerServices.IsConst*,CvFileNode!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double)">
@brief Finds a file node and returns its value.

The function is a simple superposition of cvGetFileNodeByName and cvReadReal .
@param fs File storage
@param map The parent map. If it is NULL, the function searches a top-level node.
@param name The node name
@param default_value The value that is returned if the file node is not found

</member>
        <member name="M:cvReadReal(CvFileNode!System.Runtime.CompilerServices.IsConst*,System.Double)">
@brief Retrieves a floating-point value from a file node.

The function returns a floating-point value that is represented by the file node. If the file node
is NULL, the default_value is returned (thus, it is convenient to call the function right after
cvGetFileNode without checking for a NULL pointer). If the file node has type CV_NODE_REAL ,
then node-\&gt;data.f is returned. If the file node has type CV_NODE_INT , then node-:math:\&gt;data.f
is converted to floating-point and returned. Otherwise the result is not determined.
@param node File node
@param default_value The value that is returned if node is NULL

</member>
        <member name="M:cvReadIntByName(CvFileStorage!System.Runtime.CompilerServices.IsConst*,CvFileNode!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Finds a file node and returns its value.

The function is a simple superposition of cvGetFileNodeByName and cvReadInt.
@param fs File storage
@param map The parent map. If it is NULL, the function searches a top-level node.
@param name The node name
@param default_value The value that is returned if the file node is not found

</member>
        <member name="M:cvReadInt(CvFileNode!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Retrieves an integer value from a file node.

The function returns an integer that is represented by the file node. If the file node is NULL, the
default_value is returned (thus, it is convenient to call the function right after cvGetFileNode
without checking for a NULL pointer). If the file node has type CV_NODE_INT, then node-\&gt;data.i is
returned. If the file node has type CV_NODE_REAL, then node-\&gt;data.f is converted to an integer
and returned. Otherwise the error is reported.
@param node File node
@param default_value The value that is returned if node is NULL

</member>
        <member name="M:cvGetFileNodeByName(CvFileStorage!System.Runtime.CompilerServices.IsConst*,CvFileNode!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief Finds a node in a map or file storage.

The function finds a file node by name. The node is searched either in map or, if the pointer is
NULL, among the top-level file storage nodes. Using this function for maps and cvGetSeqElem (or
sequence reader) for sequences, it is possible to navigate through the file storage. To speed up
multiple queries for a certain key (e.g., in the case of an array of structures) one may use a
combination of cvGetHashedKey and cvGetFileNode.
@param fs File storage
@param map The parent map. If it is NULL, the function searches in all the top-level nodes
(streams), starting with the first one.
@param name The file node name

</member>
        <member name="M:cvGetFileNode(CvFileStorage*,CvFileNode*,CvStringHashNode!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Finds a node in a map or file storage.

The function finds a file node. It is a faster version of cvGetFileNodeByName (see
cvGetHashedKey discussion). Also, the function can insert a new node, if it is not in the map yet.
@param fs File storage
@param map The parent map. If it is NULL, the function searches a top-level node. If both map and
key are NULLs, the function returns the root file node - a map that contains top-level nodes.
@param key Unique pointer to the node name, retrieved with cvGetHashedKey
@param create_missing Flag that specifies whether an absent node should be added to the map

</member>
        <member name="M:cvGetRootFileNode(CvFileStorage!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Retrieves one of the top-level nodes of the file storage.

The function returns one of the top-level file nodes. The top-level nodes do not have a name, they
correspond to the streams that are stored one after another in the file storage. If the index is out
of range, the function returns a NULL pointer, so all the top-level nodes can be iterated by
subsequent calls to the function with stream_index=0,1,..., until the NULL pointer is returned.
This function can be used as a base for recursive traversal of the file storage.
@param fs File storage
@param stream_index Zero-based index of the stream. See cvStartNextStream . In most cases,
there is only one stream in the file; however, there can be several.

</member>
        <member name="M:cvWriteRawData(CvFileStorage*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief Writes multiple numbers.

The function writes an array, whose elements consist of single or multiple numbers. The function
call can be replaced with a loop containing a few cvWriteInt and cvWriteReal calls, but a single
call is more efficient. Note that because none of the elements have a name, they should be written
to a sequence rather than a map.
@param fs File storage
@param src Pointer to the written array
@param len Number of the array elements to write
@param dt Specification of each array element, see @ref format_spec "format specification"

</member>
        <member name="M:cvStartNextStream(CvFileStorage*)">
@brief Starts the next stream.

The function finishes the currently written stream and starts the next stream. In the case of XML
the file with multiple streams looks like this:
@code{.xml}
    <opencv_storage><!-- stream #1 data --></opencv_storage><opencv_storage><!-- stream #2 data --></opencv_storage>
    ...
@endcode
The YAML file will look like this:
@code{.yaml}
    %YAML:1.0
    # stream #1 data
    ...
    ---
    # stream #2 data
@endcode
This is useful for concatenating files or for resuming the writing process.
@param fs File storage

</member>
        <member name="M:cvWriteComment(CvFileStorage*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Writes a comment.

The function writes a comment into file storage. The comments are skipped when the storage is read.
@param fs File storage
@param comment The written comment, single-line or multi-line
@param eol_comment If non-zero, the function tries to put the comment at the end of current line.
If the flag is zero, if the comment is multi-line, or if it does not fit at the end of the current
line, the comment starts a new line.

</member>
        <member name="M:cvWriteString(CvFileStorage*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Writes a text string.

The function writes a text string to file storage.
@param fs File storage
@param name Name of the written string . Should be NULL if and only if the parent structure is a
sequence.
@param str The written text string
@param quote If non-zero, the written string is put in quotes, regardless of whether they are
required. Otherwise, if the flag is zero, quotes are used only when they are required (e.g. when
the string starts with a digit or contains spaces).

</member>
        <member name="M:cvWriteInt(CvFileStorage*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Writes an integer value.

The function writes a single integer value (with or without a name) to the file storage.
@param fs File storage
@param name Name of the written value. Should be NULL if and only if the parent structure is a
sequence.
@param value The written value

</member>
        <member name="M:cvEndWriteStruct(CvFileStorage*)">
@brief Finishes writing to a file node collection.
@param fs File storage
@sa cvStartWriteStruct.

</member>
        <member name="M:cvStartWriteStruct(CvFileStorage*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,CvAttrList)">
@brief Starts writing a new structure.

The function starts writing a compound structure (collection) that can be a sequence or a map. After
all the structure fields, which can be scalars or structures, are written, cvEndWriteStruct should
be called. The function can be used to group some objects or to implement the write function for a
some user object (see CvTypeInfo).
@param fs File storage
@param name Name of the written structure. The structure can be accessed by this name when the
storage is read.
@param struct_flags A combination one of the following values:
-   **CV_NODE_SEQ** the written structure is a sequence (see discussion of CvFileStorage ),
    that is, its elements do not have a name.
-   **CV_NODE_MAP** the written structure is a map (see discussion of CvFileStorage ), that
    is, all its elements have names.
One and only one of the two above flags must be specified
-   **CV_NODE_FLOW** the optional flag that makes sense only for YAML streams. It means that
     the structure is written as a flow (not as a block), which is more compact. It is
     recommended to use this flag for structures or arrays whose elements are all scalars.
@param type_name Optional parameter - the object type name. In
    case of XML it is written as a type_id attribute of the structure opening tag. In the case of
    YAML it is written after a colon following the structure name (see the example in
    CvFileStorage description). Mainly it is used with user objects. When the storage is read, the
    encoded type name is used to determine the object type (see CvTypeInfo and cvFindType ).
@param attributes This parameter is not used in the current implementation

</member>
        <member name="M:cvAttrValue(CvAttrList!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
returns attribute value or 0 (NULL) if there is no such attribute 
</member>
        <member name="M:cvReleaseFileStorage(CvFileStorage**)">
@brief Releases file storage.

The function closes the file associated with the storage and releases all the temporary structures.
It must be called after all I/O operations with the storage are finished.
@param fs Double pointer to the released file storage

</member>
        <member name="M:cvOpenFileStorage(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,CvMemStorage*,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief Opens file storage for reading or writing data.

The function opens file storage for reading or writing data. In the latter case, a new file is
created or an existing file is rewritten. The type of the read or written file is determined by the
filename extension: .xml for XML and .yml or .yaml for YAML. The function returns a pointer to the
CvFileStorage structure. If the file cannot be opened then the function returns NULL.
@param filename Name of the file associated with the storage
@param memstorage Memory storage used for temporary data and for
:   storing dynamic structures, such as CvSeq or CvGraph . If it is NULL, a temporary memory
    storage is created and used.
@param flags Can be one of the following:
&gt; -   **CV_STORAGE_READ** the storage is open for reading
&gt; -   **CV_STORAGE_WRITE** the storage is open for writing
@param encoding

</member>
        <member name="M:cvSetIPLAllocators(=FUNC:_IplImage*(System.Int32,System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,_IplROI*,_IplImage*,System.Void*,_IplTileInfo*),=FUNC:System.Void(_IplImage*,System.Int32,System.Int32),=FUNC:System.Void(_IplImage*,System.Int32),=FUNC:_IplROI*(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32),=FUNC:_IplImage*(_IplImage!System.Runtime.CompilerServices.IsConst*))">
@brief Makes OpenCV use IPL functions for allocating IplImage and IplROI structures.

Normally, the function is not called directly. Instead, a simple macro
CV_TURN_ON_IPL_COMPATIBILITY() is used that calls cvSetIPLAllocators and passes there pointers
to IPL allocation functions. :
@code
    ...
    CV_TURN_ON_IPL_COMPATIBILITY()
    ...
@endcode
@param create_header pointer to a function, creating IPL image header.
@param allocate_data pointer to a function, allocating IPL image data.
@param deallocate pointer to a function, deallocating IPL image.
@param create_roi pointer to a function, creating IPL image ROI (i.e. Region of Interest).
@param clone_image pointer to a function, cloning an IPL image.

</member>
        <member name="M:cvUseOptimized(System.Int32)">
Loads optimized functions from IPP, MKL etc. or switches back to pure C code 
</member>
        <member name="M:cvKMeans2(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Void*,CvTermCriteria,System.Int32,System.UInt64*,System.Int32,System.Void*,System.Double*)">
The function implements the K-means algorithm for clustering an array of sample
   vectors in a specified number of classes 
</member>
        <member name="M:cvTreeToNodeSeq(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,CvMemStorage*)">
Gathers pointers to all the sequences,
   accessible from the `first`, to the single sequence 
</member>
        <member name="M:cvRemoveNodeFromTree(System.Void*,System.Void*)">
Removes contour from tree (together with the contour children). 
</member>
        <member name="M:cvInsertNodeIntoTree(System.Void*,System.Void*,System.Void*)">
Inserts sequence into tree with specified "parent" sequence.
   If parent is equal to frame (e.g. the most external contour),
   then added contour will have null pointer to parent. 
</member>
        <member name="M:cvLUT(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
Does look-up transformation. Elements of the source array
   (that should be 8uC1 or 8sC1) are used as indexes in lutarr 256-element table 
</member>
        <member name="M:cvCloneGraph(CvGraph!System.Runtime.CompilerServices.IsConst*,CvMemStorage*)">
Creates a copy of graph 
</member>
        <member name="M:cvNextGraphItem(CvGraphScanner*)">
Get next graph element 
</member>
        <member name="M:cvReleaseGraphScanner(CvGraphScanner**)">
Releases graph scanner. 
</member>
        <member name="M:cvCreateGraphScanner(CvGraph*,CvGraphVtx*,System.Int32)">
Creates new graph scanner. 
</member>
        <member name="T:CvGraphScanner">
Retrieves graph vertex by given index 
Retrieves index of a graph vertex given its pointer 
Retrieves index of a graph edge given its pointer 
flags for graph vertices and edges 
</member>
        <member name="M:cvGraphVtxDegree(CvGraph!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Count number of edges incident to the vertex 
</member>
        <member name="M:cvClearGraph(CvGraph*)">
Remove all vertices and edges from the graph 
</member>
        <member name="M:cvFindGraphEdge(CvGraph!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
Find edge connecting two vertices 
</member>
        <member name="M:cvGraphRemoveEdge(CvGraph*,System.Int32,System.Int32)">
Remove edge connecting two vertices 
</member>
        <member name="M:cvGraphAddEdge(CvGraph*,System.Int32,System.Int32,CvGraphEdge!System.Runtime.CompilerServices.IsConst*,CvGraphEdge**)">
Link two vertices specifed by indices or pointers if they
   are not connected or return pointer to already existing edge
   connecting the vertices.
   Functions return 1 if a new edge was created, 0 otherwise 
</member>
        <member name="M:cvGraphRemoveVtx(CvGraph*,System.Int32)">
Removes vertex from the graph together with all incident edges 
</member>
        <member name="M:cvGraphAddVtx(CvGraph*,CvGraphVtx!System.Runtime.CompilerServices.IsConst*,CvGraphVtx**)">
Adds new vertex to the graph 
</member>
        <member name="M:cvCreateGraph(System.Int32,System.Int32,System.Int32,System.Int32,CvMemStorage*)">
Creates new graph 
</member>
        <member name="M:cvClearSet(CvSet*)">
Removes all the elements from the set 
</member>
        <member name="M:cvGetSetElem(CvSet!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Returns a set element by index. If the element doesn't belong to the set,
   NULL is returned 
</member>
        <member name="M:cvSetRemove(CvSet*,System.Int32)">
Removes element from the set by its index  
</member>
        <member name="M:cvSetRemoveByPtr(CvSet*,System.Void*)">
Removes set element given its pointer 
</member>
        <member name="M:cvSetNew(CvSet*)">
Fast variant of cvSetAdd 
</member>
        <member name="M:cvSetAdd(CvSet*,CvSetElem*,CvSetElem**)">
Adds new element to the set and returns pointer to it 
</member>
        <member name="M:cvCreateSet(System.Int32,System.Int32,System.Int32,CvMemStorage*)">
Creates a new set 
</member>
        <member name="M:cvSeqPartition(CvSeq!System.Runtime.CompilerServices.IsConst*,CvMemStorage*,CvSeq**,=FUNC:System.Int32(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*),System.Void*)">
Splits sequence into one or more equivalence classes using the specified criteria 
</member>
        <member name="M:cvSeqInvert(CvSeq*)">
Reverses order of sequence elements in-place 
</member>
        <member name="M:cvSeqSearch(CvSeq*,System.Void!System.Runtime.CompilerServices.IsConst*,=FUNC:System.Int32(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*),System.Int32,System.Int32*,System.Void*)">
Finds element in a [sorted] sequence 
</member>
        <member name="M:cvSeqSort(CvSeq*,=FUNC:System.Int32(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*),System.Void*)">
Sorts sequence in-place given element comparison function 
</member>
        <member name="M:cvSeqInsertSlice(CvSeq*,System.Int32,System.Void!System.Runtime.CompilerServices.IsConst*)">
Inserts a sequence or array into another sequence 
</member>
        <member name="M:cvSeqRemoveSlice(CvSeq*,CvSlice)">
Removes sequence slice 
</member>
        <member name="M:cvSeqSlice(CvSeq!System.Runtime.CompilerServices.IsConst*,CvSlice,CvMemStorage*,System.Int32)">
Extracts sequence slice (with or without copying sequence elements) 
</member>
        <member name="M:cvMakeSeqHeaderForArray(System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,CvSeq*,CvSeqBlock*)">
Creates sequence header for array.
   After that all the operations on sequences that do not alter the content
   can be applied to the resultant sequence 
</member>
        <member name="M:cvCvtSeqToArray(CvSeq!System.Runtime.CompilerServices.IsConst*,System.Void*,CvSlice)">
Copies sequence content to a continuous piece of memory 
</member>
        <member name="M:cvSetSeqReaderPos(CvSeqReader*,System.Int32,System.Int32)">
Changes sequence reader position. It may seek to an absolute or
   to relative to the current position 
</member>
        <member name="M:cvGetSeqReaderPos(CvSeqReader*)">
Returns current sequence reader position (currently observed sequence element) 
</member>
        <member name="M:cvStartReadSeq(CvSeq!System.Runtime.CompilerServices.IsConst*,CvSeqReader*,System.Int32)">
Initializes sequence reader.
   The sequence can be read in forward or backward direction 
</member>
        <member name="M:cvFlushSeqWriter(CvSeqWriter*)">
Updates sequence header. May be useful to get access to some of previously
   written elements via cvGetSeqElem or sequence reader 
</member>
        <member name="M:cvEndWriteSeq(CvSeqWriter*)">
Closes sequence writer, updates sequence header and returns pointer
   to the resultant sequence
   (which may be useful if the sequence was created using cvStartWriteSeq))

</member>
        <member name="M:cvStartWriteSeq(System.Int32,System.Int32,System.Int32,CvMemStorage*,CvSeqWriter*)">
Combination of cvCreateSeq and cvStartAppendToSeq 
</member>
        <member name="M:cvStartAppendToSeq(CvSeq*,CvSeqWriter*)">
Initializes sequence writer. The new elements will be added to the end of sequence 
</member>
        <member name="M:cvSeqElemIdx(CvSeq!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,CvSeqBlock**)">
Calculates index of the specified sequence element.
   Returns -1 if element does not belong to the sequence 
</member>
        <member name="M:cvGetSeqElem(CvSeq!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Retrieves pointer to specified sequence element.
   Negative indices are supported and mean counting from the end
   (e.g -1 means the last sequence element) 
</member>
        <member name="M:cvClearSeq(CvSeq*)">
Removes all the elements from the sequence. The freed memory
   can be reused later only by the same sequence unless cvClearMemStorage
   or cvRestoreMemStoragePos is called 
</member>
        <member name="M:cvSeqRemove(CvSeq*,System.Int32)">
Removes specified sequence element 
</member>
        <member name="M:cvSeqInsert(CvSeq*,System.Int32,System.Void!System.Runtime.CompilerServices.IsConst*)">
Inserts a new element in the middle of sequence.
   cvSeqInsert(seq,0,elem) == cvSeqPushFront(seq,elem) 
</member>
        <member name="M:cvSeqPopMulti(CvSeq*,System.Void*,System.Int32,System.Int32)">
Removes several elements from the end of sequence and optionally saves them 
</member>
        <member name="M:cvSeqPushMulti(CvSeq*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
Adds several new elements to the end of sequence 
</member>
        <member name="M:cvSeqPopFront(CvSeq*,System.Void*)">
Removes the first element from sequence and optioanally saves it 
</member>
        <member name="M:cvSeqPop(CvSeq*,System.Void*)">
Removes the last element from sequence and optionally saves it 
</member>
        <member name="M:cvSeqPushFront(CvSeq*,System.Void!System.Runtime.CompilerServices.IsConst*)">
Adds new element to the beginning of sequence. Returns pointer to it 
</member>
        <member name="M:cvSeqPush(CvSeq*,System.Void!System.Runtime.CompilerServices.IsConst*)">
Adds new element to the end of sequence. Returns pointer to the element 
</member>
        <member name="M:cvSetSeqBlockSize(CvSeq*,System.Int32)">
Changes default size (granularity) of sequence blocks.
   The default size is ~1Kbyte 
</member>
        <member name="M:cvCreateSeq(System.Int32,System.UInt32,System.UInt32,CvMemStorage*)">
Creates new empty sequence that will reside in the specified storage 
</member>
        <member name="M:cvMemStorageAllocString(CvMemStorage*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Allocates string in memory storage 
</member>
        <member name="M:cvMemStorageAlloc(CvMemStorage*,System.UInt32)">
Allocates continuous buffer of the specified size in the storage 
</member>
        <member name="M:cvRestoreMemStoragePos(CvMemStorage*,CvMemStoragePos*)">
Restore a storage "free memory" position 
</member>
        <member name="M:cvSaveMemStoragePos(CvMemStorage!System.Runtime.CompilerServices.IsConst*,CvMemStoragePos*)">
Remember a storage "free memory" position 
</member>
        <member name="M:cvClearMemStorage(CvMemStorage*)">
Clears memory storage. This is the only way(!!!) (besides cvRestoreMemStoragePos)
   to reuse memory allocated for the storage - cvClearSeq,cvClearSet ...
   do not free any memory.
   A child storage returns all the blocks to the parent when it is cleared 
</member>
        <member name="M:cvReleaseMemStorage(CvMemStorage**)">
Releases memory storage. All the children of a parent must be released before
   the parent. A child storage returns all the blocks to parent when it is released 
</member>
        <member name="M:cvCreateChildMemStorage(CvMemStorage*)">
Creates a memory storage that will borrow memory blocks from parent storage 
</member>
        <member name="M:cvCreateMemStorage(System.Int32)">
Creates new memory storage.
   block_size == 0 means that default,
   somewhat optimal size, is used (currently, it is 64K) 
</member>
        <member name="M:cvSliceLength(CvSlice,CvSeq!System.Runtime.CompilerServices.IsConst*)">
Calculates length of sequence slice (with support of negative indices). 
</member>
        <member name="M:cvDCT(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
Discrete Cosine Transform
@see core_c_DftFlags "flags"

</member>
        <member name="M:cvGetOptimalDFTSize(System.Int32)">
Finds optimal DFT vector size &gt;= size0 
</member>
        <member name="M:cvMulSpectrums(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
Multiply results of DFTs: DFT(X)*DFT(Y) or DFT(X)*conj(DFT(Y))
@see core_c_DftFlags "flags"

</member>
        <member name="M:cvDFT(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Int32)">
@anchor core_c_DftFlags
  @name Flags for cvDFT, cvDCT and cvMulSpectrums
  @{

@} 
Discrete Fourier Transform:
    complex-&gt;complex,
    real-&gt;ccs (forward),
    ccs-&gt;real (inverse)
@see core_c_DftFlags "flags"

</member>
        <member name="M:cvReduce(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Int32)">
@anchor core_c_ReduceFlags
  @name Flags for cvReduce
  @{

@} 
@see @ref core_c_ReduceFlags "flags" 
</member>
        <member name="M:cvNormalize(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Double,System.Double,System.Int32,System.Void!System.Runtime.CompilerServices.IsConst*)">
@see ref core_c_NormFlags "flags" 
</member>
        <member name="M:cvNorm(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Void!System.Runtime.CompilerServices.IsConst*)">
@anchor core_c_NormFlags
  @name Flags for cvNorm and cvNormalize
  @{

@} 
Finds norm, difference norm or relative difference norm for an array (or two arrays)
@see ref core_c_NormFlags "flags"

</member>
        <member name="M:cvMinMaxLoc(System.Void!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Double*,CvPoint*,CvPoint*,System.Void!System.Runtime.CompilerServices.IsConst*)">
Finds global minimum, maximum and their positions 
</member>
        <member name="M:cvAvgSdv(System.Void!System.Runtime.CompilerServices.IsConst*,CvScalar*,CvScalar*,System.Void!System.Runtime.CompilerServices.IsConst*)">
Calculates mean and standard deviation of pixel values 
</member>
        <member name="M:cvAvg(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*)">
Calculates mean value of array elements 
</member>
        <member name="M:cvCountNonZero(System.Void!System.Runtime.CompilerServices.IsConst*)">
Calculates number of non-zero pixels 
</member>
        <member name="M:cvSum(System.Void!System.Runtime.CompilerServices.IsConst*)">
Finds sum of array elements 
</member>
        <member name="M:cvMahalanobis(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*)">
Calculates Mahalanobis(weighted) distance 
</member>
        <member name="M:cvCalcCovarMatrix(System.Void!System.Runtime.CompilerServices.IsConst**,System.Int32,System.Void*,System.Void*,System.Int32)">
  @anchor core_c_CovarFlags
@name Flags for cvCalcCovarMatrix
@see cvCalcCovarMatrix
  @{

flag for cvCalcCovarMatrix, transpose([v1-avg, v2-avg,...]) * [v1-avg,v2-avg,...] 
flag for cvCalcCovarMatrix, [v1-avg, v2-avg,...] * transpose([v1-avg,v2-avg,...]) 
flag for cvCalcCovarMatrix, do not calc average (i.e. mean vector) - use the input vector instead
   (useful for calculating covariance matrix by parts) 
flag for cvCalcCovarMatrix, scale the covariance matrix coefficients by number of the vectors 
flag for cvCalcCovarMatrix, all the input vectors are stored in a single matrix, as its rows 
flag for cvCalcCovarMatrix, all the input vectors are stored in a single matrix, as its columns 
@} 
Calculates covariation matrix for a set of vectors
@see @ref core_c_CovarFlags "flags"

</member>
        <member name="M:cvRange(System.Void*,System.Double,System.Double)">
Fills matrix with given range of numbers 
</member>
        <member name="M:cvSetIdentity(System.Void*,CvScalar)">
* Finds selected eigen values and vectors of a symmetric matrix */
Makes an identity matrix (mat_ij = i == j) 
</member>
        <member name="M:cvEigenVV(System.Void*,System.Void*,System.Void*,System.Double,System.Int32,System.Int32)">
Finds eigen values and vectors of a symmetric matrix 
</member>
        <member name="M:cvTrace(System.Void!System.Runtime.CompilerServices.IsConst*)">
Calculates trace of the matrix (sum of elements on the main diagonal) 
</member>
        <member name="M:cvDet(System.Void!System.Runtime.CompilerServices.IsConst*)">
Calculates determinant of input matrix 
</member>
        <member name="M:cvSolve(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
Solves linear system (src1)*(dst) = (src2)
   (returns 0 if src1 is a singular and CV_LU method is used) 
</member>
        <member name="M:cvInvert(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
Inverts matrix 
</member>
        <member name="M:cvSVBkSb(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
Performs Singular Value Back Substitution (solves A*X = B):
   flags must be the same as in cvSVD 
</member>
        <member name="M:cvSVD(System.Void*,System.Void*,System.Void*,System.Void*,System.Int32)">
Performs Singular Value Decomposition of a matrix 
</member>
        <member name="M:cvFlip(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
Mirror array data around horizontal (flip=0),
   vertical (flip=1) or both(flip=-1) axises:
   cvFlip(src) flips images vertically and sequences horizontally (inplace) 
</member>
        <member name="M:cvCompleteSymm(CvMat*,System.Int32)">
Completes the symmetric matrix from the lower (LtoR=0) or from the upper (LtoR!=0) part 
</member>
        <member name="M:cvTranspose(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
Tranposes matrix. Square matrices can be transposed in-place 
</member>
        <member name="M:cvMulTransposed(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Void!System.Runtime.CompilerServices.IsConst*,System.Double)">
Calculates (A-delta)*(A-delta)^T (order=0) or (A-delta)^T*(A-delta) (order=1) 
</member>
        <member name="M:cvPerspectiveTransform(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvMat!System.Runtime.CompilerServices.IsConst*)">
Does perspective transform on every element of input array 
</member>
        <member name="M:cvTransform(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvMat!System.Runtime.CompilerServices.IsConst*,CvMat!System.Runtime.CompilerServices.IsConst*)">
Transforms each element of source array and stores
   resultant vectors in destination array 
</member>
        <member name="M:cvGEMM(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Double,System.Void!System.Runtime.CompilerServices.IsConst*,System.Double,System.Void*,System.Int32)">
Matrix transform: dst = A*B + C, C is optional 
Extended matrix transform:
   dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T 
</member>
        <member name="M:cvCrossProduct(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
@brief Calculates the cross product of two 3D vectors.

The function calculates the cross product of two 3D vectors:
\f[\texttt{dst} =  \texttt{src1} \times \texttt{src2}\f]
or:
\f[\begin{array}{l} \texttt{dst} _1 =  \texttt{src1} _2  \texttt{src2} _3 -  \texttt{src1} _3  \texttt{src2} _2 \\ \texttt{dst} _2 =  \texttt{src1} _3  \texttt{src2} _1 -  \texttt{src1} _1  \texttt{src2} _3 \\ \texttt{dst} _3 =  \texttt{src1} _1  \texttt{src2} _2 -  \texttt{src1} _2  \texttt{src2} _1 \end{array}\f]
@param src1 The first source vector
@param src2 The second source vector
@param dst The destination vector

</member>
        <member name="M:cvSolvePoly(CvMat!System.Runtime.CompilerServices.IsConst*,CvMat*,System.Int32,System.Int32)">
Finds all real and complex roots of a polynomial equation 
</member>
        <member name="M:cvSolveCubic(CvMat!System.Runtime.CompilerServices.IsConst*,CvMat*)">
Finds real roots of a cubic equation 
</member>
        <member name="M:cvRandArr(System.UInt64*,System.Void*,System.Int32,CvScalar,CvScalar)">
@brief Fills an array with random numbers and updates the RNG state.

The function fills the destination array with uniformly or normally distributed random numbers.
@param rng CvRNG state initialized by cvRNG
@param arr The destination array
@param dist_type Distribution type
&gt; -   **CV_RAND_UNI** uniform distribution
&gt; -   **CV_RAND_NORMAL** normal or Gaussian distribution
@param param1 The first parameter of the distribution. In the case of a uniform distribution it is
the inclusive lower boundary of the random numbers range. In the case of a normal distribution it
is the mean value of the random numbers.
@param param2 The second parameter of the distribution. In the case of a uniform distribution it
is the exclusive upper boundary of the random numbers range. In the case of a normal distribution
it is the standard deviation of the random numbers.
@sa randu, randn, RNG::fill.

</member>
        <member name="M:cvCheckArr(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,System.Double)">
Checks array values for NaNs, Infs or simply for too large numbers
   (if CV_CHECK_RANGE is set). If CV_CHECK_QUIET is set,
   no runtime errors is raised (function returns zero value in case of "bad" values).
   Otherwise cvError is called 
</member>
        <member name="M:cvCbrt(System.Single)">
Fast cubic root calculation 
</member>
        <member name="M:cvFastArctan(System.Single,System.Single)">
Fast arctangent calculation 
</member>
        <member name="M:cvLog(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
Calculates natural logarithms: dst(idx) = log(abs(src(idx))).
   Logarithm of 0 gives large negative number(~-700)
   Maximal relative error is ~3e-7 for single-precision output

</member>
        <member name="M:cvExp(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
Does exponention: dst(idx) = exp(src(idx)).
   Overflow is not handled yet. Underflow is handled.
   Maximal relative error is ~7e-6 for single-precision input 
</member>
        <member name="M:cvPow(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Double)">
Does powering: dst(idx) = src(idx)^power 
</member>
        <member name="M:cvPolarToCart(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void*,System.Int32)">
Does polar-&gt;cartesian coordinates conversion.
   Either of output components (magnitude or angle) is optional.
   If magnitude is missing it is assumed to be all 1's 
</member>
        <member name="M:cvCartToPolar(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void*,System.Int32)">
Does cartesian-&gt;polar coordinates conversion.
   Either of output components (magnitude or angle) is optional 
</member>
        <member name="M:cvAbsDiffS(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvScalar)">
dst(x,y,c) = abs(src(x,y,c) - value(c)) 
</member>
        <member name="M:cvAbsDiff(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
dst(x,y,c) = abs(src1(x,y,c) - src2(x,y,c)) 
</member>
        <member name="M:cvMaxS(System.Void!System.Runtime.CompilerServices.IsConst*,System.Double,System.Void*)">
dst(idx) = max(src(idx),value) 
</member>
        <member name="M:cvMinS(System.Void!System.Runtime.CompilerServices.IsConst*,System.Double,System.Void*)">
dst(idx) = min(src(idx),value) 
</member>
        <member name="M:cvMax(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
dst(idx) = max(src1(idx),src2(idx)) 
</member>
        <member name="M:cvMin(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
dst(idx) = min(src1(idx),src2(idx)) 
</member>
        <member name="M:cvCmpS(System.Void!System.Runtime.CompilerServices.IsConst*,System.Double,System.Void*,System.Int32)">
dst(idx) = src1(idx) _cmp_op_ value 
</member>
        <member name="M:cvCmp(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
The comparison operation support single-channel arrays only.
   Destination image should be 8uC1 or 8sC1 
dst(idx) = src1(idx) _cmp_op_ src2(idx) 
</member>
        <member name="M:cvNot(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
dst(idx) = ~src(idx) 
</member>
        <member name="M:cvXorS(System.Void!System.Runtime.CompilerServices.IsConst*,CvScalar,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
dst(idx) = src(idx) ^ value 
</member>
        <member name="M:cvXor(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
dst(idx) = src1(idx) ^ src2(idx) 
</member>
        <member name="M:cvOrS(System.Void!System.Runtime.CompilerServices.IsConst*,CvScalar,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
dst(idx) = src(idx) | value 
</member>
        <member name="M:cvOr(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
dst(idx) = src1(idx) | src2(idx) 
</member>
        <member name="M:cvDotProduct(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Calculates the dot product of two arrays in Euclidean metrics.

The function calculates and returns the Euclidean dot product of two arrays.

\f[src1  \bullet src2 =  \sum _I ( \texttt{src1} (I)  \texttt{src2} (I))\f]

In the case of multiple channel arrays, the results for all channels are accumulated. In particular,
cvDotProduct(a,a) where a is a complex vector, will return \f$||\texttt{a}||^2\f$. The function can
process multi-dimensional arrays, row by row, layer by layer, and so on.
@param src1 The first source array
@param src2 The second source array

</member>
        <member name="M:cvAddWeighted(System.Void!System.Runtime.CompilerServices.IsConst*,System.Double,System.Void!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double,System.Void*)">
dst = src1 * alpha + src2 * beta + gamma 
</member>
        <member name="M:cvScaleAdd(System.Void!System.Runtime.CompilerServices.IsConst*,CvScalar,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
dst = src1 * scale + src2 
</member>
        <member name="M:cvDiv(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Double)">
element-wise division/inversion with scaling:
    dst(idx) = src1(idx) * scale / src2(idx)
    or dst(idx) = scale / src2(idx) if src1 == 0 
</member>
        <member name="M:cvMul(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Double)">
dst(idx) = src1(idx) * src2(idx) * scale
   (scaled element-wise multiplication of 2 arrays) 
</member>
        <member name="M:cvSubRS(System.Void!System.Runtime.CompilerServices.IsConst*,CvScalar,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
dst(mask) = value - src(mask) 
</member>
        <member name="M:cvSubS(System.Void!System.Runtime.CompilerServices.IsConst*,CvScalar,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
dst(mask) = src(mask) - value = src(mask) + (-value) 
</member>
        <member name="M:cvSub(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
dst(mask) = src1(mask) - src2(mask) 
</member>
        <member name="M:cvAddS(System.Void!System.Runtime.CompilerServices.IsConst*,CvScalar,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
dst(mask) = src(mask) + value 
</member>
        <member name="M:cvAdd(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
dst(mask) = src1(mask) + src2(mask) 
</member>
        <member name="M:cvCheckTermCriteria(CvTermCriteria,System.Double,System.Int32)">
checks termination criteria validity and
   sets eps to default_eps (if it is not set),
   max_iter to default_max_iters (if it is not set)

</member>
        <member name="M:cvConvertScaleAbs(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Double,System.Double)">
Performs linear transformation on every source array element,
   stores absolute value of the result:
   dst(x,y,c) = abs(scale*src(x,y,c)+shift).
   destination array must have 8u type.
   In other cases one may use cvConvertScale + cvAbsDiffS 
</member>
        <member name="M:cvConvertScale(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Double,System.Double)">
@brief Converts one array to another with optional linear transformation.

The function has several different purposes, and thus has several different names. It copies one
array to another with optional scaling, which is performed first, and/or optional type conversion,
performed after:

\f[\texttt{dst} (I) =  \texttt{scale} \texttt{src} (I) + ( \texttt{shift} _0, \texttt{shift} _1,...)\f]

All the channels of multi-channel arrays are processed independently.

The type of conversion is done with rounding and saturation, that is if the result of scaling +
conversion can not be represented exactly by a value of the destination array element type, it is
set to the nearest representable value on the real axis.
@param src Source array
@param dst Destination array
@param scale Scale factor
@param shift Value added to the scaled source array elements

</member>
        <member name="M:cvMixChannels(System.Void!System.Runtime.CompilerServices.IsConst**,System.Int32,System.Void**,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Copies several channels from input arrays to
   certain channels of output arrays 
</member>
        <member name="M:cvMerge(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
Merges a set of single-channel arrays into the single multi-channel array
   or inserts one particular [color] plane to the array 
</member>
        <member name="M:cvSplit(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void*,System.Void*,System.Void*)">
Splits a multi-channel array into the set of single-channel arrays or
   extracts particular [color] plane 
</member>
        <member name="M:cvSetZero(System.Void*)">
@brief Clears the array.

The function clears the array. In the case of dense arrays (CvMat, CvMatND or IplImage),
cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0). In the case of sparse arrays all the
elements are removed.
@param arr Array to be cleared

</member>
        <member name="M:cvSet(System.Void*,CvScalar,System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Sets every element of an array to a given value.

The function copies the scalar value to every selected element of the destination array:
\f[\texttt{arr} (I)= \texttt{value} \quad \text{if} \quad \texttt{mask} (I)  \ne 0\f]
If array arr is of IplImage type, then is ROI used, but COI must not be set.
@param arr The destination array
@param value Fill value
@param mask Operation mask, 8-bit single channel array; specifies elements of the destination
array to be changed

</member>
        <member name="M:cvCopy(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Copies one array to another.

The function copies selected elements from an input array to an output array:

\f[\texttt{dst} (I)= \texttt{src} (I)  \quad \text{if} \quad \texttt{mask} (I)  \ne 0.\f]

If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays
must have the same type, the same number of dimensions, and the same size. The function can also
copy sparse arrays (mask is not supported in this case).
@param src The source array
@param dst The destination array
@param mask Operation mask, 8-bit single channel array; specifies elements of the destination array
to be changed

</member>
        <member name="M:cvGetSize(System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Returns size of matrix or image ROI.

The function returns number of rows (CvSize::height) and number of columns (CvSize::width) of the
input matrix or image. In the case of image the size of ROI is returned.
@param arr array header

</member>
        <member name="M:cvSetData(System.Void*,System.Void*,System.Int32)">
@brief Assigns user data to the array header.

The function assigns user data to the array header. Header should be initialized before using
cvCreateMatHeader, cvCreateImageHeader, cvCreateMatNDHeader, cvInitMatHeader,
cvInitImageHeader or cvInitMatNDHeader.
@param arr Array header
@param data User data
@param step Full row length in bytes

</member>
        <member name="M:cvReleaseData(System.Void*)">
@brief Releases array data.

The function releases the array data. In the case of CvMat or CvMatND it simply calls
cvDecRefData(), that is the function can not deallocate external data. See also the note to
cvCreateData .
@param arr Array header

</member>
        <member name="M:cvCreateData(System.Void*)">
@brief Allocates array data

The function allocates image, matrix or multi-dimensional dense array data. Note that in the case of
matrix types OpenCV allocation functions are used. In the case of IplImage they are used unless
CV_TURN_ON_IPL_COMPATIBILITY() has been called before. In the latter case IPL functions are used
to allocate the data.
@param arr Array header

</member>
        <member name="M:cvRepeat(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)">
Repeats source 2d array several times in both horizontal and
   vertical direction to fill destination array 
</member>
        <member name="M:cvGetImage(System.Void!System.Runtime.CompilerServices.IsConst*,_IplImage*)">
@brief Returns image header for arbitrary array.

The function returns the image header for the input array that can be a matrix (CvMat) or image
(IplImage). In the case of an image the function simply returns the input pointer. In the case of
CvMat it initializes an image_header structure with the parameters of the input matrix. Note that
if we transform IplImage to CvMat using cvGetMat and then transform CvMat back to IplImage using
this function, we will get different headers if the ROI is set in the original image.
@param arr Input array
@param image_header Pointer to IplImage structure used as a temporary buffer

</member>
        <member name="M:cvClearND(System.Void*,System.Int32!System.Runtime.CompilerServices.IsConst*)">
clears element of ND dense array,
   in case of sparse arrays it deletes the specified node 
</member>
        <member name="M:cvSetRealND(System.Void*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double)">
@overload
@param arr Input array
@param idx Array of the element indices
@param value The assigned value

</member>
        <member name="M:cvSetReal3D(System.Void*,System.Int32,System.Int32,System.Int32,System.Double)">
@overload 
</member>
        <member name="M:cvSetReal2D(System.Void*,System.Int32,System.Int32,System.Double)">
@overload 
</member>
        <member name="M:cvSetReal1D(System.Void*,System.Int32,System.Double)">
@brief Change a specific array element.

The functions assign a new value to a specific element of a single-channel array. If the array has
multiple channels, a runtime error is raised. Note that the Set\*D function can be used safely for
both single-channel and multiple-channel arrays, though they are a bit slower.

In the case of a sparse array the functions create the node if it does not yet exist.
@param arr Input array
@param idx0 The first zero-based component of the element index
@param value The assigned value

</member>
        <member name="M:cvSetND(System.Void*,System.Int32!System.Runtime.CompilerServices.IsConst*,CvScalar)">
@overload
@param arr Input array
@param idx Array of the element indices
@param value The assigned value

</member>
        <member name="M:cvSet3D(System.Void*,System.Int32,System.Int32,System.Int32,CvScalar)">
@overload 
</member>
        <member name="M:cvSet2D(System.Void*,System.Int32,System.Int32,CvScalar)">
@overload 
</member>
        <member name="M:cvSet1D(System.Void*,System.Int32,CvScalar)">
@brief Change the particular array element.

The functions assign the new value to a particular array element. In the case of a sparse array the
functions create the node if it does not exist yet.
@param arr Input array
@param idx0 The first zero-based component of the element index
@param value The assigned value

</member>
        <member name="M:cvGetRealND(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*)">
@overload
@param arr Input array. Must have a single channel.
@param idx Array of the element indices

</member>
        <member name="M:cvGetReal3D(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Int32)">
@overload 
</member>
        <member name="M:cvGetReal2D(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
@overload 
</member>
        <member name="M:cvGetReal1D(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Return a specific element of single-channel 1D, 2D, 3D or nD array.

Returns a specific element of a single-channel array. If the array has multiple channels, a runtime
error is raised. Note that Get?D functions can be used safely for both single-channel and
multiple-channel arrays though they are a bit slower.

In the case of a sparse array the functions return 0 if the requested node does not exist (no new
node is created by the functions).
@param arr Input array. Must have a single channel.
@param idx0 The first zero-based component of the element index

</member>
        <member name="M:cvGetND(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*)">
@overload
@param arr Input array
@param idx Array of the element indices

</member>
        <member name="M:cvGet3D(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Int32)">
@overload 
</member>
        <member name="M:cvGet2D(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
@overload 
</member>
        <member name="M:cvGet1D(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Return a specific array element.

The functions return a specific array element. In the case of a sparse array the functions return 0
if the requested node does not exist (no new node is created by the functions).
@param arr Input array
@param idx0 The first zero-based component of the element index

</member>
        <member name="M:cvPtrND(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Int32,System.UInt32*)">
@overload
@param arr Input array
@param idx Array of the element indices
@param type Optional output parameter: type of matrix elements
@param create_node Optional input parameter for sparse matrices. Non-zero value of the parameter
means that the requested element is created if it does not exist already.
@param precalc_hashval Optional input parameter for sparse matrices. If the pointer is not NULL,
the function does not recalculate the node hash value, but takes it from the specified location.
It is useful for speeding up pair-wise operations (TODO: provide an example)

</member>
        <member name="M:cvPtr3D(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Int32,System.Int32*)">
@overload 
</member>
        <member name="M:cvPtr2D(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Int32*)">
@overload 
</member>
        <member name="M:cvPtr1D(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32*)">
@brief Return pointer to a particular array element.

The functions return a pointer to a specific array element. Number of array dimension should match
to the number of indices passed to the function except for cvPtr1D function that can be used for
sequential access to 1D, 2D or nD dense arrays.

The functions can be used for sparse arrays as well - if the requested node does not exist they
create it and set it to zero.

All these as well as other functions accessing array elements ( cvGetND , cvGetRealND , cvSet
, cvSetND , cvSetRealND ) raise an error in case if the element index is out of range.
@param arr Input array
@param idx0 The first zero-based component of the element index
@param type Optional output parameter: type of matrix elements

</member>
        <member name="M:cvGetDimSize(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Returns array size along the specified dimension.

@param arr Input array
@param index Zero-based dimension index (for matrices 0 means number of rows, 1 means number of
columns; for images 0 means height, 1 means width)

</member>
        <member name="M:cvGetElemType(System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Returns type of array elements.

The function returns type of the array elements. In the case of IplImage the type is converted to
CvMat-like representation. For example, if the image has been created as:
@code
    IplImage* img = cvCreateImage(cvSize(640, 480), IPL_DEPTH_8U, 3);
@endcode
The code cvGetElemType(img) will return CV_8UC3.
@param arr Input array

</member>
        <member name="M:cvNextNArraySlice(CvNArrayIterator*)">
returns zero value if iteration is finished, non-zero (slice length) otherwise 
</member>
        <member name="M:cvInitNArrayIterator(System.Int32,System.Void**,System.Void!System.Runtime.CompilerServices.IsConst*,CvMatND*,CvNArrayIterator*,System.Int32)">
initializes iterator that traverses through several arrays simulteneously
   (the function together with cvNextArraySlice is used for
    N-ari element-wise operations) 
</member>
        <member name="T:CvNArrayIterator">
matrix iterator: used for n-ary operations on dense arrays 
</member>
        <member name="M:cvInitSparseMatIterator(CvSparseMat!System.Runtime.CompilerServices.IsConst*,CvSparseMatIterator*)">
@brief Initializes sparse array elements iterator.

The function initializes iterator of sparse array elements and returns pointer to the first element,
or NULL if the array is empty.
@param mat Input array
@param mat_iterator Initialized iterator

</member>
        <member name="M:cvCloneSparseMat(CvSparseMat!System.Runtime.CompilerServices.IsConst*)">
Creates a copy of CvSparseMat (except, may be, zero items) 
</member>
        <member name="M:cvReleaseSparseMat(CvSparseMat**)">
@brief Deallocates sparse array.

The function releases the sparse array and clears the array pointer upon exit.
@param mat Double pointer to the array

</member>
        <member name="M:cvCreateSparseMat(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Creates sparse array.

The function allocates a multi-dimensional sparse array. Initially the array contain no elements,
that is PtrND and other related functions will return 0 for every index.
@param dims Number of array dimensions. In contrast to the dense matrix, the number of dimensions is
practically unlimited (up to \f$2^{16}\f$ ).
@param sizes Array of dimension sizes
@param type Type of array elements. The same as for CvMat

</member>
        <member name="M:cvCloneMatND(CvMatND!System.Runtime.CompilerServices.IsConst*)">
Creates a copy of CvMatND (except, may be, steps) 
</member>
        <member name="M:cvReleaseMatND(CvMatND**)">
@brief Deallocates a multi-dimensional array.

The function decrements the array data reference counter and releases the array header. If the
reference counter reaches 0, it also deallocates the data. :
@code
    if(*mat )
        cvDecRefData(*mat);
    cvFree((void**)mat);
@endcode
@param mat Double pointer to the array

</member>
        <member name="M:cvInitMatNDHeader(CvMatND*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Void*)">
@brief Initializes a pre-allocated multi-dimensional array header.

@param mat A pointer to the array header to be initialized
@param dims The number of array dimensions
@param sizes An array of dimension sizes
@param type Type of array elements, see cvCreateMat
@param data Optional data pointer assigned to the matrix header

</member>
        <member name="M:cvCreateMatND(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Creates the header and allocates the data for a multi-dimensional dense array.

This function call is equivalent to the following code:
@code
    CvMatND* mat = cvCreateMatNDHeader(dims, sizes, type);
    cvCreateData(mat);
@endcode
@param dims Number of array dimensions. This must not exceed CV_MAX_DIM (32 by default, but can be
changed at build time).
@param sizes Array of dimension sizes.
@param type Type of array elements, see cvCreateMat .

</member>
        <member name="M:cvCreateMatNDHeader(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@brief Creates a new matrix header but does not allocate the matrix data.

The function allocates a header for a multi-dimensional dense array. The array data can further be
allocated using cvCreateData or set explicitly to user-allocated data via cvSetData.
@param dims Number of array dimensions
@param sizes Array of dimension sizes
@param type Type of array elements, see cvCreateMat

</member>
        <member name="M:cvGetDiag(System.Void!System.Runtime.CompilerServices.IsConst*,CvMat*,System.Int32)">
@brief Returns one of array diagonals.

The function returns the header, corresponding to a specified diagonal of the input array.
@param arr Input array
@param submat Pointer to the resulting sub-array header
@param diag Index of the array diagonal. Zero value corresponds to the main diagonal, -1
corresponds to the diagonal above the main, 1 corresponds to the diagonal below the main, and so
forth.

</member>
        <member name="M:cvGetCol(System.Void!System.Runtime.CompilerServices.IsConst*,CvMat*,System.Int32)">
@overload
@param arr Input array
@param submat Pointer to the resulting sub-array header
@param col Zero-based index of the selected column

</member>
        <member name="M:cvGetCols(System.Void!System.Runtime.CompilerServices.IsConst*,CvMat*,System.Int32,System.Int32)">
@brief Returns one of more array columns.

The functions return the header, corresponding to a specified column span of the input array. That

is, no data is copied. Therefore, any modifications of the submatrix will affect the original array.
If you need to copy the columns, use cvCloneMat. cvGetCol(arr, submat, col) is a shortcut for
cvGetCols(arr, submat, col, col+1).
@param arr Input array
@param submat Pointer to the resulting sub-array header
@param start_col Zero-based index of the starting column (inclusive) of the span
@param end_col Zero-based index of the ending column (exclusive) of the span

</member>
        <member name="M:cvGetRow(System.Void!System.Runtime.CompilerServices.IsConst*,CvMat*,System.Int32)">
@overload
@param arr Input array
@param submat Pointer to the resulting sub-array header
@param row Zero-based index of the selected row

</member>
        <member name="M:cvGetRows(System.Void!System.Runtime.CompilerServices.IsConst*,CvMat*,System.Int32,System.Int32,System.Int32)">
@brief Returns array row or row span.

The functions return the header, corresponding to a specified row/row span of the input array.
cvGetRow(arr, submat, row) is a shortcut for cvGetRows(arr, submat, row, row+1).
@param arr Input array
@param submat Pointer to the resulting sub-array header
@param start_row Zero-based index of the starting row (inclusive) of the span
@param end_row Zero-based index of the ending row (exclusive) of the span
@param delta_row Index step in the row span. That is, the function extracts every delta_row -th
row from start_row and up to (but not including) end_row .

</member>
        <member name="M:cvGetSubRect(System.Void!System.Runtime.CompilerServices.IsConst*,CvMat*,CvRect)">
@brief Returns matrix header corresponding to the rectangular sub-array of input image or matrix.

The function returns header, corresponding to a specified rectangle of the input array. In other

words, it allows the user to treat a rectangular part of input array as a stand-alone array. ROI is
taken into account by the function so the sub-array of ROI is actually extracted.
@param arr Input array
@param submat Pointer to the resultant sub-array header
@param rect Zero-based coordinates of the rectangle of interest

</member>
        <member name="M:cvCloneMat(CvMat!System.Runtime.CompilerServices.IsConst*)">
Creates an exact copy of the input matrix (except, may be, step value) 
</member>
        <member name="M:cvIncRefData(System.Void*)">
@brief Increments array data reference counter.

The function increments CvMat or CvMatND data reference counter and returns the new counter value if
the reference counter pointer is not NULL, otherwise it returns zero.
@param arr Array header

</member>
        <member name="M:cvDecRefData(System.Void*)">
@brief Decrements an array data reference counter.

The function decrements the data reference counter in a CvMat or CvMatND if the reference counter

pointer is not NULL. If the counter reaches zero, the data is deallocated. In the current
implementation the reference counter is not NULL only if the data was allocated using the
cvCreateData function. The counter will be NULL in other cases such as: external data was assigned
to the header using cvSetData, header is part of a larger matrix or image, or the header was
converted from an image or n-dimensional matrix header.
@param arr Pointer to an array header

</member>
        <member name="M:cvReleaseMat(CvMat**)">
@brief Deallocates a matrix.

The function decrements the matrix data reference counter and deallocates matrix header. If the data
reference counter is 0, it also deallocates the data. :
@code
    if(*mat )
        cvDecRefData(*mat);
    cvFree((void**)mat);
@endcode
@param mat Double pointer to the matrix

</member>
        <member name="M:cvCreateMatHeader(System.Int32,System.Int32,System.Int32)">
@brief Creates a matrix header but does not allocate the matrix data.

The function allocates a new matrix header and returns a pointer to it. The matrix data can then be
allocated using cvCreateData or set explicitly to user-allocated data via cvSetData.
@param rows Number of rows in the matrix
@param cols Number of columns in the matrix
@param type Type of the matrix elements, see cvCreateMat

</member>
        <member name="M:cvGetImageROI(_IplImage!System.Runtime.CompilerServices.IsConst*)">
@brief Returns the image ROI.

If there is no ROI set, cvRect(0,0,image-\&gt;width,image-\&gt;height) is returned.
@param image A pointer to the image header

</member>
        <member name="M:cvResetImageROI(_IplImage*)">
@brief Resets the image ROI to include the entire image and releases the ROI structure.

This produces a similar result to the following, but in addition it releases the ROI structure. :
@code
    cvSetImageROI(image, cvRect(0, 0, image-&gt;width, image-&gt;height ));
    cvSetImageCOI(image, 0);
@endcode
@param image A pointer to the image header

</member>
        <member name="M:cvSetImageROI(_IplImage*,CvRect)">
@brief Sets an image Region Of Interest (ROI) for a given rectangle.

If the original image ROI was NULL and the rect is not the whole image, the ROI structure is
allocated.

Most OpenCV functions support the use of ROI and treat the image rectangle as a separate image. For
example, all of the pixel coordinates are counted from the top-left (or bottom-left) corner of the
ROI, not the original image.
@param image A pointer to the image header
@param rect The ROI rectangle

</member>
        <member name="M:cvGetImageCOI(_IplImage!System.Runtime.CompilerServices.IsConst*)">
@brief Returns the index of the channel of interest.

Returns the channel of interest of in an IplImage. Returned values correspond to the coi in
cvSetImageCOI.
@param image A pointer to the image header

</member>
        <member name="M:cvSetImageCOI(_IplImage*,System.Int32)">
@brief Sets the channel of interest in an IplImage.

If the ROI is set to NULL and the coi is *not* 0, the ROI is allocated. Most OpenCV functions do
*not* support the COI setting, so to process an individual image/matrix channel one may copy (via
cvCopy or cvSplit) the channel to a separate image/matrix, process it and then copy the result
back (via cvCopy or cvMerge) if needed.
@param image A pointer to the image header
@param coi The channel of interest. 0 - all channels are selected, 1 - first channel is selected,
etc. Note that the channel indices become 1-based.

</member>
        <member name="M:cvCloneImage(_IplImage!System.Runtime.CompilerServices.IsConst*)">
Creates a copy of IPL image (widthStep may differ) 
</member>
        <member name="M:cvReleaseImage(_IplImage**)">
@brief Deallocates the image header and the image data.

This call is a shortened form of :
@code
    if(*image )
    {
        cvReleaseData(*image);
        cvReleaseImageHeader(image);
    }
@endcode
@param image Double pointer to the image header

</member>
        <member name="M:cvReleaseImageHeader(_IplImage**)">
@brief Deallocates an image header.

This call is an analogue of :
@code
    if(image )
    {
        iplDeallocate(*image, IPL_IMAGE_HEADER | IPL_IMAGE_ROI);
        *image = 0;
    }
@endcode
but it does not use IPL functions by default (see the CV_TURN_ON_IPL_COMPATIBILITY macro).
@param image Double pointer to the image header

</member>
        <member name="M:cvCreateImage(CvSize,System.Int32,System.Int32)">
@brief Creates an image header and allocates the image data.

This function call is equivalent to the following code:
@code
    header = cvCreateImageHeader(size, depth, channels);
    cvCreateData(header);
@endcode
@param size Image width and height
@param depth Bit depth of image elements. See IplImage for valid depths.
@param channels Number of channels per pixel. See IplImage for details. This function only creates
images with interleaved channels.

</member>
        <member name="M:cvInitImageHeader(_IplImage*,CvSize,System.Int32,System.Int32,System.Int32,System.Int32)">
@brief Initializes an image header that was previously allocated.

The returned IplImage\* points to the initialized header.
@param image Image header to initialize
@param size Image width and height
@param depth Image depth (see cvCreateImage )
@param channels Number of channels (see cvCreateImage )
@param origin Top-left IPL_ORIGIN_TL or bottom-left IPL_ORIGIN_BL
@param align Alignment for image rows, typically 4 or 8 bytes

</member>
        <member name="M:cvCreateImageHeader(CvSize,System.Int32,System.Int32)">
@brief Creates an image header but does not allocate the image data.

@param size Image width and height
@param depth Image depth (see cvCreateImage )
@param channels Number of channels (see cvCreateImage )

</member>
        <member name="M:cvFree_(System.Void*)">
`free` wrapper.
   Here and further all the memory releasing functions
   (that all call cvFree) take double pointer in order to
   to clear pointer to the data after releasing it.
   Passing pointer to NULL pointer is Ok: nothing happens in this case

</member>
        <member name="M:cvAlloc(System.UInt32)">
@} 
@addtogroup core_c
    @{

`malloc` wrapper.
   If there is no enough memory, the function
   (as well as other OpenCV functions that call cvAlloc)
   raises an error. 
</member>
        <member name="T:CvTypeInfo">
@brief Type information

The structure contains information about one of the standard or user-defined types. Instances of the
type may or may not contain a pointer to the corresponding CvTypeInfo structure. In any case, there
is a way to find the type info structure for a given object using the cvTypeOf function.
Alternatively, type info can be found by type name using cvFindType, which is used when an object
is read from file storage. The user can register a new type with cvRegisterType that adds the type
information structure into the beginning of the type list. Thus, it is possible to create
specialized types from generic standard types and override the basic methods.

</member>
        <member name="T:CvFileNode">
Basic element of the file storage - scalar or collection: 
</member>
        <member name="T:CvStringHashNode">
All the keys (names) of elements in the readed file storage
   are stored in the hash to speed up the lookup operations: 
</member>
        <member name="T:CvString">
file node flags 
</member>
        <member name="M:cvAttrList(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**,CvAttrList*)">
initializes CvAttrList structure 
</member>
        <member name="T:CvAttrList">
Storage flags: 
@brief List of attributes. :

In the current implementation, attributes are used to pass extra parameters when writing user
objects (see cvWrite). XML attributes inside tags are not supported, aside from the object type
specification (type_id attribute).
@see cvAttrList, cvAttrValue

</member>
        <member name="T:CvFileStorage">
Add element to sequence: 
Move reader position forward: 
Move reader position backward: 
Read element and move read position forward: 
Read element and move read position backward: 
Return next graph edge for given vertex: 
"black box" file storage 
</member>
        <member name="T:CvSeqWriter">
types of sequences 
types of sparse sequences (sets) 
flags for curves 
flags for graphs 
point sets 
chain-coded curves 
binary tree for the contour 
sequence of the connected components 
sequence of the integer numbers 
flag checking 
type checking macros 
</member>
        <member name="T:CvChain">
@} 
</member>
        <member name="T:CvGraph">
Graph is "derived" from the set (this is set a of vertices)
and includes another set (edges)

</member>
        <member name="T:CvGraphEdge">
Checks whether the element pointed by ptr belongs to a set or not 
@name Graph

We represent a graph as a set of vertices. Vertices contain their adjacency lists (more exactly,
pointers to first incoming or outcoming edge (or 0 if isolated vertex)). Edges are stored in
another set. There is a singly-linked list of incoming/outcoming edges for each vertex.

Each edge consists of:

- Two pointers to the starting and ending vertices (vtx[0] and vtx[1] respectively).

    A graph may be oriented or not. In the latter case, edges between vertex i to vertex j are not
distinguished during search operations.

- Two pointers to next edges for the starting and ending vertices, where next[0] points to the
next edge in the vtx[0] adjacency list and next[1] points to the next edge in the vtx[1]
adjacency list.

@see CvGraphEdge, CvGraphVtx, CvGraphVtx2D, CvGraph
@{

</member>
        <member name="T:CvSetElem">
@brief Set
  Order is not preserved. There can be gaps between sequence elements.
  After the element has been inserted it stays in the same place all the time.
  The MSB(most-significant or sign bit) of the first field (flags) is 0 iff the element exists.

</member>
        <member name="T:CvSeq">
Read/Write sequence.
Elements can be dynamically inserted to or deleted from the sequence.

</member>
        <member name="T:CvScalar">
@sa Scalar_

</member>
        <member name="F:CvLineIterator.ptr">
Pointer to the current point: 
</member>
        <member name="T:CvLineIterator">
Line iterator state: 
</member>
        <member name="T:CvBox2D">
@sa RotatedRect

</member>
        <member name="M:cvSize2D32f(System.Double,System.Double)">
constructs CvSize2D32f structure. 
</member>
        <member name="M:cvSize(System.Int32,System.Int32)">
constructs CvSize structure. 
</member>
        <member name="M:cvPoint3D64f(System.Double,System.Double,System.Double)">
constructs CvPoint3D64f structure. 
</member>
        <member name="M:cvPoint2D64f(System.Double,System.Double)">
constructs CvPoint2D64f structure.
</member>
        <member name="M:cvPoint3D32f(System.Double,System.Double,System.Double)">
constructs CvPoint3D32f structure. 
</member>
        <member name="M:cvPointFrom32f(CvPoint2D32f)">
converts CvPoint2D32f to CvPoint. 
</member>
        <member name="M:cvPointTo32f(CvPoint)">
converts CvPoint to CvPoint2D32f. 
</member>
        <member name="M:cvPoint2D32f(System.Double,System.Double)">
constructs CvPoint2D32f structure. 
</member>
        <member name="M:cvPoint(System.Int32,System.Int32)">
constructs CvPoint structure. 
</member>
        <member name="T:CvTermCriteria">
@sa TermCriteria

</member>
        <member name="M:cvRect(System.Int32,System.Int32,System.Int32,System.Int32)">
constructs CvRect structure. 
</member>
        <member name="T:CvRect">
@sa Rect_ 
</member>
        <member name="T:CvHistogram">
indicates whether bin ranges are set already or not 
should be used as a parameter only,
   it turns to CV_HIST_UNIFORM_FLAG of hist-&gt;type 
</member>
        <member name="T:CvMatND">
@deprecated consider using cv::Mat instead

</member>
        <member name="M:cvmSet(CvMat*,System.Int32,System.Int32,System.Double)">
@brief Sets a specific element of a single-channel floating-point matrix.

The function is a fast replacement for cvSetReal2D in the case of single-channel floating-point
matrices. It is faster because it is inline, it does fewer checks for array type and array element
type, and it checks for the row and column ranges only in debug mode.
@param mat The matrix
@param row The zero-based index of row
@param col The zero-based index of column
@param value The new value of the matrix element

</member>
        <member name="M:cvmGet(CvMat!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
@brief Returns the particular element of single-channel floating-point matrix.

The function is a fast replacement for cvGetReal2D in the case of single-channel floating-point
matrices. It is faster because it is inline, it does fewer checks for array type and array element
type, and it checks for the row and column ranges only in debug mode.
@param mat Input matrix
@param row The zero-based index of row
@param col The zero-based index of column

</member>
        <member name="M:cvMat(System.Int32,System.Int32,System.Int32,System.Void*)">
Inline constructor. No data is allocated internally!!!
 * (Use together with cvCreateData, or use cvCreateMat instead to
 * get a matrix with allocated data):

</member>
        <member name="T:CvMat">
extra border mode 
for storing double-precision
   floating point data in IplImage's 
get reference to pixel at (col,row),
   for multi-channel images (col) should be multiplied by number of channels 
Matrix elements are stored row by row. Element (i, j) (i - 0-based row index, j - 0-based column
index) of a matrix can be retrieved or modified using CV_MAT_ELEM macro:

    uchar pixval = CV_MAT_ELEM(grayimg, uchar, i, j)
    CV_MAT_ELEM(cameraMatrix, float, 0, 2) = image.width*0.5f;

To access multiple-channel matrices, you can use
CV_MAT_ELEM(matrix, type, i, j\*nchannels + channel_idx).

@deprecated CvMat is now obsolete; consider using Mat instead.

</member>
        <member name="T:_IplImage">
The IplImage is taken from the Intel Image Processing Library, in which the format is native. OpenCV
only supports a subset of possible IplImage formats, as outlined in the parameter list above.

In addition to the above restrictions, OpenCV handles ROIs differently. OpenCV functions require
that the image size or ROI size of all source and destination images match exactly. On the other
hand, the Intel Image Processing Library processes the area of intersection between the source and
destination images (or ROIs), allowing them to vary independently.

</member>
        <member name="M:cvRandReal(System.UInt64*)">
@brief Returns a floating-point random number and updates RNG.

The function returns a uniformly-distributed random floating-point number between 0 and 1 (1 is not
included).
@param rng RNG state initialized by cvRNG

</member>
        <member name="M:cvRandInt(System.UInt64*)">
@brief Returns a 32-bit unsigned integer and updates RNG.

The function returns a uniformly-distributed random 32-bit unsigned integer and updates the RNG
state. It is similar to the rand() function from the C runtime library, except that OpenCV functions
always generates a 32-bit random number, regardless of the platform.
@param rng CvRNG state initialized by cvRNG.

</member>
        <member name="M:cvRNG(System.Int64)">
@brief Initializes a random number generator state.

The function initializes a random number generator and returns the state. The pointer to the state
can be then passed to the cvRandInt, cvRandReal and cvRandArr functions. In the current
implementation a multiply-with-carry generator is used.
@param seed 64-bit value used to initiate a random sequence
@sa the C++ class RNG replaced CvRNG.

</member>
        <member name="D:CvArr">
@addtogroup core_c
    @{

@brief This is the "metatype" used *only* as a function parameter.

It denotes that the function accepts arrays of multiple types, such as IplImage*, CvMat* or even
CvSeq* sometimes. The particular array type is determined at runtime by analyzing the first 4
bytes of the header. In C++ interface the role of CvArr is played by InputArray and OutputArray.

</member>
        <member name="M:cv.CommandLineParser.printErrors">
@brief Print list of errors occured

    @sa check

</member>
        <member name="M:cv.CommandLineParser.printMessage">
@brief Print help message

    This method will print standard help message containing the about message and arguments description.

    @sa about

</member>
        <member name="M:cv.CommandLineParser.about(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set the about message

    The about message will be shown when @ref printMessage is called, right before arguments table.

</member>
        <member name="M:cv.CommandLineParser.check">
@brief Check for parsing errors

    Returns true if error occured while accessing the parameters (bad conversion, missing arguments,
    etc.). Call @ref printErrors to print error messages list.

</member>
        <member name="M:cv.CommandLineParser.has(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Check if field was provided in the command line

    @param name argument name to check

</member>
        <member name="M:cv.CommandLineParser.getPathToApplication">
@brief Returns application path

    This method returns the path to the executable from the command line (`argv[0]`).

    For example, if the application has been started with such command:
    @code{.sh}
    $ ./bin/my-executable
    @endcode
    this method will return `./bin`.

</member>
        <member name="M:cv.CommandLineParser.Dispose">
@brief Destructor 
</member>
        <member name="M:cv.CommandLineParser.op_Assign(cv.CommandLineParser!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Assignment operator 
</member>
        <member name="M:cv.CommandLineParser.#ctor(cv.CommandLineParser!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Copy constructor 
</member>
        <member name="M:cv.CommandLineParser.#ctor(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Constructor

    Initializes command line parser object

    @param argc number of command line arguments (from main())
    @param argv array of command line arguments (from main())
    @param keys string describing acceptable command line parameters (see class description for syntax)

</member>
        <member name="M:cv.parallel_for_(cv.Range!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.ParallelLoopBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief Parallel data processor

</member>
        <member name="T:cv.ParallelLoopBody">
@brief Base class for parallel data processors

</member>
        <member name="M:cv.useOptimized">
@brief Returns the status of optimized code usage.

The function returns true if the optimized code is enabled. Otherwise, it returns false.

</member>
        <member name="M:cv.setUseOptimized(System.Boolean)">
@brief Enables or disables the optimized code.

The function can be used to dynamically turn on and off optimized code (code that uses SSE2, AVX,
and other instructions on the platforms that support it). It sets a global flag that is further
checked by OpenCV functions. Since the flag is not checked in the inner OpenCV loops, it is only
safe to call the function on the very top level in your application where you can be sure that no
other OpenCV function is currently executed.

By default, the optimized code is enabled unless you disable it in CMake. The current status can be
retrieved using useOptimized.
@param onoff The boolean flag specifying whether the optimized code should be used (onoff=true)
or not (onoff=false).

</member>
        <member name="M:cv.getNumberOfCPUs">
@brief Returns the number of logical CPUs available for the process.

</member>
        <member name="M:cv.checkHardwareSupport(System.Int32)">
@brief Returns true if the specified feature is supported by the host hardware.

The function returns true if the host hardware supports the specified feature. When user calls
setUseOptimized(false), the subsequent calls to checkHardwareSupport() will return false until
setUseOptimized(true) is called. This way user can dynamically switch on and off the optimized code
in OpenCV.
@param feature The feature of interest, one of cv::CpuFeatures

</member>
        <member name="T:cv.CpuFeatures">
@brief Available CPU features.

remember to keep this list identical to the one in cvdef.h

</member>
        <member name="M:cv.getCPUTickCount">
@brief Returns the number of CPU ticks.

The function returns the current number of CPU ticks on some architectures (such as x86, x64,
PowerPC). On other platforms the function is equivalent to getTickCount. It can also be used for
very accurate time measurements, as well as for RNG initialization. Note that in case of multi-CPU
systems a thread, from which getCPUTickCount is called, can be suspended and resumed at another CPU
with its own counter. So, theoretically (and practically) the subsequent calls to the function do
not necessary return the monotonously increasing values. Also, since a modern CPU varies the CPU
frequency depending on the load, the number of CPU clocks spent in some code cannot be directly
converted to time units. Therefore, getTickCount is generally a preferable solution for measuring
execution time.

</member>
        <member name="M:cv.getTickFrequency">
@brief Returns the number of ticks per second.

The function returns the number of ticks per second. That is, the following code computes the
execution time in seconds:
@code
    double t = (double)getTickCount();
    // do something ...
    t = ((double)getTickCount() - t)/getTickFrequency();
@endcode

</member>
        <member name="M:cv.getTickCount">
@brief Returns the number of ticks.

The function returns the number of ticks after the certain event (for example, when the machine was
turned on). It can be used to initialize RNG or to measure a function execution time by reading the
tick count before and after the function call. See also the tick frequency.

</member>
        <member name="M:cv.getBuildInformation">
@brief Returns full configuration time cmake output.

Returned value is raw cmake output including version control system revision, compiler version,
compiler flags, enabled modules and third party libraries, etc. Output format depends on target
architecture.

</member>
        <member name="M:cv.getThreadNum">
@brief Returns the index of the currently executed thread within the current parallel region. Always
returns 0 if called outside of parallel region.

The exact meaning of return value depends on the threading framework used by OpenCV library:
- `TBB` â€“ Unsupported with current 4.1 TBB release. May be will be supported in future.
- `OpenMP` â€“ The thread number, within the current team, of the calling thread.
- `Concurrency` â€“ An ID for the virtual processor that the current context is executing on (0
  for master thread and unique number for others, but not necessary 1,2,3,...).
- `GCD` â€“ System calling thread's ID. Never returns 0 inside parallel region.
- `C=` â€“ The index of the current parallel task.
@sa setNumThreads, getNumThreads

</member>
        <member name="M:cv.getNumThreads">
@brief Returns the number of threads used by OpenCV for parallel regions.

Always returns 1 if OpenCV is built without threading support.

The exact meaning of return value depends on the threading framework used by OpenCV library:
- `TBB` â€“ The number of threads, that OpenCV will try to use for parallel regions. If there is
  any tbb::thread_scheduler_init in user code conflicting with OpenCV, then function returns
  default number of threads used by TBB library.
- `OpenMP` â€“ An upper bound on the number of threads that could be used to form a new team.
- `Concurrency` â€“ The number of threads, that OpenCV will try to use for parallel regions.
- `GCD` â€“ Unsupported; returns the GCD thread pool limit (512) for compatibility.
- `C=` â€“ The number of threads, that OpenCV will try to use for parallel regions, if before
  called setNumThreads with threads \&gt; 0, otherwise returns the number of logical CPUs,
  available for the process.
@sa setNumThreads, getThreadNum

</member>
        <member name="M:cv.format(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)">
@brief Returns a text string formatted using the printf-like expression.

The function acts like sprintf but forms and returns an STL string. It can be used to form an error
message in the Exception constructor.
@param fmt printf-compatible formatting specifiers.

</member>
        <member name="M:cv.redirectError(=FUNC:System.Int32(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Void*),System.Void*,System.Void**)">
@brief Sets the new error handler and the optional user data.

  The function sets the new error handler, called from cv::error().

  \param errCallback the new error handler. If NULL, the default error handler is used.
  \param userdata the optional user data pointer, passed to the callback.
  \param prevUserdata the optional output parameter where the previous user data pointer is stored

  \return the previous error handler

</member>
        <member name="M:cv.setBreakOnError(System.Boolean)">
 @brief Sets/resets the break-on-error mode.

When the break-on-error mode is set, the default error handler issues a hardware exception, which
can make debugging more convenient.

\return the previous state

</member>
        <member name="M:cv.Algorithm.getDefaultName">
Returns the algorithm string identifier.
     This string is used as top level xml/yml node tag when the object is saved to a file or string. 
</member>
        <member name="M:cv.Algorithm.empty">
@brief Returns true if the Algorithm is empty (e.g. in the very beginning or after unsuccessful read

</member>
        <member name="M:cv.Algorithm.read(cv.FileNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Reads algorithm parameters from a file storage

</member>
        <member name="M:cv.Algorithm.write(cv.FileStorage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Stores algorithm parameters in a file storage

</member>
        <member name="M:cv.Algorithm.clear">
@brief Clears the algorithm state

</member>
        <member name="T:cv.Formatter">
@todo document 
</member>
        <member name="T:cv.Formatted">
@todo document 
</member>
        <member name="M:cv.RNG_MT19937.uniform(System.Double,System.Double)">
@brief returns uniformly distributed double-precision floating-point random number from [a,b) range


</member>
        <member name="M:cv.RNG_MT19937.uniform(System.Single,System.Single)">
@brief returns uniformly distributed floating-point random number from [a,b) range


</member>
        <member name="M:cv.RNG_MT19937.uniform(System.Int32,System.Int32)">
@brief returns uniformly distributed integer random number from [a,b) range


</member>
        <member name="T:cv.RNG_MT19937">
@brief Mersenne Twister random number generator

Inspired by http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c
@todo document

</member>
        <member name="M:cv.RNG.gaussian(System.Double)">
@brief Returns the next random number sampled from the Gaussian distribution
    @param sigma standard deviation of the distribution.

    The method transforms the state using the MWC algorithm and returns the
    next random number from the Gaussian distribution N(0,sigma) . That is,
    the mean value of the returned random numbers is zero and the standard
    deviation is the specified sigma .

</member>
        <member name="M:cv.RNG.fill(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief Fills arrays with random numbers.

    @param mat 2D or N-dimensional matrix; currently matrices with more than
    4 channels are not supported by the methods, use Mat::reshape as a
    possible workaround.
    @param distType distribution type, RNG::UNIFORM or RNG::NORMAL.
    @param a first distribution parameter; in case of the uniform
    distribution, this is an inclusive lower boundary, in case of the normal
    distribution, this is a mean value.
    @param b second distribution parameter; in case of the uniform
    distribution, this is a non-inclusive upper boundary, in case of the
    normal distribution, this is a standard deviation (diagonal of the
    standard deviation matrix or the full standard deviation matrix).
    @param saturateRange pre-saturation flag; for uniform distribution only;
    if true, the method will first convert a and b to the acceptable value
    range (according to the mat datatype) and then will generate uniformly
    distributed random numbers within the range [saturate(a), saturate(b)),
    if saturateRange=false, the method will generate uniformly distributed
    random numbers in the original range [a, b) and then will saturate them,
    it means, for example, that
    <tt>theRNG().fill(mat_8u, RNG::UNIFORM, -DBL_MAX, DBL_MAX)</tt> will likely
    produce array mostly filled with 0's and 255's, since the range (0, 255)
    is significantly smaller than [-DBL_MAX, DBL_MAX).

    Each of the methods fills the matrix with the random values from the
    specified distribution. As the new numbers are generated, the RNG state
    is updated accordingly. In case of multiple-channel images, every
    channel is filled independently, which means that RNG cannot generate
    samples from the multi-dimensional Gaussian distribution with
    non-diagonal covariance matrix directly. To do that, the method
    generates samples from multi-dimensional standard Gaussian distribution
    with zero mean and identity covariation matrix, and then transforms them
    using transform to get samples from the specified Gaussian distribution.

</member>
        <member name="M:cv.RNG.uniform(System.Double,System.Double)">
@overload 
</member>
        <member name="M:cv.RNG.uniform(System.Single,System.Single)">
@overload 
</member>
        <member name="M:cv.RNG.uniform(System.Int32,System.Int32)">
@brief returns uniformly distributed integer random number from [a,b) range

    The methods transform the state using the MWC algorithm and return the
    next uniformly-distributed random number of the specified type, deduced
    from the input parameter type, from the range [a, b) . There is a nuance
    illustrated by the following sample:

    @code{.cpp}
    RNG rng;

    // always produces 0
    double a = rng.uniform(0, 1);

    // produces double from [0, 1)
    double a1 = rng.uniform((double)0, (double)1);

    // produces float from [0, 1)
    double b = rng.uniform(0.f, 1.f);

    // produces double from [0, 1)
    double c = rng.uniform(0., 1.);

    // may cause compiler error because of ambiguity:
    //  RNG::uniform(0, (int)0.999999)? or RNG::uniform((double)0, 0.99999)?
    double d = rng.uniform(0, 0.999999);
    @endcode

    The compiler does not take into account the type of the variable to
    which you assign the result of RNG::uniform . The only thing that
    matters to the compiler is the type of a and b parameters. So, if you
    want a floating-point random number, but the range boundaries are
    integer numbers, either put dots in the end, if they are constants, or
    use explicit type cast operators, as in the a1 initialization above.
    @param a lower inclusive boundary of the returned random numbers.
    @param b upper non-inclusive boundary of the returned random numbers.

</member>
        <member name="M:cv.RNG.op_FunctionCall(System.UInt32)">
@overload
    @param N upper non-inclusive boundary of the returned random number.

</member>
        <member name="M:cv.RNG.op_FunctionCall">
@brief returns a random integer sampled uniformly from [0, N).

    The methods transform the state using the MWC algorithm and return the
    next random number. The first form is equivalent to RNG::next . The
    second form returns the random number modulo N , which means that the
    result is in the range [0, N) .

</member>
        <member name="M:cv.RNG.op_Implicit~System.Double">
@overload 
</member>
        <member name="M:cv.RNG.op_Implicit~System.Single">
@overload 
</member>
        <member name="M:cv.RNG.op_Implicit~System.Int32">
@overload 
</member>
        <member name="M:cv.RNG.op_Implicit~System.UInt32">
@overload 
</member>
        <member name="M:cv.RNG.op_Implicit~System.Int16">
@overload 
</member>
        <member name="M:cv.RNG.op_Implicit~System.UInt16">
@overload 
</member>
        <member name="M:cv.RNG.op_Implicit~System.SByte">
@overload 
</member>
        <member name="M:cv.RNG.op_Implicit~System.Byte">
Each of the methods updates the state using the MWC algorithm and
    returns the next random number of the specified type. In case of integer
    types, the returned number is from the available value range for the
    specified type. In case of floating-point types, the returned value is
    from [0,1) range.

</member>
        <member name="M:cv.RNG.next">
The method updates the state using the MWC algorithm and returns the
    next 32-bit random number.
</member>
        <member name="M:cv.RNG.#ctor(System.UInt64)">
@overload
    @param state 64-bit value used to initialize the RNG.

</member>
        <member name="M:cv.RNG.#ctor">
@brief constructor

    These are the RNG constructors. The first form sets the state to some
    pre-defined value, equal to 2\*\*32-1 in the current implementation. The
    second form sets the state to the specified value. If you passed state=0
    , the constructor uses the above default value instead to avoid the
    singular random number sequence, consisting of all zeros.

</member>
        <member name="M:cv.SVD.backSubst(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief performs a singular value back substitution.

    The method calculates a back substitution for the specified right-hand
    side:

    \f[\texttt{x} =  \texttt{vt} ^T  \cdot diag( \texttt{w} )^{-1}  \cdot \texttt{u} ^T  \cdot \texttt{rhs} \sim \texttt{A} ^{-1}  \cdot \texttt{rhs}\f]

    Using this technique you can either get a very accurate solution of the
    convenient linear system, or the best (in the least-squares terms)
    pseudo-solution of an overdetermined linear system.

    @param rhs right-hand side of a linear system (u\*w\*v')\*dst = rhs to
    be solved, where A has been previously decomposed.

    @param dst found solution of the system.

    @note Explicit SVD with the further back substitution only makes sense
    if you need to solve many linear systems with the same left-hand side
    (for example, src ). If all you need is to solve a single system
    (possibly with multiple rhs immediately available), simply call solve
    add pass DECOMP_SVD there. It does absolutely the same thing.

</member>
        <member name="M:cv.SVD.solveZ(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief solves an under-determined singular linear system

    The method finds a unit-length solution x of a singular linear system
    A\*x = 0. Depending on the rank of A, there can be no solutions, a
    single solution or an infinite number of solutions. In general, the
    algorithm solves the following problem:
    \f[dst =  \arg \min _{x:  \| x \| =1}  \| src  \cdot x  \|\f]
    @param src left-hand-side matrix.
    @param dst found solution.

</member>
        <member name="M:cv.SVD.backSubst(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief performs back substitution

</member>
        <member name="M:cv.SVD.compute(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@overload
    computes singular values of a matrix
    @param src decomposed matrix
    @param w calculated singular values
    @param flags operation flags - see SVD::Flags.

</member>
        <member name="M:cv.SVD.compute(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief decomposes matrix and stores the results to user-provided matrices

    The methods/functions perform SVD of matrix. Unlike SVD::SVD constructor
    and SVD::operator(), they store the results to the user-provided
    matrices:

    @code{.cpp}
    Mat A, w, u, vt;
    SVD::compute(A, w, u, vt);
    @endcode

    @param src decomposed matrix
    @param w calculated singular values
    @param u calculated left singular vectors
    @param vt transposed matrix of right singular values
    @param flags operation flags - see SVD::SVD.

</member>
        <member name="M:cv.SVD.op_FunctionCall(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief the operator that performs SVD. The previously allocated u, w and vt are released.

    The operator performs the singular value decomposition of the supplied
    matrix. The u,`vt` , and the vector of singular values w are stored in
    the structure. The same SVD structure can be reused many times with
    different matrices. Each time, if needed, the previous u,`vt` , and w
    are reclaimed and the new matrices are created, which is all handled by
    Mat::create.
    @param src decomposed matrix.
    @param flags operation flags (SVD::Flags)

</member>
        <member name="M:cv.SVD.#ctor(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@overload
    initializes an empty SVD structure and then calls SVD::operator()
    @param src decomposed matrix.
    @param flags operation flags (SVD::Flags)

</member>
        <member name="M:cv.SVD.#ctor">
@brief the default constructor

    initializes an empty SVD structure

</member>
        <member name="F:FULL_UV">
when the matrix is not square, by default the algorithm produces u and vt matrices of
            sufficiently large size for the further A reconstruction; if, however, FULL_UV flag is
            specified, u and vt will be full-size square orthogonal matrices.
</member>
        <member name="F:NO_UV">
indicates that only a vector of singular values `w` is to be processed, while u and vt
            will be set to empty matrices 
</member>
        <member name="F:MODIFY_A">
allow the algorithm to modify the decomposed matrix; it can save space and speed up
            processing. currently ignored. 
</member>
        <member name="T:cv.SVD">
@brief Singular Value Decomposition

Class for computing Singular Value Decomposition of a floating-point
matrix. The Singular Value Decomposition is used to solve least-square
problems, under-determined linear systems, invert matrices, compute
condition numbers, and so on.

If you want to compute a condition number of a matrix or an absolute value of
its determinant, you do not need `u` and `vt`. You can pass
flags=SVD::NO_UV|... . Another flag SVD::FULL_UV indicates that full-size u
and vt must be computed, which is not necessary most of the time.

@sa invert, solve, eigen, determinant

</member>
        <member name="M:cv.LDA.eigenvalues">
Returns the eigenvalues of this LDA.

</member>
        <member name="M:cv.LDA.eigenvectors">
Returns the eigenvectors of this LDA.

</member>
        <member name="M:cv.LDA.reconstruct(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Reconstructs projections from the LDA subspace.

</member>
        <member name="M:cv.LDA.project(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Projects samples into the LDA subspace.

</member>
        <member name="M:cv.LDA.compute(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Compute the discriminants for data in src and labels.

</member>
        <member name="M:cv.LDA.Dispose">
destructor

</member>
        <member name="M:cv.LDA.load(cv.FileStorage!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Deserializes this object from a given cv::FileStorage.

</member>
        <member name="M:cv.LDA.save(cv.FileStorage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Serializes this object to a given cv::FileStorage.

</member>
        <member name="M:cv.LDA.load(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Deserializes this object from a given filename.

</member>
        <member name="M:cv.LDA.save(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Serializes this object to a given filename.

</member>
        <member name="M:cv.LDA.#ctor(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Initializes and performs a Discriminant Analysis with Fisher's
     Optimization Criterion on given data in src and corresponding labels
     in labels. If 0 (or less) number of components are given, they are
     automatically determined for given data in computation.

</member>
        <member name="M:cv.LDA.#ctor(System.Int32)">
@brief constructor
    Initializes a LDA with num_components (default 0) and specifies how
    samples are aligned (default dataAsRow=true).

</member>
        <member name="T:cv.LDA">
@example pca.cpp
  An example using %PCA for dimensionality reduction while maintaining an amount of variance

@brief Linear Discriminant Analysis
@todo document this class

</member>
        <member name="M:cv.PCA.write(cv.FileStorage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief write and load PCA matrix


</member>
        <member name="M:cv.PCA.backProject(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param vec coordinates of the vectors in the principal component
    subspace, the layout and size are the same as of PCA::project output
    vectors.
    @param result reconstructed vectors; the layout and size are the same as
    of PCA::project input vectors.

</member>
        <member name="M:cv.PCA.backProject(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Reconstructs vectors from their PC projections.

    The methods are inverse operations to PCA::project. They take PC
    coordinates of projected vectors and reconstruct the original vectors.
    Unless all the principal components have been retained, the
    reconstructed vectors are different from the originals. But typically,
    the difference is small if the number of components is large enough (but
    still much smaller than the original vector dimensionality). As a
    result, PCA is used.
    @param vec coordinates of the vectors in the principal component
    subspace, the layout and size are the same as of PCA::project output
    vectors.

</member>
        <member name="M:cv.PCA.project(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param vec input vector(s); must have the same dimensionality and the
    same layout as the input data used at PCA phase, that is, if
    DATA_AS_ROW are specified, then `vec.cols==data.cols`
    (vector dimensionality) and `vec.rows` is the number of vectors to
    project, and the same is true for the PCA::DATA_AS_COL case.
    @param result output vectors; in case of PCA::DATA_AS_COL, the
    output matrix has as many columns as the number of input vectors, this
    means that `result.cols==vec.cols` and the number of rows match the
    number of principal components (for example, `maxComponents` parameter
    passed to the constructor).

</member>
        <member name="M:cv.PCA.project(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Projects vector(s) to the principal component subspace.

    The methods project one or more vectors to the principal component
    subspace, where each vector projection is represented by coefficients in
    the principal component basis. The first form of the method returns the
    matrix that the second form writes to the result. So the first form can
    be used as a part of expression while the second form can be more
    efficient in a processing loop.
    @param vec input vector(s); must have the same dimensionality and the
    same layout as the input data used at %PCA phase, that is, if
    DATA_AS_ROW are specified, then `vec.cols==data.cols`
    (vector dimensionality) and `vec.rows` is the number of vectors to
    project, and the same is true for the PCA::DATA_AS_COL case.

</member>
        <member name="M:cv.PCA.op_FunctionCall(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double)">
@overload
    @param data input samples stored as the matrix rows or as the matrix
    columns.
    @param mean optional mean value; if the matrix is empty (noArray()),
    the mean is computed from the data.
    @param flags operation flags; currently the parameter is only used to
    specify the data layout. (PCA::Flags)
    @param retainedVariance Percentage of variance that %PCA should retain.
    Using this parameter will let the %PCA decided how many components to
    retain but it will always keep at least 2.

</member>
        <member name="M:cv.PCA.op_FunctionCall(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief performs %PCA

    The operator performs %PCA of the supplied dataset. It is safe to reuse
    the same PCA structure for multiple datasets. That is, if the structure
    has been previously used with another dataset, the existing internal
    data is reclaimed and the new eigenvalues, @ref eigenvectors , and @ref
    mean are allocated and computed.

    The computed eigenvalues are sorted from the largest to the smallest and
    the corresponding eigenvectors are stored as eigenvectors rows.

    @param data input samples stored as the matrix rows or as the matrix
    columns.
    @param mean optional mean value; if the matrix is empty (noArray()),
    the mean is computed from the data.
    @param flags operation flags; currently the parameter is only used to
    specify the data layout. (Flags)
    @param maxComponents maximum number of components that PCA should
    retain; by default, all the components are retained.

</member>
        <member name="M:cv.PCA.#ctor(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double)">
@overload
    @param data input samples stored as matrix rows or matrix columns.
    @param mean optional mean value; if the matrix is empty (noArray()),
    the mean is computed from the data.
    @param flags operation flags; currently the parameter is only used to
    specify the data layout (PCA::Flags)
    @param retainedVariance Percentage of variance that PCA should retain.
    Using this parameter will let the PCA decided how many components to
    retain but it will always keep at least 2.

</member>
        <member name="M:cv.PCA.#ctor(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@overload
    @param data input samples stored as matrix rows or matrix columns.
    @param mean optional mean value; if the matrix is empty (@c noArray()),
    the mean is computed from the data.
    @param flags operation flags; currently the parameter is only used to
    specify the data layout (PCA::Flags)
    @param maxComponents maximum number of components that %PCA should
    retain; by default, all the components are retained.

</member>
        <member name="M:cv.PCA.#ctor">
@brief default constructor

    The default constructor initializes an empty %PCA structure. The other
    constructors initialize the structure and call PCA::operator()().

</member>
        <member name="M:cv.randShuffle(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv.RNG*)">
@brief Shuffles the array elements randomly.

The function randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and
swapping them. The number of such swap operations will be dst.rows\*dst.cols\*iterFactor .
@param dst input/output numerical 1D array.
@param iterFactor scale factor that determines the number of random swap operations (see the details
below).
@param rng optional random number generator used for shuffling; if it is zero, theRNG () is used
instead.
@sa RNG, sort

</member>
        <member name="M:cv.randn(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Fills the array with normally distributed random numbers.

The function randn fills the matrix dst with normally distributed random numbers with the specified
mean vector and the standard deviation matrix. The generated random numbers are clipped to fit the
value range of the output array data type.
@param dst output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.
@param mean mean value (expectation) of the generated random numbers.
@param stddev standard deviation of the generated random numbers; it can be either a vector (in
which case a diagonal standard deviation matrix is assumed) or a square matrix.
@sa RNG, randu

</member>
        <member name="M:cv.theRNG">
@brief Returns the default random number generator.

The function theRNG returns the default random number generator. For each thread, there is a
separate random number generator, so you can use the function safely in multi-thread environments.
If you just need to get a single random number using this generator or initialize an array, you can
use randu or randn instead. But if you are going to generate many random numbers inside a loop, it
is much faster to use this function to retrieve the generator and then use RNG::operator _Tp() .
@sa RNG, randu, randn

</member>
        <member name="M:cv.getOptimalDFTSize(System.Int32)">
@brief Returns the optimal DFT size for a given vector size.

DFT performance is not a monotonic function of a vector size. Therefore, when you calculate
convolution of two arrays or perform the spectral analysis of an array, it usually makes sense to
pad the input data with zeros to get a bit larger array that can be transformed much faster than the
original one. Arrays whose size is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process.
Though, the arrays whose size is a product of 2's, 3's, and 5's (for example, 300 = 5\*5\*3\*2\*2)
are also processed quite efficiently.

The function getOptimalDFTSize returns the minimum number N that is greater than or equal to vecsize
so that the DFT of a vector of size N can be processed efficiently. In the current implementation N
= 2 ^p^ \* 3 ^q^ \* 5 ^r^ for some integer p, q, r.

The function returns a negative number if vecsize is too large (very close to INT_MAX ).

While the function cannot be used directly to estimate the optimal vector size for DCT transform
(since the current DCT implementation supports only even-size vectors), it can be easily processed
as getOptimalDFTSize((vecsize+1)/2)\*2.
@param vecsize vector size.
@sa dft , dct , idft , idct , mulSpectrums

</member>
        <member name="M:cv.mulSpectrums(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
@brief Performs the per-element multiplication of two Fourier spectrums.

The function mulSpectrums performs the per-element multiplication of the two CCS-packed or complex
matrices that are results of a real or complex Fourier transform.

The function, together with dft and idft , may be used to calculate convolution (pass conjB=false )
or correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are
simply multiplied (per element) with an optional conjugation of the second-array elements. When the
arrays are real, they are assumed to be CCS-packed (see dft for details).
@param a first input array.
@param b second input array of the same size and type as src1 .
@param c output array of the same size and type as src1 .
@param flags operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that
each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a `0` as value.
@param conjB optional flag that conjugates the second input array before the multiplication (true)
or not (false).

</member>
        <member name="M:cv.idct(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.

idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE).
@param src input floating-point single-channel array.
@param dst output array of the same size and type as src.
@param flags operation flags.
@sa  dct, dft, idft, getOptimalDFTSize

</member>
        <member name="M:cv.idft(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.

idft(src, dst, flags) is equivalent to dft(src, dst, flags | DFT_INVERSE) .
@note None of dft and idft scales the result by default. So, you should pass DFT_SCALE to one of
dft or idft explicitly to make these transforms mutually inverse.
@sa dft, dct, idct, mulSpectrums, getOptimalDFTSize
@param src input floating-point real or complex array.
@param dst output array whose size and type depend on the flags.
@param flags operation flags (see dft and cv::DftFlags).
@param nonzeroRows number of dst rows to process; the rest of the rows have undefined content (see
the convolution sample in dft description.

</member>
        <member name="M:cv.Mahalanobis(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates the Mahalanobis distance between two vectors.

The function Mahalanobis calculates and returns the weighted distance between two vectors:
\f[d( \texttt{vec1} , \texttt{vec2} )= \sqrt{\sum_{i,j}{\texttt{icovar(i,j)}\cdot(\texttt{vec1}(I)-\texttt{vec2}(I))\cdot(\texttt{vec1(j)}-\texttt{vec2(j)})} }\f]
The covariance matrix may be calculated using the cv::calcCovarMatrix function and then inverted using
the invert function (preferably using the cv::DECOMP_SVD method, as the most accurate).
@param v1 first 1D input vector.
@param v2 second 1D input vector.
@param icovar inverse covariance matrix.

</member>
        <member name="M:cv.SVBackSubst(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
wrap SVD::backSubst 
</member>
        <member name="M:cv.SVDecomp(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
wrap SVD::compute 
</member>
        <member name="M:cv.PCABackProject(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
wrap PCA::backProject 
</member>
        <member name="M:cv.PCAProject(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
wrap PCA::project 
</member>
        <member name="M:cv.PCACompute(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
wrap PCA::operator() 
</member>
        <member name="M:cv.PCACompute(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
wrap PCA::operator() 
</member>
        <member name="M:cv.calcCovarMatrix(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@overload
@note use cv::COVAR_ROWS or cv::COVAR_COLS flag
@param samples samples stored as rows/columns of a single matrix.
@param covar output covariance matrix of the type ctype and square size.
@param mean input or output (depending on the flags) array as the average value of the input vectors.
@param flags operation flags as a combination of cv::CovarFlags
@param ctype type of the matrixl; it equals 'CV_64F' by default.

</member>
        <member name="M:cv.calcCovarMatrix(cv.Mat!System.Runtime.CompilerServices.IsConst*,System.Int32,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief Calculates the covariance matrix of a set of vectors.

The functions calcCovarMatrix calculate the covariance matrix and, optionally, the mean vector of
the set of input vectors.
@param samples samples stored as separate matrices
@param nsamples number of samples
@param covar output covariance matrix of the type ctype and square size.
@param mean input or output (depending on the flags) array as the average value of the input vectors.
@param flags operation flags as a combination of cv::CovarFlags
@param ctype type of the matrixl; it equals 'CV_64F' by default.
@sa PCA, mulTransposed, Mahalanobis
@todo InputArrayOfArrays

</member>
        <member name="M:cv.solvePoly(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Finds the real or complex roots of a polynomial equation.

The function solvePoly finds real and complex roots of a polynomial equation:
\f[\texttt{coeffs} [n] x^{n} +  \texttt{coeffs} [n-1] x^{n-1} + ... +  \texttt{coeffs} [1] x +  \texttt{coeffs} [0] = 0\f]
@param coeffs array of polynomial coefficients.
@param roots output (complex) array of roots.
@param maxIters maximum number of iterations the algorithm does.

</member>
        <member name="M:cv.solveCubic(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Finds the real roots of a cubic equation.

The function solveCubic finds the real roots of a cubic equation:
-   if coeffs is a 4-element vector:
\f[\texttt{coeffs} [0] x^3 +  \texttt{coeffs} [1] x^2 +  \texttt{coeffs} [2] x +  \texttt{coeffs} [3] = 0\f]
-   if coeffs is a 3-element vector:
\f[x^3 +  \texttt{coeffs} [0] x^2 +  \texttt{coeffs} [1] x +  \texttt{coeffs} [2] = 0\f]

The roots are stored in the roots array.
@param coeffs equation coefficients, an array of 3 or 4 elements.
@param roots output array of real roots that has 1 or 3 elements.

</member>
        <member name="M:cv.sortIdx(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Sorts each row or each column of a matrix.

The function sortIdx sorts each matrix row or each matrix column in the
ascending or descending order. So you should pass two operation flags to
get desired behaviour. Instead of reordering the elements themselves, it
stores the indices of sorted elements in the output array. For example:
@code
    Mat A = Mat::eye(3,3,CV_32F), B;
    sortIdx(A, B, SORT_EVERY_ROW + SORT_ASCENDING);
    // B will probably contain
    // (because of equal elements in A some permutations are possible):
    // [[1, 2, 0], [0, 2, 1], [0, 1, 2]]
@endcode
@param src input single-channel array.
@param dst output integer array of the same size as src.
@param flags operation flags that could be a combination of cv::SortFlags
@sa sort, randShuffle

</member>
        <member name="M:cv.sort(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Sorts each row or each column of a matrix.

The function sort sorts each matrix row or each matrix column in
ascending or descending order. So you should pass two operation flags to
get desired behaviour. If you want to sort matrix rows or columns
lexicographically, you can use STL std::sort generic function with the
proper comparison predicate.

@param src input single-channel array.
@param dst output array of the same size and type as src.
@param flags operation flags, a combination of cv::SortFlags
@sa sortIdx, randShuffle

</member>
        <member name="M:cv.solve(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Solves one or more linear systems or least-squares problems.

The function solve solves a linear system or least-squares problem (the
latter is possible with SVD or QR methods, or by specifying the flag
DECOMP_NORMAL ):
\f[\texttt{dst} =  \arg \min _X \| \texttt{src1} \cdot \texttt{X} -  \texttt{src2} \|\f]

If DECOMP_LU or DECOMP_CHOLESKY method is used, the function returns 1
if src1 (or \f$\texttt{src1}^T\texttt{src1}\f$ ) is non-singular. Otherwise,
it returns 0. In the latter case, dst is not valid. Other methods find a
pseudo-solution in case of a singular left-hand side part.

@note If you want to find a unity-norm solution of an under-defined
singular system \f$\texttt{src1}\cdot\texttt{dst}=0\f$ , the function solve
will not do the work. Use SVD::solveZ instead.

@param src1 input matrix on the left-hand side of the system.
@param src2 input matrix on the right-hand side of the system.
@param dst output solution.
@param flags solution (matrix inversion) method (cv::DecompTypes)
@sa invert, SVD, eigen

</member>
        <member name="M:cv.invert(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Finds the inverse or pseudo-inverse of a matrix.

The function invert inverts the matrix src and stores the result in dst
. When the matrix src is singular or non-square, the function calculates
the pseudo-inverse matrix (the dst matrix) so that norm(src\*dst - I) is
minimal, where I is an identity matrix.

In case of the DECOMP_LU method, the function returns non-zero value if
the inverse has been successfully calculated and 0 if src is singular.

In case of the DECOMP_SVD method, the function returns the inverse
condition number of src (the ratio of the smallest singular value to the
largest singular value) and 0 if src is singular. The SVD method
calculates a pseudo-inverse matrix if src is singular.

Similarly to DECOMP_LU, the method DECOMP_CHOLESKY works only with
non-singular square matrices that should also be symmetrical and
positively defined. In this case, the function stores the inverted
matrix in dst and returns non-zero. Otherwise, it returns 0.

@param src input floating-point M x N matrix.
@param dst output matrix of N x M size and the same type as src.
@param flags inversion method (cv::DecompTypes)
@sa solve, SVD

</member>
        <member name="M:cv.trace(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Returns the trace of a matrix.

The function trace returns the sum of the diagonal elements of the
matrix mtx .
\f[\mathrm{tr} ( \texttt{mtx} ) =  \sum _i  \texttt{mtx} (i,i)\f]
@param mtx input matrix.

</member>
        <member name="M:cv.setIdentity(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Initializes a scaled identity matrix.

The function setIdentity initializes a scaled identity matrix:
\f[\texttt{mtx} (i,j)= \fork{\texttt{value}}{ if \(i=j\)}{0}{otherwise}\f]

The function can also be emulated using the matrix initializers and the
matrix expressions:
@code
    Mat A = Mat::eye(4, 3, CV_32F)*5;
    // A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]
@endcode
@param mtx matrix to initialize (not necessarily square).
@param s value to assign to diagonal elements.
@sa Mat::zeros, Mat::ones, Mat::setTo, Mat::operator=

</member>
        <member name="M:cv.transform(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Performs the matrix transformation of every array element.

The function transform performs the matrix transformation of every
element of the array src and stores the results in dst :
\f[\texttt{dst} (I) =  \texttt{m} \cdot \texttt{src} (I)\f]
(when m.cols=src.channels() ), or
\f[\texttt{dst} (I) =  \texttt{m} \cdot [ \texttt{src} (I); 1]\f]
(when m.cols=src.channels()+1 )

Every element of the N -channel array src is interpreted as N -element
vector that is transformed using the M x N or M x (N+1) matrix m to
M-element vector - the corresponding element of the output array dst .

The function may be used for geometrical transformation of
N -dimensional points, arbitrary linear color space transformation (such
as various kinds of RGB to YUV transforms), shuffling the image
channels, and so forth.
@param src input array that must have as many channels (1 to 4) as
m.cols or m.cols-1.
@param dst output array of the same size and depth as src; it has as
many channels as m.rows.
@param m transformation 2x2 or 2x3 floating-point matrix.
@sa perspectiveTransform, getAffineTransform, estimateRigidTransform, warpAffine, warpPerspective

</member>
        <member name="M:cv.transpose(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Transposes a matrix.

The function transpose transposes the matrix src :
\f[\texttt{dst} (i,j) =  \texttt{src} (j,i)\f]
@note No complex conjugation is done in case of a complex matrix. It it
should be done separately if needed.
@param src input array.
@param dst output array of the same type as src.

</member>
        <member name="M:cv.mulTransposed(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32)">
@brief Calculates the product of a matrix and its transposition.

The function mulTransposed calculates the product of src and its
transposition:
\f[\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )\f]
if aTa=true , and
\f[\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T\f]
otherwise. The function is used to calculate the covariance matrix. With
zero delta, it can be used as a faster substitute for general matrix
product A\*B when B=A'
@param src input single-channel matrix. Note that unlike gemm, the
function can multiply not only floating-point matrices.
@param dst output square matrix.
@param aTa Flag specifying the multiplication ordering. See the
description below.
@param delta Optional delta matrix subtracted from src before the
multiplication. When the matrix is empty ( delta=noArray() ), it is
assumed to be zero, that is, nothing is subtracted. If it has the same
size as src , it is simply subtracted. Otherwise, it is "repeated" (see
repeat ) to cover the full src and then subtracted. Type of the delta
matrix, when it is not empty, must be the same as the type of created
output matrix. See the dtype parameter description below.
@param scale Optional scale factor for the matrix product.
@param dtype Optional type of the output matrix. When it is negative,
the output matrix will have the same type as src . Otherwise, it will be
type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F .
@sa calcCovarMatrix, gemm, repeat, reduce

</member>
        <member name="M:cv.gemm(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Performs generalized matrix multiplication.

The function performs generalized matrix multiplication similar to the
gemm functions in BLAS level 3. For example,
`gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)`
corresponds to
\f[\texttt{dst} =  \texttt{alpha} \cdot \texttt{src1} ^T  \cdot \texttt{src2} +  \texttt{beta} \cdot \texttt{src3} ^T\f]

In case of complex (two-channel) data, performed a complex matrix
multiplication.

The function can be replaced with a matrix expression. For example, the
above call can be replaced with:
@code{.cpp}
    dst = alpha*src1.t()*src2 + beta*src3.t();
@endcode
@param src1 first multiplied input matrix that could be real(CV_32FC1,
CV_64FC1) or complex(CV_32FC2, CV_64FC2).
@param src2 second multiplied input matrix of the same type as src1.
@param alpha weight of the matrix product.
@param src3 third optional delta matrix added to the matrix product; it
should have the same type as src1 and src2.
@param beta weight of src3.
@param dst output matrix; it has the proper size and the same type as
input matrices.
@param flags operation flags (cv::GemmFlags)
@sa mulTransposed , transform

</member>
        <member name="M:cv.patchNaNs(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief converts NaN's to the given number

</member>
        <member name="M:cv.magnitude(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates the magnitude of 2D vectors.

The function magnitude calculates the magnitude of 2D vectors formed
from the corresponding elements of x and y arrays:
\f[\texttt{dst} (I) =  \sqrt{\texttt{x}(I)^2 + \texttt{y}(I)^2}\f]
@param x floating-point array of x-coordinates of the vectors.
@param y floating-point array of y-coordinates of the vectors; it must
have the same size as x.
@param magnitude output array of the same size and type as x.
@sa cartToPolar, polarToCart, phase, sqrt

</member>
        <member name="M:cv.phase(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief Calculates the rotation angle of 2D vectors.

The function phase calculates the rotation angle of each 2D vector that
is formed from the corresponding elements of x and y :
\f[\texttt{angle} (I) =  \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))\f]

The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 ,
the corresponding angle(I) is set to 0.
@param x input floating-point array of x-coordinates of 2D vectors.
@param y input array of y-coordinates of 2D vectors; it must have the
same size and the same type as x.
@param angle output array of vector angles; it has the same size and
same type as x .
@param angleInDegrees when true, the function calculates the angle in
degrees, otherwise, they are measured in radians.

</member>
        <member name="M:cv.cartToPolar(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief Calculates the magnitude and angle of 2D vectors.

The function cartToPolar calculates either the magnitude, angle, or both
for every 2D vector (x(I),y(I)):
\f[\begin{array}{l} \texttt{magnitude} (I)= \sqrt{\texttt{x}(I)^2+\texttt{y}(I)^2} , \\ \texttt{angle} (I)= \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))[ \cdot180 / \pi ] \end{array}\f]

The angles are calculated with accuracy about 0.3 degrees. For the point
(0,0), the angle is set to 0.
@param x array of x-coordinates; this must be a single-precision or
double-precision floating-point array.
@param y array of y-coordinates, that must have the same size and same type as x.
@param magnitude output array of magnitudes of the same size and type as x.
@param angle output array of angles that has the same size and type as
x; the angles are measured in radians (from 0 to 2\*Pi) or in degrees (0 to 360 degrees).
@param angleInDegrees a flag, indicating whether the angles are measured
in radians (which is by default), or in degrees.
@sa Sobel, Scharr

</member>
        <member name="M:cv.polarToCart(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief Calculates x and y coordinates of 2D vectors from their magnitude and angle.

The function polarToCart calculates the Cartesian coordinates of each 2D
vector represented by the corresponding elements of magnitude and angle:
\f[\begin{array}{l} \texttt{x} (I) =  \texttt{magnitude} (I) \cos ( \texttt{angle} (I)) \\ \texttt{y} (I) =  \texttt{magnitude} (I) \sin ( \texttt{angle} (I)) \\ \end{array}\f]

The relative accuracy of the estimated coordinates is about 1e-6.
@param magnitude input floating-point array of magnitudes of 2D vectors;
it can be an empty matrix (=Mat()), in this case, the function assumes
that all the magnitudes are =1; if it is not empty, it must have the
same size and type as angle.
@param angle input floating-point array of angles of 2D vectors.
@param x output array of x-coordinates of 2D vectors; it has the same
size and type as angle.
@param y output array of y-coordinates of 2D vectors; it has the same
size and type as angle.
@param angleInDegrees when true, the input angles are measured in
degrees, otherwise, they are measured in radians.
@sa cartToPolar, magnitude, phase, exp, log, pow, sqrt

</member>
        <member name="M:cv.log(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates the natural logarithm of every array element.

The function log calculates the natural logarithm of the absolute value
of every element of the input array:
\f[\texttt{dst} (I) =  \fork{\log |\texttt{src}(I)|}{if \(\texttt{src}(I) \ne 0\) }{\texttt{C}}{otherwise}\f]

where C is a large negative number (about -700 in the current
implementation). The maximum relative error is about 7e-6 for
single-precision input and less than 1e-10 for double-precision input.
Special values (NaN, Inf) are not handled.
@param src input array.
@param dst output array of the same size and type as src .
@sa exp, cartToPolar, polarToCart, phase, pow, sqrt, magnitude

</member>
        <member name="M:cv.exp(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates the exponent of every array element.

The function exp calculates the exponent of every element of the input
array:
\f[\texttt{dst} [I] = e^{ src(I) }\f]

The maximum relative error is about 7e-6 for single-precision input and
less than 1e-10 for double-precision input. Currently, the function
converts denormalized values to zeros on output. Special values (NaN,
Inf) are not handled.
@param src input array.
@param dst output array of the same size and type as src.
@sa log , cartToPolar , polarToCart , phase , pow , sqrt , magnitude

</member>
        <member name="M:cv.sqrt(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates a square root of array elements.

The functions sqrt calculate a square root of each input array element.
In case of multi-channel arrays, each channel is processed
independently. The accuracy is approximately the same as of the built-in
std::sqrt .
@param src input floating-point array.
@param dst output array of the same size and type as src.

</member>
        <member name="M:cv.max(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates per-element maximum of two arrays or an array and a scalar.

The functions max calculate the per-element maximum of two arrays:
\f[\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{src2} (I))\f]
or array and a scalar:
\f[\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{value} )\f]
@param src1 first input array.
@param src2 second input array of the same size and type as src1 .
@param dst output array of the same size and type as src1.
@sa  min, compare, inRange, minMaxLoc, @ref MatrixExpressions

</member>
        <member name="M:cv.min(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates per-element minimum of two arrays or an array and a scalar.

The functions min calculate the per-element minimum of two arrays:
\f[\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{src2} (I))\f]
or array and a scalar:
\f[\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{value} )\f]
@param src1 first input array.
@param src2 second input array of the same size and type as src1.
@param dst output array of the same size and type as src1.
@sa max, compare, inRange, minMaxLoc

</member>
        <member name="M:cv.inRange(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  Checks if array elements lie between the elements of two other arrays.

The function checks the range as follows:
-   For every element of a single-channel input array:
    \f[\texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0\f]
-   For two-channel arrays:
    \f[\texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0  \land \texttt{lowerb} (I)_1  \leq \texttt{src} (I)_1 \leq  \texttt{upperb} (I)_1\f]
-   and so forth.

That is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the
specified 1D, 2D, 3D, ... box and 0 otherwise.

When the lower and/or upper boundary parameters are scalars, the indexes
(I) at lowerb and upperb in the above formulas should be omitted.
@param src first input array.
@param lowerb inclusive lower boundary array or a scalar.
@param upperb inclusive upper boundary array or a scalar.
@param dst output array of the same size as src and CV_8U type.

</member>
        <member name="M:cv.bitwise_not(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  Inverts every bit of an array.

The function calculates per-element bit-wise inversion of the input
array:
\f[\texttt{dst} (I) =  \neg \texttt{src} (I)\f]
In case of a floating-point input array, its machine-specific bit
representation (usually IEEE754-compliant) is used for the operation. In
case of multi-channel arrays, each channel is processed independently.
@param src input array.
@param dst output array that has the same size and type as the input
array.
@param mask optional operation mask, 8-bit single channel array, that
specifies elements of the output array to be changed.

</member>
        <member name="M:cv.bitwise_xor(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates the per-element bit-wise "exclusive or" operation on two
arrays or an array and a scalar.

The function calculates the per-element bit-wise logical "exclusive-or"
operation for:
*   Two arrays when src1 and src2 have the same size:
    \f[\texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\f]
*   An array and a scalar when src2 is constructed from Scalar or has
    the same number of elements as `src1.channels()`:
    \f[\texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} \quad \texttt{if mask} (I) \ne0\f]
*   A scalar and an array when src1 is constructed from Scalar or has
    the same number of elements as `src2.channels()`:
    \f[\texttt{dst} (I) =  \texttt{src1}  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\f]
In case of floating-point arrays, their machine-specific bit
representations (usually IEEE754-compliant) are used for the operation.
In case of multi-channel arrays, each channel is processed
independently. In the 2nd and 3rd cases above, the scalar is first
converted to the array type.
@param src1 first input array or a scalar.
@param src2 second input array or a scalar.
@param dst output array that has the same size and type as the input
arrays.
@param mask optional operation mask, 8-bit single channel array, that
specifies elements of the output array to be changed.

</member>
        <member name="M:cv.bitwise_or(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates the per-element bit-wise disjunction of two arrays or an
array and a scalar.

The function calculates the per-element bit-wise logical disjunction for:
*   Two arrays when src1 and src2 have the same size:
    \f[\texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\f]
*   An array and a scalar when src2 is constructed from Scalar or has
    the same number of elements as `src1.channels()`:
    \f[\texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} \quad \texttt{if mask} (I) \ne0\f]
*   A scalar and an array when src1 is constructed from Scalar or has
    the same number of elements as `src2.channels()`:
    \f[\texttt{dst} (I) =  \texttt{src1}  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\f]
In case of floating-point arrays, their machine-specific bit
representations (usually IEEE754-compliant) are used for the operation.
In case of multi-channel arrays, each channel is processed
independently. In the second and third cases above, the scalar is first
converted to the array type.
@param src1 first input array or a scalar.
@param src2 second input array or a scalar.
@param dst output array that has the same size and type as the input
arrays.
@param mask optional operation mask, 8-bit single channel array, that
specifies elements of the output array to be changed.

</member>
        <member name="M:cv.vconcat(cv.Mat!System.Runtime.CompilerServices.IsConst*,System.UInt32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Applies vertical concatenation to given matrices.

The function vertically concatenates two or more cv::Mat matrices (with the same number of cols).
@code{.cpp}
    cv::Mat matArray[] = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)),
                           cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)),
                           cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};

    cv::Mat out;
    cv::vconcat( matArray, 3, out );
    //out:
    //[1,   1,   1,   1;
    // 2,   2,   2,   2;
    // 3,   3,   3,   3]
@endcode
@param src input array or vector of matrices. all of the matrices must have the same number of cols and the same depth.
@param nsrc number of matrices in src.
@param dst output array. It has the same number of cols and depth as the src, and the sum of rows of the src.
@sa cv::hconcat(const Mat*, size_t, OutputArray), @sa cv::hconcat(InputArrayOfArrays, OutputArray) and @sa cv::hconcat(InputArray, InputArray, OutputArray)

</member>
        <member name="M:cv.hconcat(cv.Mat!System.Runtime.CompilerServices.IsConst*,System.UInt32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Applies horizontal concatenation to given matrices.

The function horizontally concatenates two or more cv::Mat matrices (with the same number of rows).
@code{.cpp}
    cv::Mat matArray[] = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)),
                           cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)),
                           cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};

    cv::Mat out;
    cv::hconcat( matArray, 3, out );
    //out:
    //[1, 2, 3;
    // 1, 2, 3;
    // 1, 2, 3;
    // 1, 2, 3]
@endcode
@param src input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.
@param nsrc number of matrices in src.
@param dst output array. It has the same number of rows and depth as the src, and the sum of cols of the src.
@sa cv::vconcat(const Mat*, size_t, OutputArray), @sa cv::vconcat(InputArrayOfArrays, OutputArray) and @sa cv::vconcat(InputArray, InputArray, OutputArray)

</member>
        <member name="M:cv.repeat(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@overload
@param src input array to replicate.
@param ny Flag to specify how many times the src is repeated along the
vertical axis.
@param nx Flag to specify how many times the src is repeated along the
horizontal axis.

</member>
        <member name="M:cv.repeat(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Fills the output array with repeated copies of the input array.

The functions repeat duplicate the input array one or more times along each of the two axes:
\f[\texttt{dst} _{ij}= \texttt{src} _{i\mod src.rows, \; j\mod src.cols }\f]
The second variant of the function is more convenient to use with @ref MatrixExpressions.
@param src input array to replicate.
@param dst output array of the same type as src.
@param ny Flag to specify how many times the src is repeated along the
vertical axis.
@param nx Flag to specify how many times the src is repeated along the
horizontal axis.
@sa reduce

</member>
        <member name="M:cv.insertChannel(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief inserts a single channel to dst (coi is 0-based index)
@todo document

</member>
        <member name="M:cv.extractChannel(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief extracts a single channel from src (coi is 0-based index)
@todo document

</member>
        <member name="M:cv.mixChannels(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
@param src input array or vector of matricesl; all of the matrices must have the same size and the
same depth.
@param dst output array or vector of matrices; all the matrices *must be allocated*; their size and
depth must be the same as in src[0].
@param fromTo array of index pairs specifying which channels are copied and where; fromTo[k\*2] is
a 0-based index of the input channel in src, fromTo[k\*2+1] is an index of the output channel in
dst; the continuous channel numbering is used: the first input image channels are indexed from 0 to
src[0].channels()-1, the second input image channels are indexed from src[0].channels() to
src[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image
channels; as a special case, when fromTo[k\*2] is negative, the corresponding output channel is
filled with zero .

</member>
        <member name="M:cv.mixChannels(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
@overload
@param src input array or vector of matricesl; all of the matrices must have the same size and the
same depth.
@param dst output array or vector of matrices; all the matrices *must be allocated*; their size and
depth must be the same as in src[0].
@param fromTo array of index pairs specifying which channels are copied and where; fromTo[k\*2] is
a 0-based index of the input channel in src, fromTo[k\*2+1] is an index of the output channel in
dst; the continuous channel numbering is used: the first input image channels are indexed from 0 to
src[0].channels()-1, the second input image channels are indexed from src[0].channels() to
src[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image
channels; as a special case, when fromTo[k\*2] is negative, the corresponding output channel is
filled with zero .
@param npairs number of index pairs in fromTo.

</member>
        <member name="M:cv.split(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
@param m input multi-channel array.
@param mv output vector of arrays; the arrays themselves are reallocated, if needed.

</member>
        <member name="M:cv.split(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*)">
@brief Divides a multi-channel array into several single-channel arrays.

The functions split split a multi-channel array into separate single-channel arrays:
\f[\texttt{mv} [c](I) =  \texttt{src} (I)_c\f]
If you need to extract a single channel or do some other sophisticated channel permutation, use
mixChannels .
@param src input multi-channel array.
@param mvbegin output array; the number of arrays must match src.channels(); the arrays themselves are
reallocated, if needed.
@sa merge, mixChannels, cvtColor

</member>
        <member name="M:cv.merge(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
@param mv input vector of matrices to be merged; all the matrices in mv must have the same
size and the same depth.
@param dst output array of the same size and the same depth as mv[0]; The number of channels will
be the total number of channels in the matrix array.

</member>
        <member name="M:cv.merge(cv.Mat!System.Runtime.CompilerServices.IsConst*,System.UInt32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Creates one multichannel array out of several single-channel ones.

The functions merge merge several arrays to make a single multi-channel array. That is, each
element of the output array will be a concatenation of the elements of the input arrays, where
elements of i-th input array are treated as mv[i].channels()-element vectors.

The function split does the reverse operation. If you need to shuffle channels in some other
advanced way, use mixChannels .
@param mv input array of matrices to be merged; all the matrices in mv must have the same
size and the same depth.
@param count number of input matrices when mv is a plain C array; it must be greater than zero.
@param dst output array of the same size and the same depth as mv[0]; The number of channels will
be the total number of channels in the matrix array.
@sa  mixChannels, split, Mat::reshape

</member>
        <member name="M:cv.reduce(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
@brief Reduces a matrix to a vector.

The function reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of
1D vectors and performing the specified operation on the vectors until a single row/column is
obtained. For example, the function can be used to compute horizontal and vertical projections of a
raster image. In case of REDUCE_SUM and REDUCE_AVG , the output may have a larger element
bit-depth to preserve accuracy. And multi-channel arrays are also supported in these two reduction
modes.
@param src input 2D matrix.
@param dst output vector. Its size and type is defined by dim and dtype parameters.
@param dim dimension index along which the matrix is reduced. 0 means that the matrix is reduced to
a single row. 1 means that the matrix is reduced to a single column.
@param rtype reduction operation that could be one of cv::ReduceTypes
@param dtype when negative, the output vector will have the same type as the input matrix,
otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()).
@sa repeat

</member>
        <member name="M:cv.minMaxLoc(cv.SparseMat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*,System.Double*,System.Int32*,System.Int32*)">
@overload
@param a input single-channel array.
@param minVal pointer to the returned minimum value; NULL is used if not required.
@param maxVal pointer to the returned maximum value; NULL is used if not required.
@param minIdx pointer to the returned minimum location (in nD case); NULL is used if not required;
Otherwise, it must point to an array of src.dims elements, the coordinates of the minimum element
in each dimension are stored there sequentially.
@param maxIdx pointer to the returned maximum location (in nD case). NULL is used if not required.

</member>
        <member name="M:cv.minMaxIdx(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*,System.Double*,System.Int32*,System.Int32*,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Finds the global minimum and maximum in an array

The function minMaxIdx finds the minimum and maximum element values and their positions. The
extremums are searched across the whole array or, if mask is not an empty array, in the specified
array region. The function does not work with multi-channel arrays. If you need to find minimum or
maximum elements across all the channels, use Mat::reshape first to reinterpret the array as
single-channel. Or you may extract the particular channel using either extractImageCOI , or
mixChannels , or split . In case of a sparse matrix, the minimum is found among non-zero elements
only.
@note When minIdx is not NULL, it must have at least 2 elements (as well as maxIdx), even if src is
a single-row or single-column matrix. In OpenCV (following MATLAB) each array has at least 2
dimensions, i.e. single-column matrix is Mx1 matrix (and therefore minIdx/maxIdx will be
(i1,0)/(i2,0)) and single-row matrix is 1xN matrix (and therefore minIdx/maxIdx will be
(0,j1)/(0,j2)).
@param src input single-channel array.
@param minVal pointer to the returned minimum value; NULL is used if not required.
@param maxVal pointer to the returned maximum value; NULL is used if not required.
@param minIdx pointer to the returned minimum location (in nD case); NULL is used if not required;
Otherwise, it must point to an array of src.dims elements, the coordinates of the minimum element
in each dimension are stored there sequentially.
@param maxIdx pointer to the returned maximum location (in nD case). NULL is used if not required.
@param mask specified array region

</member>
        <member name="M:cv.minMaxLoc(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*,System.Double*,cv.Point_&lt;System.Int32&gt;*,cv.Point_&lt;System.Int32&gt;*,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Finds the global minimum and maximum in an array.

The functions minMaxLoc find the minimum and maximum element values and their positions. The
extremums are searched across the whole array or, if mask is not an empty array, in the specified
array region.

The functions do not work with multi-channel arrays. If you need to find minimum or maximum
elements across all the channels, use Mat::reshape first to reinterpret the array as
single-channel. Or you may extract the particular channel using either extractImageCOI , or
mixChannels , or split .
@param src input single-channel array.
@param minVal pointer to the returned minimum value; NULL is used if not required.
@param maxVal pointer to the returned maximum value; NULL is used if not required.
@param minLoc pointer to the returned minimum location (in 2D case); NULL is used if not required.
@param maxLoc pointer to the returned maximum location (in 2D case); NULL is used if not required.
@param mask optional mask used to select a sub-array.
@sa max, min, compare, inRange, extractImageCOI, mixChannels, split, Mat::reshape

</member>
        <member name="M:cv.normalize(cv.SparseMat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.SparseMat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32)">
@overload
@param src input array.
@param dst output array of the same size as src .
@param alpha norm value to normalize to or the lower range boundary in case of the range
normalization.
@param normType normalization type (see cv::NormTypes).

</member>
        <member name="M:cv.normalize(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Int32,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Normalizes the norm or value range of an array.

The functions normalize scale and shift the input array elements so that
\f[\| \texttt{dst} \| _{L_p}= \texttt{alpha}\f]
(where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that
\f[\min _I  \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I  \texttt{dst} (I)= \texttt{beta}\f]

when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be
normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
min-max but modify the whole array, you can use norm and Mat::convertTo.

In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
the range transformation for sparse matrices is not allowed since it can shift the zero level.

@param src input array.
@param dst output array of the same size as src .
@param alpha norm value to normalize to or the lower range boundary in case of the range
normalization.
@param beta upper range boundary in case of the range normalization; it is not used for the norm
normalization.
@param norm_type normalization type (see cv::NormTypes).
@param dtype when negative, the output array has the same type as src; otherwise, it has the same
number of channels as src and the depth =CV_MAT_DEPTH(dtype).
@param mask optional operation mask.
@sa norm, Mat::convertTo, SparseMat::convertTo

</member>
        <member name="M:cv.batchDistance(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
@brief naive nearest neighbor finder

see http://en.wikipedia.org/wiki/Nearest_neighbor_search
@todo document

</member>
        <member name="M:cv.PSNR(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief computes PSNR image/video quality metric

see http://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio for details
@todo document

</member>
        <member name="M:cv.norm(cv.SparseMat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@overload
@param src first input array.
@param normType type of the norm (see cv::NormTypes).

</member>
        <member name="M:cv.norm(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
@param src1 first input array.
@param src2 second input array of the same size and the same type as src1.
@param normType type of the norm (cv::NormTypes).
@param mask optional operation mask; it must have the same size as src1 and CV_8UC1 type.

</member>
        <member name="M:cv.norm(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates an absolute array norm, an absolute difference norm, or a
relative difference norm.

The functions norm calculate an absolute norm of src1 (when there is no
src2 ):

\f[norm =  \forkthree{\|\texttt{src1}\|_{L_{\infty}} =  \max _I | \texttt{src1} (I)|}{if  \(\texttt{normType} = \texttt{NORM\_INF}\) }
{ \| \texttt{src1} \| _{L_1} =  \sum _I | \texttt{src1} (I)|}{if  \(\texttt{normType} = \texttt{NORM\_L1}\) }
{ \| \texttt{src1} \| _{L_2} =  \sqrt{\sum_I \texttt{src1}(I)^2} }{if  \(\texttt{normType} = \texttt{NORM\_L2}\) }\f]

or an absolute or relative difference norm if src2 is there:

\f[norm =  \forkthree{\|\texttt{src1}-\texttt{src2}\|_{L_{\infty}} =  \max _I | \texttt{src1} (I) -  \texttt{src2} (I)|}{if  \(\texttt{normType} = \texttt{NORM\_INF}\) }
{ \| \texttt{src1} - \texttt{src2} \| _{L_1} =  \sum _I | \texttt{src1} (I) -  \texttt{src2} (I)|}{if  \(\texttt{normType} = \texttt{NORM\_L1}\) }
{ \| \texttt{src1} - \texttt{src2} \| _{L_2} =  \sqrt{\sum_I (\texttt{src1}(I) - \texttt{src2}(I))^2} }{if  \(\texttt{normType} = \texttt{NORM\_L2}\) }\f]

or

\f[norm =  \forkthree{\frac{\|\texttt{src1}-\texttt{src2}\|_{L_{\infty}}    }{\|\texttt{src2}\|_{L_{\infty}} }}{if  \(\texttt{normType} = \texttt{NORM\_RELATIVE\_INF}\) }
{ \frac{\|\texttt{src1}-\texttt{src2}\|_{L_1} }{\|\texttt{src2}\|_{L_1}} }{if  \(\texttt{normType} = \texttt{NORM\_RELATIVE\_L1}\) }
{ \frac{\|\texttt{src1}-\texttt{src2}\|_{L_2} }{\|\texttt{src2}\|_{L_2}} }{if  \(\texttt{normType} = \texttt{NORM\_RELATIVE\_L2}\) }\f]

The functions norm return the calculated norm.

When the mask parameter is specified and it is not empty, the norm is
calculated only over the region specified by the mask.

A multi-channel input arrays are treated as a single-channel, that is,
the results for all channels are combined.

@param src1 first input array.
@param normType type of the norm (see cv::NormTypes).
@param mask optional operation mask; it must have the same size as src1 and CV_8UC1 type.

</member>
        <member name="M:cv.meanStdDev(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates a mean and standard deviation of array elements.

The function meanStdDev calculates the mean and the standard deviation M
of array elements independently for each channel and returns it via the
output parameters:
\f[\begin{array}{l} N =  \sum _{I, \texttt{mask} (I)  \ne 0} 1 \\ \texttt{mean} _c =  \frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \texttt{src} (I)_c}{N} \\ \texttt{stddev} _c =  \sqrt{\frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \left ( \texttt{src} (I)_c -  \texttt{mean} _c \right )^2}{N}} \end{array}\f]
When all the mask elements are 0's, the functions return
mean=stddev=Scalar::all(0).
@note The calculated standard deviation is only the diagonal of the
complete normalized covariance matrix. If the full matrix is needed, you
can reshape the multi-channel array M x N to the single-channel array
M\*N x mtx.channels() (only possible when the matrix is continuous) and
then pass the matrix to calcCovarMatrix .
@param src input array that should have from 1 to 4 channels so that the results can be stored in
Scalar_ 's.
@param mean output parameter: calculated mean value.
@param stddev output parameter: calculateded standard deviation.
@param mask optional operation mask.
@sa  countNonZero, mean, norm, minMaxLoc, calcCovarMatrix

</member>
        <member name="M:cv.mean(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates an average (mean) of array elements.

The function mean calculates the mean value M of array elements,
independently for each channel, and return it:
\f[\begin{array}{l} N =  \sum _{I: \; \texttt{mask} (I) \ne 0} 1 \\ M_c =  \left ( \sum _{I: \; \texttt{mask} (I) \ne 0}{ \texttt{mtx} (I)_c} \right )/N \end{array}\f]
When all the mask elements are 0's, the functions return Scalar::all(0)
@param src input array that should have from 1 to 4 channels so that the result can be stored in
Scalar_ .
@param mask optional operation mask.
@sa  countNonZero, meanStdDev, norm, minMaxLoc

</member>
        <member name="M:cv.countNonZero(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Counts non-zero array elements.

The function returns the number of non-zero elements in src :
\f[\sum _{I: \; \texttt{src} (I) \ne0 } 1\f]
@param src single-channel array.
@sa  mean, meanStdDev, norm, minMaxLoc, calcCovarMatrix

</member>
        <member name="M:cv.sum(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates the sum of array elements.

The functions sum calculate and return the sum of array elements,
independently for each channel.
@param src input array that must have from 1 to 4 channels.
@sa  countNonZero, mean, meanStdDev, norm, minMaxLoc, reduce

</member>
        <member name="M:cv.LUT(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Performs a look-up table transform of an array.

The function LUT fills the output array with values from the look-up table. Indices of the entries
are taken from the input array. That is, the function processes each element of src as follows:
\f[\texttt{dst} (I)  \leftarrow \texttt{lut(src(I) + d)}\f]
where
\f[d =  \fork{0}{if \texttt{src} has depth \texttt{CV\_8U}}{128}{if \texttt{src} has depth \texttt{CV\_8S}}\f]
@param src input array of 8-bit elements.
@param lut look-up table of 256 elements; in case of multi-channel input array, the table should
either have a single channel (in this case the same table is used for all channels) or the same
number of channels as in the input array.
@param dst output array of the same size and number of channels as src, and the same depth as lut.
@sa  convertScaleAbs, Mat::convertTo

</member>
        <member name="M:cv.addWeighted(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Calculates the weighted sum of two arrays.

The function addWeighted calculates the weighted sum of two arrays as follows:
\f[\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +  \texttt{gamma} )\f]
where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
channel is processed independently.
The function can be replaced with a matrix expression:
@code{.cpp}
    dst = src1*alpha + src2*beta + gamma;
@endcode
@note Saturation is not applied when the output array has the depth CV_32S. You may even get
result of an incorrect sign in the case of overflow.
@param src1 first input array.
@param alpha weight of the first array elements.
@param src2 second input array of the same size and channel number as src1.
@param beta weight of the second array elements.
@param gamma scalar added to each sum.
@param dst output array that has the same size and number of channels as the input arrays.
@param dtype optional depth of the output array; when both input arrays have the same depth, dtype
can be set to -1, which will be equivalent to src1.depth().
@sa  add, subtract, scaleAdd, Mat::convertTo

</member>
        <member name="M:cv.scaleAdd(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculates the sum of a scaled array and another array.

The function scaleAdd is one of the classical primitive linear algebra operations, known as DAXPY
or SAXPY in [BLAS](http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms). It calculates
the sum of a scaled array and another array:
\f[\texttt{dst} (I)= \texttt{scale} \cdot \texttt{src1} (I) +  \texttt{src2} (I)\f]
The function can also be emulated with a matrix expression, for example:
@code{.cpp}
    Mat A(3, 3, CV_64F);
    ...
    A.row(0) = A.row(1)*2 + A.row(2);
@endcode
@param src1 first input array.
@param alpha scale factor for the first array.
@param src2 second input array of the same size and type as src1.
@param dst output array of the same size and type as src1.
@sa add, addWeighted, subtract, Mat::dot, Mat::convertTo

</member>
        <member name="M:cv.divide(System.Double,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@overload 
</member>
        <member name="M:cv.divide(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32)">
@brief Performs per-element division of two arrays or a scalar by an array.

The functions divide divide one array by another:
\f[\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}\f]
or a scalar by an array when there is no src1 :
\f[\texttt{dst(I) = saturate(scale/src2(I))}\f]

When src2(I) is zero, dst(I) will also be zero. Different channels of
multi-channel arrays are processed independently.

@note Saturation is not applied when the output array has the depth CV_32S. You may even get
result of an incorrect sign in the case of overflow.
@param src1 first input array.
@param src2 second input array of the same size and type as src1.
@param scale scalar factor.
@param dst output array of the same size and type as src2.
@param dtype optional depth of the output array; if -1, dst will have depth src2.depth(), but in
case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth().
@sa  multiply, add, subtract

</member>
        <member name="M:cv.multiply(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32)">
@brief Calculates the per-element scaled product of two arrays.

The function multiply calculates the per-element product of two arrays:

\f[\texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I)  \cdot \texttt{src2} (I))\f]

There is also a @ref MatrixExpressions -friendly variant of the first function. See Mat::mul .

For a not-per-element matrix product, see gemm .

@note Saturation is not applied when the output array has the depth
CV_32S. You may even get result of an incorrect sign in the case of
overflow.
@param src1 first input array.
@param src2 second input array of the same size and the same type as src1.
@param dst output array of the same size and type as src1.
@param scale optional scale factor.
@param dtype optional depth of the output array
@sa add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare,
Mat::convertTo

</member>
        <member name="M:cv.subtract(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Calculates the per-element difference between two arrays or array and a scalar.

The function subtract calculates:
- Difference between two arrays, when both input arrays have the same size and the same number of
channels:
    \f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0\f]
- Difference between an array and a scalar, when src2 is constructed from Scalar or has the same
number of elements as `src1.channels()`:
    \f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0\f]
- Difference between a scalar and an array, when src1 is constructed from Scalar or has the same
number of elements as `src2.channels()`:
    \f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} -  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0\f]
- The reverse difference between a scalar and an array in the case of `SubRS`:
    \f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src2} -  \texttt{src1}(I) ) \quad \texttt{if mask}(I) \ne0\f]
where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
channel is processed independently.

The first function in the list above can be replaced with matrix expressions:
@code{.cpp}
    dst = src1 - src2;
    dst -= src1; // equivalent to subtract(dst, src1, dst);
@endcode
The input arrays and the output array can all have the same or different depths. For example, you
can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of
the output array is determined by dtype parameter. In the second and third cases above, as well as
in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this
case the output array will have the same depth as the input array, be it src1, src2 or both.
@note Saturation is not applied when the output array has the depth CV_32S. You may even get
result of an incorrect sign in the case of overflow.
@param src1 first input array or a scalar.
@param src2 second input array or a scalar.
@param dst output array of the same size and the same number of channels as the input array.
@param mask optional operation mask; this is an 8-bit single channel array that specifies elements
of the output array to be changed.
@param dtype optional depth of the output array
@sa  add, addWeighted, scaleAdd, Mat::convertTo

</member>
        <member name="M:cv.add(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Calculates the per-element sum of two arrays or an array and a scalar.

The function add calculates:
- Sum of two arrays when both input arrays have the same size and the same number of channels:
\f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0\f]
- Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of
elements as `src1.channels()`:
\f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0\f]
- Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of
elements as `src2.channels()`:
\f[\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} +  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0\f]
where `I` is a multi-dimensional index of array elements. In case of multi-channel arrays, each
channel is processed independently.

The first function in the list above can be replaced with matrix expressions:
@code{.cpp}
    dst = src1 + src2;
    dst += src1; // equivalent to add(dst, src1, dst);
@endcode
The input arrays and the output array can all have the same or different depths. For example, you
can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit
floating-point array. Depth of the output array is determined by the dtype parameter. In the second
and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can
be set to the default -1. In this case, the output array will have the same depth as the input
array, be it src1, src2 or both.
@note Saturation is not applied when the output array has the depth CV_32S. You may even get
result of an incorrect sign in the case of overflow.
@param src1 first input array or a scalar.
@param src2 second input array or a scalar.
@param dst output array that has the same size and number of channels as the input array(s); the
depth is defined by dtype or src1/src2.
@param mask optional operation mask - 8-bit single channel array, that specifies elements of the
output array to be changed.
@param dtype optional depth of the output array (see the discussion below).
@sa subtract, addWeighted, scaleAdd, Mat::convertTo

</member>
        <member name="M:cv.copyMakeBorder(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Forms a border around an image.

The function copies the source image into the middle of the destination image. The areas to the
left, to the right, above and below the copied source image will be filled with extrapolated
pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but
what other more complex functions, including your own, may do to simplify image boundary handling.

The function supports the mode when src is already in the middle of dst . In this case, the
function does not copy src itself but simply constructs the border, for example:

@code{.cpp}
    // let border be the same in all directions
    int border=2;
    // constructs a larger image to fit both the image and the border
    Mat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());
    // select the middle part of it w/o copying data
    Mat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));
    // convert image from RGB to grayscale
    cvtColor(rgb, gray, COLOR_RGB2GRAY);
    // form a border in-place
    copyMakeBorder(gray, gray_buf, border, border,
                   border, border, BORDER_REPLICATE);
    // now do some custom filtering ...
    ...
@endcode
@note When the source image is a part (ROI) of a bigger image, the function will try to use the
pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as
if src was not a ROI, use borderType | BORDER_ISOLATED.

@param src Source image.
@param dst Destination image of the same type as src and the size Size(src.cols+left+right,
src.rows+top+bottom) .
@param top
@param bottom
@param left
@param right Parameter specifying how many pixels in each direction from the source image rectangle
to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs
to be built.
@param borderType Border type. See borderInterpolate for details.
@param value Border value if borderType==BORDER_CONSTANT .

@sa  borderInterpolate

</member>
        <member name="M:cv.swap(cv.UMat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.UMat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload 
</member>
        <member name="M:cv.swap(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Swaps two matrices

</member>
        <member name="F:KMEANS_USE_INITIAL_LABELS">
During the first (and possibly the only) attempt, use the
        user-supplied labels instead of computing them from the initial centers. For the second and
        further attempts, use the random or semi-random centers. Use one of KMEANS_\*_CENTERS flag
        to specify the exact method.
</member>
        <member name="F:KMEANS_PP_CENTERS">
Use kmeans++ center initialization by Arthur and Vassilvitskii [Arthur2007].
</member>
        <member name="F:KMEANS_RANDOM_CENTERS">
Select random initial centers in each attempt.
</member>
        <member name="F:COVAR_COLS">
If the flag is
        specified, all the input vectors are stored as columns of the samples matrix. mean should be a
        single-column vector in this case.
</member>
        <member name="F:COVAR_ROWS">
If the flag is
        specified, all the input vectors are stored as rows of the samples matrix. mean should be a
        single-row vector in this case.
</member>
        <member name="F:COVAR_SCALE">
If the flag is specified, the covariance matrix is scaled. In the
        "normal" mode, scale is 1./nsamples . In the "scrambled" mode, scale is the reciprocal of the
        total number of elements in each input vector. By default (if the flag is not specified), the
        covariance matrix is not scaled ( scale=1 ).
</member>
        <member name="F:COVAR_USE_AVG">
If the flag is specified, the function does not calculate mean from
        the input vectors but, instead, uses the passed mean vector. This is useful if mean has been
        pre-calculated or known in advance, or if the covariance matrix is calculated by parts. In
        this case, mean is not a mean vector of the input sub-set of vectors but rather the mean
        vector of the whole set.
</member>
        <member name="F:COVAR_NORMAL">
The output covariance matrix is calculated as:
        \f[\texttt{scale}   \cdot  [  \texttt{vects}  [0]-  \texttt{mean}  , \texttt{vects}  [1]-  \texttt{mean}  ,...]  \cdot  [ \texttt{vects}  [0]- \texttt{mean}  , \texttt{vects}  [1]- \texttt{mean}  ,...]^T,\f]
        covar will be a square matrix of the same size as the total number of elements in each input
        vector. One and only one of COVAR_SCRAMBLED and COVAR_NORMAL must be specified.
</member>
        <member name="F:COVAR_SCRAMBLED">
The output covariance matrix is calculated as:
       \f[\texttt{scale}   \cdot  [  \texttt{vects}  [0]-  \texttt{mean}  , \texttt{vects}  [1]-  \texttt{mean}  ,...]^T  \cdot  [ \texttt{vects}  [0]- \texttt{mean}  , \texttt{vects}  [1]- \texttt{mean}  ,...],\f]
       The covariance matrix will be nsamples x nsamples. Such an unusual covariance matrix is used
       for fast PCA of a set of very large vectors (see, for example, the EigenFaces technique for
       face recognition). Eigenvalues of this "scrambled" matrix match the eigenvalues of the true
       covariance matrix. The "true" eigenvectors can be easily calculated from the eigenvectors of
       the "scrambled" covariance matrix. 
</member>
        <member name="M:cv.op_LeftShift(cv.FileStorage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
@brief Writes data to a file storage.

</member>
        <member name="M:cv.op_LeftShift(cv.FileStorage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief Writes data to a file storage.

</member>
        <member name="M:cv.op_LeftShift(cv.FileStorage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Writes string to a file storage.
@relates cv::FileStorage

</member>
        <member name="M:cv.FileNodeIterator.readRaw(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte*,System.UInt32)">
@brief Reads node elements to the buffer with the specified format.

    Usually it is more convenient to use operator `&gt;&gt;` instead of this method.
    @param fmt Specification of each array element. See @ref format_spec "format specification"
    @param vec Pointer to the destination array.
    @param maxCount Number of elements to read. If it is greater than number of remaining elements then
    all of them will be read.

</member>
        <member name="M:cv.FileNodeIterator.#ctor(cv.FileNodeIterator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param it Iterator to be used as initialization for the created iterator.

</member>
        <member name="M:cv.FileNodeIterator.#ctor(CvFileStorage!System.Runtime.CompilerServices.IsConst*,CvFileNode!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
@overload
    @param fs File storage for the iterator.
    @param node File node for the iterator.
    @param ofs Index of the element in the node. The created iterator will point to this element.

</member>
        <member name="M:cv.FileNodeIterator.#ctor">
@brief The constructors.

    These constructors are used to create a default iterator, set it to specific element in a file node
    or construct it from another iterator.

</member>
        <member name="T:cv.FileNodeIterator">
@brief used to iterate through sequences and mappings.

A standard STL notation, with node.begin(), node.end() denoting the beginning and the end of a
sequence, stored in node. See the data reading sample in the beginning of the section.

</member>
        <member name="M:cv.FileNode.readRaw(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte*,System.UInt32)">
@brief Reads node elements to the buffer with the specified format.

    Usually it is more convenient to use operator `&gt;&gt;` instead of this method.
    @param fmt Specification of each array element. See @ref format_spec "format specification"
    @param vec Pointer to the destination array.
    @param len Number of elements to read. If it is greater than number of remaining elements then all
    of them will be read.

</member>
        <member name="M:cv.FileNode.type">
@brief Returns type of the node.
    @returns Type of the node. See FileNode::Type

</member>
        <member name="M:cv.FileNode.op_Subscript(System.Int32)">
@overload
    @param i Index of an element in the sequence node.

</member>
        <member name="M:cv.FileNode.op_Subscript(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@overload
    @param nodename Name of an element in the mapping node.

</member>
        <member name="M:cv.FileNode.op_Subscript(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Returns element of a mapping node or a sequence node.
    @param nodename Name of an element in the mapping node.
    @returns Returns the element with the given identifier.

</member>
        <member name="M:cv.FileNode.#ctor(cv.FileNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param node File node to be used as initialization for the created file node.

</member>
        <member name="M:cv.FileNode.#ctor(CvFileStorage!System.Runtime.CompilerServices.IsConst*,CvFileNode!System.Runtime.CompilerServices.IsConst*)">
@overload
    @param fs Pointer to the obsolete file storage structure.
    @param node File node to be used as initialization for the created file node.

</member>
        <member name="M:cv.FileNode.#ctor">
@brief The constructors.

    These constructors are used to create a default file node, construct it from obsolete structures or
    from the another file node.

</member>
        <member name="T:cv.FileNode">
@brief File Storage Node class.

The node is used to store each and every element of the file storage opened for reading. When
XML/YAML file is read, it is first parsed and stored in the memory as a hierarchical collection of
nodes. Each node can be a â€śleafâ€ť that is contain a single number or a string, or be a collection of
other nodes. There can be named collections (mappings) where each element has a name and it is
accessed by a name, and ordered collections (sequences) where elements do not have names but rather
accessed by index. Type of the file node can be determined using FileNode::type method.

Note that file nodes are only used for navigating file storages opened for reading. When a file
storage is opened for writing, no data is stored in memory after it is written.

</member>
        <member name="M:cv.FileStorage.getDefaultObjectName(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Returns the normalized object name for the specified name of a file.
    @param filename Name of a file
    @returns The normalized object name.

</member>
        <member name="M:cv.FileStorage.writeObj(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void!System.Runtime.CompilerServices.IsConst*)">
@brief Writes the registered C structure (CvMat, CvMatND, CvSeq).
    @param name Name of the written object.
    @param obj Pointer to the object.
    @see ocvWrite for details.

</member>
        <member name="M:cv.FileStorage.op_PointerDereference">
@brief Returns the obsolete C FileStorage structure.
    @returns Pointer to the underlying C FileStorage structure


@overload 
</member>
        <member name="M:cv.FileStorage.op_Subscript(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@overload 
</member>
        <member name="M:cv.FileStorage.op_Subscript(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Returns the specified element of the top-level mapping.
    @param nodename Name of the file node.
    @returns Node with the given name.

</member>
        <member name="M:cv.FileStorage.root(System.Int32)">
@brief Returns the top-level mapping
    @param streamidx Zero-based index of the stream. In most cases there is only one stream in the file.
    However, YAML supports multiple streams and so there can be several.
    @returns The top-level mapping.

</member>
        <member name="M:cv.FileStorage.getFirstTopLevelNode">
@brief Returns the first element of the top-level mapping.
    @returns The first element of the top-level mapping.

</member>
        <member name="M:cv.FileStorage.releaseAndGetString">
@brief Closes the file and releases all the memory buffers.

    Call this method after all I/O operations with the storage are finished. If the storage was
    opened for writing data and FileStorage::WRITE was specified

</member>
        <member name="M:cv.FileStorage.release">
@brief Closes the file and releases all the memory buffers.

    Call this method after all I/O operations with the storage are finished.

</member>
        <member name="M:cv.FileStorage.isOpened">
@brief Checks whether the file is opened.

    @returns true if the object is associated with the current file and false otherwise. It is a
    good practice to call this method after you tried to open a file.

</member>
        <member name="M:cv.FileStorage.open(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Opens a file.

    See description of parameters in FileStorage::FileStorage. The method calls FileStorage::release
    before opening the file.
    @param filename Name of the file to open or the text string to read the data from.
       Extension of the file (.xml or .yml/.yaml) determines its format (XML or YAML respectively).
        Also you can append .gz to work with compressed files, for example myHugeMatrix.xml.gz. If both
        FileStorage::WRITE and FileStorage::MEMORY flags are specified, source is used just to specify
        the output file format (e.g. mydata.xml, .yml etc.).
    @param flags Mode of operation. One of FileStorage::Mode
    @param encoding Encoding of the file. Note that UTF-16 XML encoding is not supported currently and
    you should use 8-bit encoding instead of it.

</member>
        <member name="M:cv.FileStorage.#ctor(CvFileStorage*,System.Boolean)">
@overload 
</member>
        <member name="M:cv.FileStorage.#ctor(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param source Name of the file to open or the text string to read the data from. Extension of the
    file (.xml or .yml/.yaml) determines its format (XML or YAML respectively). Also you can append .gz
    to work with compressed files, for example myHugeMatrix.xml.gz. If both FileStorage::WRITE and
    FileStorage::MEMORY flags are specified, source is used just to specify the output file format (e.g.
    mydata.xml, .yml etc.).
    @param flags Mode of operation. See  FileStorage::Mode
    @param encoding Encoding of the file. Note that UTF-16 XML encoding is not supported currently and
    you should use 8-bit encoding instead of it.

</member>
        <member name="M:cv.FileStorage.#ctor">
@brief The constructors.

    The full constructor opens the file. Alternatively you can use the default constructor and then
    call FileStorage::open.

</member>
        <member name="T:cv.FileStorage">
@brief XML/YAML file storage class that encapsulates all the information necessary for writing or reading
data to/from a file.

</member>
        <member name="M:cv.abs(cv.MatExpr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
@param e matrix expression.

</member>
        <member name="T:cv.SparseMatIterator">
@brief  Read-write Sparse Matrix Iterator

 The class is similar to cv::SparseMatConstIterator,
 but can be used for in-place modification of the matrix elements.

</member>
        <member name="M:cv.SparseMat.#ctor(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param m Source matrix for copy constructor. If m is dense matrix (ocvMat) then it will be converted
    to sparse representation.

</member>
        <member name="M:cv.SparseMat.#ctor(cv.SparseMat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param m Source matrix for copy constructor. If m is dense matrix (ocvMat) then it will be converted
    to sparse representation.

</member>
        <member name="M:cv.SparseMat.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@overload
    @param dims Array dimensionality.
    @param _sizes Sparce matrix size on all dementions.
    @param _type Sparse matrix data type.

</member>
        <member name="M:cv.SparseMat.#ctor">
@brief Various SparseMat constructors.

</member>
        <member name="T:cv.UMat">
@todo document 
</member>
        <member name="M:cv.Mat.ptr(System.Int32!System.Runtime.CompilerServices.IsConst*)">
@overload 

@overload 
</member>
        <member name="M:cv.Mat.ptr(System.Int32,System.Int32,System.Int32)">
@overload 

@overload 
</member>
        <member name="M:cv.Mat.ptr(System.Int32,System.Int32)">
@overload 

@overload 
</member>
        <member name="M:cv.Mat.ptr(System.Int32)">
@brief Returns a pointer to the specified matrix row.

    The methods return `uchar*` or typed pointer to the specified matrix row. See the sample in
    Mat::isContinuous to know how to use these methods.
    @param i0 A 0-based row index.


@overload 
</member>
        <member name="M:cv.Mat.total">
@brief Returns the total number of array elements.

    The method returns the number of array elements (a number of pixels if the array represents an
    image).

</member>
        <member name="M:cv.Mat.empty">
@brief Returns true if the array has no elements.

    The method returns true if Mat::total() is 0 or if Mat::data is NULL. Because of pop_back() and
    resize() methods `M.total() == 0` does not imply that `M.data == NULL`.

</member>
        <member name="M:cv.Mat.step1(System.Int32)">
@brief Returns a normalized step.

    The method returns a matrix step divided by Mat::elemSize1() . It can be useful to quickly access an
    arbitrary matrix element.

</member>
        <member name="M:cv.Mat.channels">
@brief Returns the number of matrix channels.

    The method returns the number of matrix channels.

</member>
        <member name="M:cv.Mat.depth">
@brief Returns the depth of a matrix element.

    The method returns the identifier of the matrix element depth (the type of each individual channel).
    For example, for a 16-bit signed element array, the method returns CV_16S . A complete list of
    matrix types contains the following values:
    -   CV_8U - 8-bit unsigned integers ( 0..255 )
    -   CV_8S - 8-bit signed integers ( -128..127 )
    -   CV_16U - 16-bit unsigned integers ( 0..65535 )
    -   CV_16S - 16-bit signed integers ( -32768..32767 )
    -   CV_32S - 32-bit signed integers ( -2147483648..2147483647 )
    -   CV_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN )
    -   CV_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN )

</member>
        <member name="M:cv.Mat.type">
@brief Returns the type of a matrix element.

    The method returns a matrix element type. This is an identifier compatible with the CvMat type
    system, like CV_16SC3 or 16-bit signed 3-channel array, and so on.

</member>
        <member name="M:cv.Mat.elemSize1">
@brief Returns the size of each matrix element channel in bytes.

    The method returns the matrix element channel size in bytes, that is, it ignores the number of
    channels. For example, if the matrix type is CV_16SC3 , the method returns sizeof(short) or 2.

</member>
        <member name="M:cv.Mat.elemSize">
@brief Returns the matrix element size in bytes.

    The method returns the matrix element size in bytes. For example, if the matrix type is CV_16SC3 ,
    the method returns 3\*sizeof(short) or 6.

</member>
        <member name="M:cv.Mat.op_FunctionCall(cv.Range!System.Runtime.CompilerServices.IsConst*)">
@overload
    @param ranges Array of selected ranges along each array dimension.

</member>
        <member name="M:cv.Mat.op_FunctionCall(cv.Rect_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param roi Extracted submatrix specified as a rectangle.

</member>
        <member name="M:cv.Mat.op_FunctionCall(cv.Range,cv.Range)">
@brief Extracts a rectangular submatrix.

    The operators make a new header for the specified sub-array of \*this . They are the most
    generalized forms of Mat::row, Mat::col, Mat::rowRange, and Mat::colRange . For example,
    `A(Range(0, 10), Range::all())` is equivalent to `A.rowRange(0, 10)`. Similarly to all of the above,
    the operators are O(1) operations, that is, no matrix data is copied.
    @param rowRange Start and end row of the extracted submatrix. The upper boundary is not included. To
    select all the rows, use Range::all().
    @param colRange Start and end column of the extracted submatrix. The upper boundary is not included.
    To select all the columns, use Range::all().

</member>
        <member name="M:cv.Mat.adjustROI(System.Int32,System.Int32,System.Int32,System.Int32)">
@brief Adjusts a submatrix size and position within the parent matrix.

    The method is complimentary to Mat::locateROI . The typical use of these functions is to determine
    the submatrix position within the parent matrix and then shift the position somehow. Typically, it
    can be required for filtering operations when pixels outside of the ROI should be taken into
    account. When all the method parameters are positive, the ROI needs to grow in all directions by the
    specified amount, for example:
    @code
        A.adjustROI(2, 2, 2, 2);
    @endcode
    In this example, the matrix size is increased by 4 elements in each direction. The matrix is shifted
    by 2 elements to the left and 2 elements up, which brings in all the necessary pixels for the
    filtering with the 5x5 kernel.

    adjustROI forces the adjusted ROI to be inside of the parent matrix that is boundaries of the
    adjusted ROI are constrained by boundaries of the parent matrix. For example, if the submatrix A is
    located in the first row of a parent matrix and you called A.adjustROI(2, 2, 2, 2) then A will not
    be increased in the upward direction.

    The function is used internally by the OpenCV filtering functions, like filter2D , morphological
    operations, and so on.
    @param dtop Shift of the top submatrix boundary upwards.
    @param dbottom Shift of the bottom submatrix boundary downwards.
    @param dleft Shift of the left submatrix boundary to the left.
    @param dright Shift of the right submatrix boundary to the right.
    @sa copyMakeBorder

</member>
        <member name="M:cv.Mat.locateROI(cv.Size_&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Locates the matrix header within a parent matrix.

    After you extracted a submatrix from a matrix using Mat::row, Mat::col, Mat::rowRange,
    Mat::colRange, and others, the resultant submatrix points just to the part of the original big
    matrix. However, each submatrix contains information (represented by datastart and dataend
    fields) that helps reconstruct the original matrix size and the position of the extracted
    submatrix within the original matrix. The method locateROI does exactly that.
    @param wholeSize Output parameter that contains the size of the whole matrix containing *this*
    as a part.
    @param ofs Output parameter that contains an offset of *this* inside the whole matrix.

</member>
        <member name="M:cv.Mat.pop_back(System.UInt32)">
@brief Removes elements from the bottom of the matrix.

    The method removes one or more rows from the bottom of the matrix.
    @param nelems Number of removed rows. If it is greater than the total number of rows, an exception
    is thrown.

</member>
        <member name="M:cv.Mat.push_back(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param m Added line(s).

</member>
        <member name="M:cv.Mat.resize(System.UInt32,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param sz New number of rows.
    @param s Value assigned to the newly added elements.

</member>
        <member name="M:cv.Mat.resize(System.UInt32)">
@brief Changes the number of matrix rows.

    The methods change the number of matrix rows. If the matrix is reallocated, the first
    min(Mat::rows, sz) rows are preserved. The methods emulate the corresponding methods of the STL
    vector class.
    @param sz New number of rows.

</member>
        <member name="M:cv.Mat.reserve(System.UInt32)">
@brief Reserves space for the certain number of rows.

    The method reserves space for sz rows. If the matrix already has enough space to store sz rows,
    nothing happens. If the matrix is reallocated, the first Mat::rows rows are preserved. The method
    emulates the corresponding method of the STL vector class.
    @param sz Number of rows.

</member>
        <member name="M:cv.Mat.release">
@brief Decrements the reference counter and deallocates the matrix if needed.

    The method decrements the reference counter associated with the matrix data. When the reference
    counter reaches 0, the matrix data is deallocated and the data and the reference counter pointers
    are set to NULL's. If the matrix header points to an external data set (see Mat::Mat ), the
    reference counter is NULL, and the method has no effect in this case.

    This method can be called manually to force the matrix data deallocation. But since this method is
    automatically called in the destructor, or by any other method that changes the data pointer, it is
    usually not needed. The reference counter decrement and check for 0 is an atomic operation on the
    platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in
    different threads.

</member>
        <member name="M:cv.Mat.addref">
@brief Increments the reference counter.

    The method increments the reference counter associated with the matrix data. If the matrix header
    points to an external data set (see Mat::Mat ), the reference counter is NULL, and the method has no
    effect in this case. Normally, to avoid memory leaks, the method should not be called explicitly. It
    is called implicitly by the matrix assignment operator. The reference counter increment is an atomic
    operation on the platforms that support it. Thus, it is safe to operate on the same matrices
    asynchronously in different threads.

</member>
        <member name="M:cv.Mat.create(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@overload
    @param ndims New array dimensionality.
    @param sizes Array of integers specifying a new array shape.
    @param type New matrix type.

</member>
        <member name="M:cv.Mat.create(cv.Size_&lt;System.Int32&gt;,System.Int32)">
@overload
    @param size Alternative new matrix size specification: Size(cols, rows)
    @param type New matrix type.

</member>
        <member name="M:cv.Mat.create(System.Int32,System.Int32,System.Int32)">
@brief Allocates new array data if needed.

    This is one of the key Mat methods. Most new-style OpenCV functions and methods that produce arrays
    call this method for each output array. The method uses the following algorithm:

    -# If the current array shape and the type match the new ones, return immediately. Otherwise,
       de-reference the previous data by calling Mat::release.
    -# Initialize the new header.
    -# Allocate the new data of total()\*elemSize() bytes.
    -# Allocate the new, associated with the data, reference counter and set it to 1.

    Such a scheme makes the memory management robust and efficient at the same time and helps avoid
    extra typing for you. This means that usually there is no need to explicitly allocate output arrays.
    That is, instead of writing:
    @code
        Mat color;
        ...
        Mat gray(color.rows, color.cols, color.depth());
        cvtColor(color, gray, COLOR_BGR2GRAY);
    @endcode
    you can simply write:
    @code
        Mat color;
        ...
        Mat gray;
        cvtColor(color, gray, COLOR_BGR2GRAY);
    @endcode
    because cvtColor, as well as the most of OpenCV functions, calls Mat::create() for the output array
    internally.
    @param rows New number of rows.
    @param cols New number of columns.
    @param type New matrix type.

</member>
        <member name="M:cv.Mat.eye(cv.Size_&lt;System.Int32&gt;,System.Int32)">
@overload
    @param size Alternative matrix size specification as Size(cols, rows) .
    @param type Created matrix type.

</member>
        <member name="M:cv.Mat.eye(System.Int32,System.Int32,System.Int32)">
@brief Returns an identity matrix of the specified size and type.

    The method returns a Matlab-style identity matrix initializer, similarly to Mat::zeros. Similarly to
    Mat::ones, you can use a scale operation to create a scaled identity matrix efficiently:
    @code
        // make a 4x4 diagonal matrix with 0.1's on the diagonal.
        Mat A = Mat::eye(4, 4, CV_32F)*0.1;
    @endcode
    @param rows Number of rows.
    @param cols Number of columns.
    @param type Created matrix type.

</member>
        <member name="M:cv.Mat.ones(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@overload
    @param ndims Array dimensionality.
    @param sz Array of integers specifying the array shape.
    @param type Created matrix type.

</member>
        <member name="M:cv.Mat.ones(cv.Size_&lt;System.Int32&gt;,System.Int32)">
@overload
    @param size Alternative to the matrix size specification Size(cols, rows) .
    @param type Created matrix type.

</member>
        <member name="M:cv.Mat.ones(System.Int32,System.Int32,System.Int32)">
@brief Returns an array of all 1's of the specified size and type.

    The method returns a Matlab-style 1's array initializer, similarly to Mat::zeros. Note that using
    this method you can initialize an array with an arbitrary value, using the following Matlab idiom:
    @code
        Mat A = Mat::ones(100, 100, CV_8U)*3; // make 100x100 matrix filled with 3.
    @endcode
    The above operation does not form a 100x100 matrix of 1's and then multiply it by 3. Instead, it
    just remembers the scale factor (3 in this case) and use it when actually invoking the matrix
    initializer.
    @param rows Number of rows.
    @param cols Number of columns.
    @param type Created matrix type.

</member>
        <member name="M:cv.Mat.zeros(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@overload
    @param ndims Array dimensionality.
    @param sz Array of integers specifying the array shape.
    @param type Created matrix type.

</member>
        <member name="M:cv.Mat.zeros(cv.Size_&lt;System.Int32&gt;,System.Int32)">
@overload
    @param size Alternative to the matrix size specification Size(cols, rows) .
    @param type Created matrix type.

</member>
        <member name="M:cv.Mat.zeros(System.Int32,System.Int32,System.Int32)">
@brief Returns a zero array of the specified size and type.

    The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant
    array as a function parameter, part of a matrix expression, or as a matrix initializer. :
    @code
        Mat A;
        A = Mat::zeros(3, 3, CV_32F);
    @endcode
    In the example above, a new matrix is allocated only if A is not a 3x3 floating-point matrix.
    Otherwise, the existing matrix A is filled with zeros.
    @param rows Number of rows.
    @param cols Number of columns.
    @param type Created matrix type.

</member>
        <member name="M:cv.Mat.dot(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes a dot-product of two vectors.

    The method computes a dot-product of two matrices. If the matrices are not single-column or
    single-row vectors, the top-to-bottom left-to-right scan ordering is used to treat them as 1D
    vectors. The vectors must have the same size and type. If the matrices have more than one channel,
    the dot products from all the channels are summed together.
    @param m another dot-product operand.

</member>
        <member name="M:cv.Mat.cross(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Computes a cross-product of two 3-element vectors.

    The method computes a cross-product of two 3-element vectors. The vectors must be 3-element
    floating-point vectors of the same shape and size. The result is another 3-element vector of the
    same shape and type as operands.
    @param m Another cross-product operand.

</member>
        <member name="M:cv.Mat.mul(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief Performs an element-wise multiplication or division of the two matrices.

    The method returns a temporary object encoding per-element array multiplication, with optional
    scale. Note that this is not a matrix multiplication that corresponds to a simpler "\*" operator.

    Example:
    @code
        Mat C = A.mul(5/B); // equivalent to divide(A, B, C, 5)
    @endcode
    @param m Another array of the same type and the same size as \*this, or a matrix expression.
    @param scale Optional scale factor.

</member>
        <member name="M:cv.Mat.inv(System.Int32)">
@brief Inverses a matrix.

    The method performs a matrix inversion by means of matrix expressions. This means that a temporary
    matrix inversion object is returned by the method and can be used further as a part of more complex
    matrix expressions or can be assigned to a matrix.
    @param method Matrix inversion method. One of cv::DecompTypes

</member>
        <member name="M:cv.Mat.t">
@brief Transposes a matrix.

    The method performs matrix transposition by means of matrix expressions. It does not perform the
    actual transposition but returns a temporary matrix transposition object that can be further used as
    a part of more complex matrix expressions or can be assigned to a matrix:
    @code
        Mat A1 = A + Mat::eye(A.size(), A.type())*lambda;
        Mat C = A1.t()*A1; // compute (A + lambda*I)^t * (A + lamda*I)
    @endcode

</member>
        <member name="M:cv.Mat.reshape(System.Int32,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
@overload 
</member>
        <member name="M:cv.Mat.op_Assign(cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Sets all or some of the array elements to the specified value.
    @param s Assigned scalar converted to the actual array type.

</member>
        <member name="M:cv.Mat.assignTo(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief Provides a functional form of convertTo.

    This is an internally used method called by the @ref MatrixExpressions engine.
    @param m Destination array.
    @param type Desired destination array depth (or -1 if it should be the same as the source type).

</member>
        <member name="M:cv.Mat.copyTo(cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param m Destination matrix. If it does not have a proper size or type before the operation, it is
    reallocated.
    @param mask Operation mask. Its non-zero elements indicate which matrix elements need to be copied.

</member>
        <member name="M:cv.Mat.copyTo(cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Copies the matrix to another one.

    The method copies the matrix data to another matrix. Before copying the data, the method invokes :
    @code
        m.create(this-&gt;size(), this-&gt;type());
    @endcode
    so that the destination matrix is reallocated if needed. While m.copyTo(m); works flawlessly, the
    function does not handle the case of a partial overlap between the source and the destination
    matrices.

    When the operation mask is specified, if the Mat::create call shown above reallocates the matrix,
    the newly allocated matrix is initialized with all zeros before copying the data.
    @param m Destination matrix. If it does not have a proper size or type before the operation, it is
    reallocated.

</member>
        <member name="M:cv.Mat.clone">
@brief Creates a full copy of the array and the underlying data.

    The method creates a full copy of the array. The original step[] is not taken into account. So, the
    array copy is a continuous array occupying total()*elemSize() bytes.

</member>
        <member name="M:cv.Mat.diag(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief creates a diagonal matrix

    The method makes a new header for the specified matrix diagonal. The new matrix is represented as a
    single-column matrix. Similarly to Mat::row and Mat::col, this is an O(1) operation.
    @param d Single-column matrix that forms a diagonal matrix

</member>
        <member name="M:cv.Mat.colRange(cv.Range!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param r Range structure containing both the start and the end indices.

</member>
        <member name="M:cv.Mat.colRange(System.Int32,System.Int32)">
@brief Creates a matrix header for the specified column span.

    The method makes a new header for the specified column span of the matrix. Similarly to Mat::row and
    Mat::col , this is an O(1) operation.
    @param startcol An inclusive 0-based start index of the column span.
    @param endcol An exclusive 0-based ending index of the column span.

</member>
        <member name="M:cv.Mat.rowRange(cv.Range!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param r Range structure containing both the start and the end indices.

</member>
        <member name="M:cv.Mat.rowRange(System.Int32,System.Int32)">
@brief Creates a matrix header for the specified row span.

    The method makes a new header for the specified row span of the matrix. Similarly to Mat::row and
    Mat::col , this is an O(1) operation.
    @param startrow An inclusive 0-based start index of the row span.
    @param endrow An exclusive 0-based ending index of the row span.

</member>
        <member name="M:cv.Mat.col(System.Int32)">
@brief Creates a matrix header for the specified matrix column.

    The method makes a new header for the specified matrix column and returns it. This is an O(1)
    operation, regardless of the matrix size. The underlying data of the new matrix is shared with the
    original matrix. See also the Mat::row description.
    @param x A 0-based column index.

</member>
        <member name="M:cv.Mat.op_Assign(cv.MatExpr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param expr Assigned matrix expression object. As opposite to the first form of the assignment
    operation, the second form can reuse already allocated matrix if it has the right size and type to
    fit the matrix expression result. It is automatically handled by the real function that the matrix
    expressions is expanded to. For example, C=A+B is expanded to add(A, B, C), and add takes care of
    automatic C reallocation.

</member>
        <member name="M:cv.Mat.op_Assign(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief assignment operators

    These are available assignment operators. Since they all are very different, make sure to read the
    operator parameters description.
    @param m Assigned, right-hand-side matrix. Matrix assignment is an O(1) operation. This means that
    no data is copied but the data is shared and the reference counter, if any, is incremented. Before
    assigning new data, the old data is de-referenced via Mat::release .

</member>
        <member name="M:cv.Mat.#ctor(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Range!System.Runtime.CompilerServices.IsConst*)">
@overload
    @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
    by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
    associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
    formed using such a constructor, you also modify the corresponding elements of m . If you want to
    have an independent copy of the sub-array, use Mat::clone() .
    @param ranges Array of selected ranges of m along each dimensionality.

</member>
        <member name="M:cv.Mat.#ctor(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Rect_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
    by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
    associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
    formed using such a constructor, you also modify the corresponding elements of m . If you want to
    have an independent copy of the sub-array, use Mat::clone() .
    @param roi Region of interest.

</member>
        <member name="M:cv.Mat.#ctor(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Range!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Range!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
    by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
    associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
    formed using such a constructor, you also modify the corresponding elements of m . If you want to
    have an independent copy of the sub-array, use Mat::clone() .
    @param rowRange Range of the m rows to take. As usual, the range start is inclusive and the range
    end is exclusive. Use Range::all() to take all the rows.
    @param colRange Range of the m columns to take. Use Range::all() to take all the columns.

</member>
        <member name="M:cv.Mat.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsConst*)">
@overload
    @param ndims Array dimensionality.
    @param sizes Array of integers specifying an n-dimensional array shape.
    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
    @param data Pointer to the user data. Matrix constructors that take data and step parameters do not
    allocate matrix data. Instead, they just initialize the matrix header that points to the specified
    data, which means that no data is copied. This operation is very efficient and can be used to
    process external data using OpenCV functions. The external data is not automatically deallocated, so
    you should take care of it.
    @param steps Array of ndims-1 steps in case of a multi-dimensional array (the last step is always
    set to the element size). If not specified, the matrix is assumed to be continuous.

</member>
        <member name="M:cv.Mat.#ctor(cv.Size_&lt;System.Int32&gt;,System.Int32,System.Void*,System.UInt32)">
@overload
    @param size 2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the
    number of columns go in the reverse order.
    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
    @param data Pointer to the user data. Matrix constructors that take data and step parameters do not
    allocate matrix data. Instead, they just initialize the matrix header that points to the specified
    data, which means that no data is copied. This operation is very efficient and can be used to
    process external data using OpenCV functions. The external data is not automatically deallocated, so
    you should take care of it.
    @param step Number of bytes each matrix row occupies. The value should include the padding bytes at
    the end of each row, if any. If the parameter is missing (set to AUTO_STEP ), no padding is assumed
    and the actual step is calculated as cols*elemSize(). See Mat::elemSize.

</member>
        <member name="M:cv.Mat.#ctor(System.Int32,System.Int32,System.Int32,System.Void*,System.UInt32)">
@overload
    @param rows Number of rows in a 2D array.
    @param cols Number of columns in a 2D array.
    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
    @param data Pointer to the user data. Matrix constructors that take data and step parameters do not
    allocate matrix data. Instead, they just initialize the matrix header that points to the specified
    data, which means that no data is copied. This operation is very efficient and can be used to
    process external data using OpenCV functions. The external data is not automatically deallocated, so
    you should take care of it.
    @param step Number of bytes each matrix row occupies. The value should include the padding bytes at
    the end of each row, if any. If the parameter is missing (set to AUTO_STEP ), no padding is assumed
    and the actual step is calculated as cols*elemSize(). See Mat::elemSize.

</member>
        <member name="M:cv.Mat.#ctor(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@overload
    @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
    by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
    associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
    formed using such a constructor, you also modify the corresponding elements of m . If you want to
    have an independent copy of the sub-array, use Mat::clone() .

</member>
        <member name="M:cv.Mat.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@overload
    @param ndims Array dimensionality.
    @param sizes Array of integers specifying an n-dimensional array shape.
    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.

</member>
        <member name="M:cv.Mat.#ctor(cv.Size_&lt;System.Int32&gt;,System.Int32)">
@overload
    @param size 2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the
    number of columns go in the reverse order.
    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.

</member>
        <member name="M:cv.Mat.#ctor(System.Int32,System.Int32,System.Int32)">
@overload
    @param rows Number of rows in a 2D array.
    @param cols Number of columns in a 2D array.
    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.

</member>
        <member name="M:cv.Mat.#ctor">
These are various constructors that form a matrix. As noted in the AutomaticAllocation, often
the default constructor is enough, and the proper matrix will be allocated by an OpenCV function.
The constructed matrix can further be assigned to another matrix or matrix expression or can be
allocated with Mat::create . In the former case, the old content is de-referenced.

</member>
        <member name="T:cv.MatAllocator">
@brief  Custom array allocator

</member>
        <member name="M:cv.TermCriteria.#ctor(System.Int32,System.Int32,System.Double)">
@param type The type of termination criteria, one of TermCriteria::Type
@param maxCount The maximum number of iterations or elements to compute.
@param epsilon The desired accuracy or change in parameters at which the iterative algorithm stops.

</member>
        <member name="T:cv.TermCriteria.Type">
Criteria type, can be one of: COUNT, EPS or COUNT + EPS

</member>
        <member name="T:cv.TermCriteria">
@brief The class defining termination criteria for iterative algorithms.

You can initialize it by default constructor and then override any parameters, or the structure may
be fully initialized using the advanced variant of the constructor.

</member>
        <member name="T:cv.DMatch">
@brief Class for matching keypoint descriptors

query descriptor index, train descriptor index, train image index, and distance between
descriptors.

</member>
        <member name="M:cv.KeyPoint.overlap(cv.KeyPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.KeyPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This method computes overlap for pair of keypoints. Overlap is the ratio between area of keypoint
regions' intersection and area of keypoint regions' union (considering keypoint region as circle).
If they don't overlap, we get zero. If they coincide at same location with same size, we get 1.
@param kp1 First keypoint
@param kp2 Second keypoint

</member>
        <member name="M:cv.KeyPoint.convert(std.vector&lt;cv.Point_&lt;System.Single&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.KeyPoint&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Int32,System.Int32)">
@overload
    @param points2f Array of (x,y) coordinates of each keypoint
    @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB
    @param size keypoint diameter
    @param response keypoint detector response on the keypoint (that is, strength of the keypoint)
    @param octave pyramid octave in which the keypoint has been detected
    @param class_id object id

</member>
        <member name="M:cv.KeyPoint.convert(std.vector&lt;cv.KeyPoint&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Point_&lt;System.Single&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    This method converts vector of keypoints to vector of points or the reverse, where each keypoint is
    assigned the same size and the same orientation.

    @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB
    @param points2f Array of (x,y) coordinates of each keypoint
    @param keypointIndexes Array of indexes of keypoints to be converted to points. (Acts like a mask to
    convert only specified keypoints)

</member>
        <member name="M:cv.KeyPoint.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
@param x x-coordinate of the keypoint
@param y y-coordinate of the keypoint
@param _size keypoint diameter
@param _angle keypoint orientation
@param _response keypoint detector response on the keypoint (that is, strength of the keypoint)
@param _octave pyramid octave in which the keypoint has been detected
@param _class_id object id

</member>
        <member name="T:cv.KeyPoint">
@brief Data structure for salient point detectors.

The class instance stores a keypoint, i.e. a point feature found by one of many available keypoint
detectors, such as Harris corner detector, cv::FAST, cv::StarDetector, cv::SURF, cv::SIFT,
cv::LDetector etc.

The keypoint is characterized by the 2D position, scale (proportional to the diameter of the
neighborhood that needs to be taken into account), orientation and some other parameters. The
keypoint neighborhood is then analyzed by another algorithm that builds a descriptor (usually
represented as a feature vector). The keypoints representing the same object in different images
can then be matched using cv::KDTree or another method.

</member>
        <member name="M:cv.RotatedRect.points(cv.Point_&lt;System.Single&gt;*)">
returns 4 vertices of the rectangle
    @param pts The points array for storing rectangle vertices.

</member>
        <member name="M:cv.RotatedRect.#ctor(cv.Point_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Any 3 end points of the RotatedRect. They must be given in order (either clockwise or
anticlockwise).

</member>
        <member name="M:cv.RotatedRect.#ctor(cv.Point_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
@param center The rectangle mass center.
@param size Width and height of the rectangle.
@param angle The rotation angle in a clockwise direction. When the angle is 0, 90, 180, 270 etc.,
the rectangle becomes an up-right rectangle.

</member>
        <member name="M:cv.Cholesky(System.Double*,System.UInt32,System.Int32,System.Double*,System.UInt32,System.Int32)">
proxy for hal::Cholesky 
</member>
        <member name="M:cv.Cholesky(System.Single*,System.UInt32,System.Int32,System.Single*,System.UInt32,System.Int32)">
proxy for hal::Cholesky 
</member>
        <member name="M:cv.LU(System.Double*,System.UInt32,System.Int32,System.Double*,System.UInt32,System.Int32)">
proxy for hal::LU 
</member>
        <member name="M:cv.LU(System.Single*,System.UInt32,System.Int32,System.Single*,System.UInt32,System.Int32)">
proxy for hal::LU 
</member>
        <member name="M:cv.fastAtan2(System.Single,System.Single)">
@brief Calculates the angle of a 2D vector in degrees.

 The function fastAtan2 calculates the full-range angle of an input 2D vector. The angle is measured
 in degrees and varies from 0 to 360 degrees. The accuracy is about 0.3 degrees.
 @param x x-coordinate of the vector.
 @param y y-coordinate of the vector.

</member>
        <member name="M:cv.cubeRoot(System.Single)">
@brief Computes the cube root of an argument.

 The function cubeRoot computes \f$\sqrt[3]{\texttt{val}}\f$. Negative arguments are handled correctly.
 NaN and Inf are not handled. The accuracy approaches the maximum possible accuracy for
 single-precision data.
 @param val A function argument.

</member>
        <member name="M:cv.Hamming.op_FunctionCall(System.Byte!System.Runtime.CompilerServices.IsConst*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
this will count the bits in a ^ b

</member>
        <member name="T:cv.Hamming">
@brief Call the error handler.

Currently, the error handler prints the error code and the error message to the standard
error stream `stderr`. In the Debug configuration, it then provokes memory access violation, so that
the execution stack and all the parameters can be analyzed by the debugger. In the Release
configuration, the exception is thrown.

@param code one of Error::Code
@param msg error message

 @brief Call the error handler.

This macro can be used to construct an error message on-fly to include some dynamic information,
for example:
@code
    // note the extra parentheses around the formatted text message
    CV_Error_( CV_StsOutOfRange,
    ("the value at (%d, %d)=%g is out of range", badPt.x, badPt.y, badValue));
@endcode
@param code one of Error::Code
@param args printf-like formatted error message in parentheses

@brief Checks a condition at runtime and throws exception if it fails

The macros CV_Assert (and CV_DbgAssert(expr)) evaluate the specified expression. If it is 0, the macros
raise an error (see cv::error). The macro CV_Assert checks the condition in both Debug and Release
configurations while CV_DbgAssert is only retained in the Debug configuration.

same as CV_Error(code,msg), but does not return 
same as CV_Error_(code,args), but does not return 
replaced with CV_Assert(expr) in Debug configuration 
</member>
        <member name="M:cv.errorNoReturn(System.Int32,cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
same as cv::error, but does not return 
</member>
        <member name="F:DCT_ROWS">
performs a forward or inverse transform of every individual row of the input
        matrix. This flag enables you to transform multiple vectors simultaneously and can be used to
        decrease the overhead (which is sometimes several times larger than the processing itself) to
        perform 3D and higher-dimensional transforms and so forth.
</member>
        <member name="F:DCT_INVERSE">
performs an inverse 1D or 2D transform instead of the default forward transform. 
</member>
        <member name="F:DFT_REAL_OUTPUT">
performs an inverse transformation of a 1D or 2D complex array; the
        result is normally a complex array of the same size, however, if the input array has
        conjugate-complex symmetry (for example, it is a result of forward transformation with
        DFT_COMPLEX_OUTPUT flag), the output is a real array; while the function itself does not
        check whether the input is symmetrical or not, you can pass the flag and then the function
        will assume the symmetry and produce the real output array (note that when the input is packed
        into a real array and inverse transformation is executed, the function treats the input as a
        packed complex-conjugate symmetrical array, and the output will also be a real array). 
</member>
        <member name="F:DFT_COMPLEX_OUTPUT">
performs a forward transformation of 1D or 2D real array; the result,
        though being a complex array, has complex-conjugate symmetry (*CCS*, see the function
        description below for details), and such an array can be packed into a real array of the same
        size as input, which is the fastest option and which is what the function does by default;
        however, you may wish to get a full complex array (for simpler spectrum analysis, and so on) -
        pass the flag to enable the function to produce a full-size complex output array. 
</member>
        <member name="F:DFT_ROWS">
performs a forward or inverse transform of every individual row of the input
        matrix; this flag enables you to transform multiple vectors simultaneously and can be used to
        decrease the overhead (which is sometimes several times larger than the processing itself) to
        perform 3D and higher-dimensional transformations and so forth.
</member>
        <member name="F:DFT_SCALE">
scales the result: divide it by the number of array elements. Normally, it is
        combined with DFT_INVERSE. 
</member>
        <member name="F:DFT_INVERSE">
performs an inverse 1D or 2D transform instead of the default forward
        transform. 
</member>
        <member name="T:cv.NormTypes">
norm types
- For one array:
\f[norm =  \forkthree{\|\texttt{src1}\|_{L_{\infty}} =  \max _I | \texttt{src1} (I)|}{if  \(\texttt{normType} = \texttt{NORM\_INF}\) }
{ \| \texttt{src1} \| _{L_1} =  \sum _I | \texttt{src1} (I)|}{if  \(\texttt{normType} = \texttt{NORM\_L1}\) }
{ \| \texttt{src1} \| _{L_2} =  \sqrt{\sum_I \texttt{src1}(I)^2} }{if  \(\texttt{normType} = \texttt{NORM\_L2}\) }\f]

- Absolute norm for two arrays
\f[norm =  \forkthree{\|\texttt{src1}-\texttt{src2}\|_{L_{\infty}} =  \max _I | \texttt{src1} (I) -  \texttt{src2} (I)|}{if  \(\texttt{normType} = \texttt{NORM\_INF}\) }
{ \| \texttt{src1} - \texttt{src2} \| _{L_1} =  \sum _I | \texttt{src1} (I) -  \texttt{src2} (I)|}{if  \(\texttt{normType} = \texttt{NORM\_L1}\) }
{ \| \texttt{src1} - \texttt{src2} \| _{L_2} =  \sqrt{\sum_I (\texttt{src1}(I) - \texttt{src2}(I))^2} }{if  \(\texttt{normType} = \texttt{NORM\_L2}\) }\f]

- Relative norm for two arrays
\f[norm =  \forkthree{\frac{\|\texttt{src1}-\texttt{src2}\|_{L_{\infty}}    }{\|\texttt{src2}\|_{L_{\infty}} }}{if  \(\texttt{normType} = \texttt{NORM\_RELATIVE\_INF}\) }
{ \frac{\|\texttt{src1}-\texttt{src2}\|_{L_1} }{\|\texttt{src2}\|_{L_1}} }{if  \(\texttt{normType} = \texttt{NORM\_RELATIVE\_L1}\) }
{ \frac{\|\texttt{src1}-\texttt{src2}\|_{L_2} }{\|\texttt{src2}\|_{L_2}} }{if  \(\texttt{normType} = \texttt{NORM\_RELATIVE\_L2}\) }\f]

</member>
        <member name="F:DECOMP_NORMAL">
while all the previous flags are mutually exclusive, this flag can be used together with
    any of the previous; it means that the normal equations
    \f$\texttt{src1}^T\cdot\texttt{src1}\cdot\texttt{dst}=\texttt{src1}^T\texttt{src2}\f$ are
    solved instead of the original system
    \f$\texttt{src1}\cdot\texttt{dst}=\texttt{src2}\f$ 
</member>
        <member name="F:DECOMP_QR">
QR factorization; the system can be over-defined and/or the matrix src1 can be singular 
</member>
        <member name="F:DECOMP_CHOLESKY">
Cholesky \f$LL^T\f$ factorization; the matrix src1 must be symmetrical and positively
    defined 
</member>
        <member name="F:DECOMP_EIG">
eigenvalue decomposition; the matrix src1 must be symmetrical 
</member>
        <member name="F:DECOMP_SVD">
singular value decomposition (SVD) method; the system can be over-defined and/or the matrix
    src1 can be singular 
</member>
        <member name="F:DECOMP_LU">
Gaussian elimination with the optimal pivot element chosen. 
</member>
        <member name="M:cv.fastFree(System.Void*)">
@brief Deallocates a memory buffer.

The function deallocates the buffer allocated with fastMalloc . If NULL pointer is passed, the
function does nothing. C version of the function clears the pointer *pptr* to avoid problems with
double memory deallocation.
@param ptr Pointer to the allocated buffer.

</member>
        <member name="M:cv.fastMalloc(System.UInt32)">
@brief Allocates an aligned memory buffer.

The function allocates the buffer of the specified size and returns it. When the buffer size is 16
bytes or more, the returned buffer is aligned to 16 bytes.
@param bufSize Allocated buffer size.

</member>
        <member name="M:cvIsInf(System.Single)">
@overload 
</member>
        <member name="M:cvIsNaN(System.Single)">
@overload 
</member>
        <member name="M:cvCeil(System.Int32)">
@overload 
</member>
        <member name="M:cvCeil(System.Single)">
@overload 
</member>
        <member name="M:cvFloor(System.Int32)">
@overload 
</member>
        <member name="M:cvFloor(System.Single)">
@overload 
</member>
        <member name="M:cvRound(System.Int32)">
@overload 
</member>
        <member name="M:cvRound(System.Single)">
@overload 
</member>
        <member name="M:cvIsInf(System.Double)">
@brief Determines if the argument is Infinity.

 @param value The input floating-point value

 The function returns 1 if the argument is a plus or minus infinity (as defined by IEEE754 standard)
 and 0 otherwise. 
</member>
        <member name="M:cvIsNaN(System.Double)">
@brief Determines if the argument is Not A Number.

 @param value The input floating-point value

 The function returns 1 if the argument is Not A Number (as defined by IEEE754 standard), 0
 otherwise. 
</member>
        <member name="M:cvRound(System.Double)">
@brief Rounds floating-point number to the nearest integer

 @param value floating-point number. If the value is outside of INT_MIN ... INT_MAX range, the
 result is not defined.

</member>
        <member name="M:resolveCMakeBuildDirPath(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Resolves the given relative path in CMake build folder to full platform specific path.
@param relativePath relative path in unix form, for example "ZicerOcrModelBuilder/model_all.z"
@return resolved path

</member>
        <member name="M:getCMakeBuildDirPath">
Returns the path to CMake build folder.
@return the path to CMake build folder.

</member>
        <member name="M:resolveCorePhotoPayPath(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Resolves the given relative path in core-photopay folder to full platform specific path.
@param relativePath relative path in unix form, for example "Matlab/mlacs/IMG_0715.jpg"
@return resolved path, for example "/home/dodo/Work/PhotoPay/core-photopay/Matlab/mlacs/IMG_0715.jpg" on unix or "c:\\users\\dodo\\Desktop\\PhotoPay\\core-photopay\\Matlab\\mlacs\\IMG_0715.jpg"

</member>
        <member name="M:getCorePhotoPayPath">
Returns the path to core-photopay folder that can be used in some tests.
@return the path to core-photopay folder that can be used in some tests.

</member>
        <member name="M:resolveOldTestImagesPath(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Similar to resolveTestImagesPath, but expects input in form "../TestImages/subpath"

</member>
        <member name="M:resolveTestImagesPath(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Resolves the given relative path in TestImages folder to full platform specific path.
@param relativePath relative path in unix form, for example "Cro/video/HUB3/Nexus 5/LGE Nexus 5 - 2014-02-20 16-57-51.ppv"
@return resolved path, for example "/home/dodo/PhotoPayImages/Cro/video/HUB3/Nexus 5/LGE Nexus 5 - 2014-02-20 16-57-51.ppv" on unix or "c:\\users\\dodo\\PhotoPayImages\\Cro\\video\\HUB3\\Nexus 5\\LGE Nexus 5 - 2014-02-20 16-57-51.ppv"

</member>
        <member name="M:getTestImagesPath">

  Created on: 31/05/2014
      Author: dodo

 Copyright (c)2014 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

Returns the path to TestImages folder that can be used in all tests.
@return the path to TestImages folder that can be used in all tests.

</member>
        <member name="D:_onexit_t">
warnings and errors are always printed
</member>
        <member name="M:setLogMessageProxy(=FUNC:System.Void(_tagLogLevel,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*))">
Sets a logging callback function for proxying logging to a nother part of the system

</member>
        <member name="D:LogMessageProxyFunction">
Type specifying a logging function callback

</member>
        <member name="M:PPLogf(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)">
Log that doesn't add prefix nor newline at the end of string.
Behaves exactly as printf.

</member>
        <member name="M:PPInfo(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)">
Write information to log.
@param fmt message format with parameters

</member>
        <member name="M:PPLog(_tagLogLevel,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)">
Log message
@param lvl message lov level
@param funcName name of function that generated message
@param filename of the file where message was generated
@param line line where message was generated
@param fmt message format with parameters

</member>
        <member name="M:disableFileLogging">
@brief restores default behavious as it were before calling setLogFilename

</member>
        <member name="M:setLogFilename(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
 @brief set the name of the file to which log output will be printed

 @param filename name of file to which log will be printed
 @param fileIsSecondaryLog if set to true, log outputs will be printed
 			both to default output and given filename; if
 			set to false, log outputs will be printed only
	 		to given filename.

</member>
        <member name="M:_memccpy(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)">
nothing is logged
only warnings and errors are logged
warnings, errors and information are logged
warnings, errors, information and debug outputs are logged
everything is logged
</member>
        <member name="D:int8_t">
 PP_WARN_UNUSED_RESULT tells the compiler to emit a warning if a function's
 return value is not used by the caller.

 Place this attribute at the very beginning of a function definition. For
 example, write

   PP_WARN_UNUSED_RESULT int foo();

 or

   PP_WARN_UNUSED_RESULT int foo() { return 42; }

</member>
        <member name="P:Microblink.BarDecoderRecognizerSettings.Enabled">
            <summary>
Indicates the recognizer is enabled
</summary>
        </member>
        <member name="M:Microblink.BarDecoderRecognizerSettings.requiresLandscapeMode">
            <summary>
Does the recognizer require to be used in landscape orientation
</summary>
        </member>
        <member name="M:Microblink.BarDecoderRecognizerSettings.requiresAutofocus">
            <summary>
Does the recognizer require camera with autofocus feature
</summary>
        </member>
        <member name="M:Microblink.BarDecoderRecognizerSettings.requiresOCREngine">
            <summary>
Does the recognizer require on OCR engine
</summary>
        </member>
        <member name="M:Microblink.BarDecoderRecognizerSettings.requiresFrameQualityEstimation">
            <summary>
Does the recognizer require quality estimation
of video frames captured by camera.
</summary>
        </member>
        <member name="P:Microblink.BarDecoderRecognizerSettings.TryHarder">
            <summary>
By setting this to true, you will enabled scanning of lower resolution barcodes
at cost of additional processing time. 
</summary>
            <remarks>
This option can significantly increase recognition time. Default is false.
</remarks>
        </member>
        <member name="P:Microblink.BarDecoderRecognizerSettings.AutoScaleDetection">
            <summary>
Allow enabling the autodetection of image scale when scanning barcodes.
</summary>
            <remarks>
If set to true, prior reading barcode, image scale will be
corrected. This enables correct reading of barcodes on high
resolution images but slows down the recognition process.
</remarks>
        </member>
        <member name="P:Microblink.BarDecoderRecognizerSettings.InverseScanMode">
            <summary>
By setting this to true, you will enable scanning of barcodes with inverse
intensity values (i.e. white barcodes on dark background). 
</summary>
            <remarks>
This option can significantly increase recognition time. Default is false.
</remarks>
        </member>
        <member name="P:Microblink.BarDecoderRecognizerSettings.ScanCode39">
            <summary>
Activates or deactivates the scanning of Code39 1D barcodes.         
</summary>
            <remarks>
Default (initial) value is false.
</remarks>
        </member>
        <member name="P:Microblink.BarDecoderRecognizerSettings.ScanCode128">
            <summary>
Activates or deactivates the scanning of Code128 1D barcodes.        
</summary>
            <remarks>
Default (initial) value is false.
</remarks>
        </member>
        <member name="T:Microblink.BarDecoderRecognizerSettings">
            <summary>
Bardecoder recognizer settings
</summary>
        </member>
        <member name="M:gpumv.RenderingContextManager.terminateContext">
@brief terminateContext terminates singleton instance of rendering context

</member>
        <member name="M:gpumv.RenderingContextManager.getContext(tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief getContext return the singleton instance of adequate rendering context
@param status status of the operation
@return singleton instance of adequate rendering context

</member>
        <member name="M:gpumv.IRenderingContext.getContextType">
@brief getContextType returns the type of rendering context (Direct3D or OpenGL)
@return the type of rendering context (Direct3D or OpenGL)

</member>
        <member name="M:gpumv.IRenderingContext.getRenderingSurface">
@brief getRenderingSurface returns rendering surface on which scene can be rendered
@return rendering surface on which scene can be rendered

</member>
        <member name="M:gpumv.IRenderingContext.isContextReady">
@brief isContextReady returns true if context is ready to be used for rendering
@return true if context is ready to be used for rendering

</member>
        <member name="F:RCT_OPENGL">
Specifies family of OpenGL/OpenGL ES contexts 
</member>
        <member name="F:RCT_DIRECT3D">
Specifies family of Direct3D contexts 
</member>
        <member name="T:gpumv.IRenderingContext.RenderingContextType">
@brief The RenderingContextType enum Defines possible rendering context types.

</member>
        <member name="M:ThreadPool.getNumberOfThreads">
Returns number of threads available in pool.
@return number of threads available in pool.

</member>
        <member name="F:protection.rights.Right.appliesToProd_">
List od products this right applies to. When generating licence from web admin dashboard, this right will be available for selection for these products 
</member>
        <member name="F:protection.rights.Right.appliesToDemo_">
List of demo products this right applies to. When generating demo licence for these products, this right will always be enabled. 
</member>
        <member name="F:protection.rights.Right.name_">
short string defining the name of the right. This name is also used inside keygen
     *  when parsing command line parameters.

</member>
        <member name="F:protection.rights.Right.description_">
long string describing what is this right for 
</member>
        <member name="F:protection.rights.Right.bit_">
bit in licence key that defines this right 
</member>
        <member name="M:protection.rights.Right.isValid">
Returns true if Right is valid (existing). 
</member>
        <member name="M:protection.AppProtection.getLicenseToken(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,products.Product,tagErrorStatus*!Sys">
Tries to unlock the application with given key for given owner.
@param key License key that is used for unlocking the application.
@param licensee Name of the licensee. The key is paired with its licensee.
@param product Product for which license must be OK.
@param status [out] Return parameter for checking whether any error occurred.
@return License token that contains information about license.

</member>
        <member name="M:protection.AppProtection.getLicenseToken(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,protection.IPackageResolver!System.Runtime.CompilerServices.IsConst*,products.Product,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tries to unlock the application with given key for package name obtained via
given package resolver.
@param key License key that is used for unlocking the application.
@param pkgResolver   Interface to package resolver that will be used for resolving the package
                     name of the application. For example, on android the resolver will
                     return the package name of application context, on ios it will
                     return the name of the bundle and on windows phone it will return the application id.
@param product Product for which license must be OK.
@param status [out] Return parameter for checking whether any error occured.
@return License token that contains information about license.

</member>
        <member name="M:protection.AppProtection.getActiveTokens">
@brief getActiveTokens returns list of currently active license tokens.
If there are no active license tokens, function will return empty vector.
@return list of currently active license tokens.

</member>
        <member name="M:protection.AppProtection.getYek(System.Int32,System.Int32)">
 Generates random string of given length. The random generator is initialized with given seed.
 @param length Length of the string that will be generated.
 @param seed Seed to initialize random generator.
 @return The random string.

 @note This method is public because it is also used in PaymentDataModifier and other classes that need random strings.

</member>
        <member name="M:protection.AppProtection.registerToken(Ref&lt;protection.LicenseToken&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Registers the license token in the system so that it becomes available to use.
@param lt license token to be registered
@param activeTokensConstraint if set to true, up to MAX_ACTIVE_TOKENS license tokens can be active simultaneously.
                              In order to activate new token when all token slots are used, you have to invalidate
                              at least one valid token. If set to false, token will be always registered and will
                              replace currently registered token.
@param status Status of the operation.

</member>
        <member name="M:protection.IPackageResolver.getPackageName">
Provides package name for this application. On Android, this is app package name,
on iOS, this is bundle name, etc.
@return

</member>
        <member name="F:mv.WPARGBCameraFrame.grayscaleImage_">
Cached grayscale image 
</member>
        <member name="F:mv.WPARGBCameraFrame.bgraImage_">
Cached BGRA image (original) 
</member>
        <member name="F:mv.WPARGBCameraFrame.bgrImage_">
Cached BGR image 
</member>
        <member name="F:mv.WPARGBCameraFrame.photoFrame_">
Is image photo frame or camera frame 
</member>
        <member name="F:mv.WPARGBCameraFrame.visibleROI_">
visible ROI 
</member>
        <member name="F:mv.WPARGBCameraFrame.size_">
Image size in pixels 
</member>
        <member name="M:fq.FrameQualityEstimator.calcQuality(mv.ICameraFrame*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*)">
This method should be implemented in estimators. Method should calculate the quality of given camera frame.
@param frame Camera frame that should be analyzed
@param drawBuffer Pointer to image on which drawing is allowed (for debugging purposes).
@return The quality of the image.

</member>
        <member name="M:mv.WhiteBalanceAnalyzer.transformFactors(mv.WhiteBalanceAnalysisResult!System.Runtime.CompilerServices.IsConst*,mv.RGBFactors!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,mv.RGBFactors*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Method transforms given RGB factors in order to achieve white balance correction.
@param analysisResult result of method analyzeWhiteBalance
@param origFactors factors to be transformed
@param transformFactors transformation result

</member>
        <member name="M:mv.WhiteBalanceAnalyzer.updatePixelConverter(mv.WhiteBalanceAnalysisResult!System.Runtime.CompilerServices.IsConst*,mv.PixelConverter*)">
@brief Method updates given pixel converter's factors according to given white balance analysis result.
@param analysisResult result of method analyzeWhiteBalance
@param pixelConverter pixel converter that will be updated

</member>
        <member name="M:mv.WhiteBalanceAnalyzer.analyzeWhiteBalance(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte!System.Runtime.CompilerServices.IsConst,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Method analyzes white balance point in image bgrImage with search step searchStep (searchStep == 1 means every pixel will be analyzed).
@param bgrImage BGR or BGRA image that will be analyzed
@param searchStep step by which pixels will be analyzed. searchStep == 1 means every pixel is analyzed, searchStep == 2 means every second pixel is analyzed
@param status status of the operation
@returns Result of white balance analysis. Required for methods updatePixelConverter and transformFactors

</member>
        <member name="P:Microblink.RecognitionData.IsEmpty">
            <summary>
Indicates whether results are empty.
</summary>
        </member>
        <member name="P:Microblink.RecognitionData.IsValid">
            <summary>
Indicates whether the recognized results are valid.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.CustomerNumber">
            <summary>
Key for accessing customer number result
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.BillNumber">
            <summary>
Key for accessing bill number result
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.BarcodeData">
            <summary>
Key for accessing generic barcode data
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PDF417Result">
            <summary>
Key for accessing the pdf417 2D barcode result in USDL
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.Code128Result">
            <summary>
Key for accessing the code128 1D barcode result in USDL
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.Code39Result">
            <summary>
Key for accessing the code39 1D barcode result in USDL
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.LibInfo">
            <summary>
Key for accessing the library info for barcode readers
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.DisplayData">
            <summary>
Key for accessing the display data information in Austrian payslips
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.ContractAccount">
            <summary>
Key for accessing the contract account information in Austrian payslips
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.Belegnummer">
            <summary>
Key for accessing the document type information in Austrian payslips
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.Prufziffer">
            <summary>
Key for accessing the check digit of Austrian SEPA payslips
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.RawResult">
            <summary>
Key for accessing the raw result of OCR/barcode decode.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.CustomerData">
            <summary>
Key for accessing Tax number element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.TaxNumber">
            <summary>
Key for accessing Tax number element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PayBullURL">
            <summary>
Key for accessing PayBull URL element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PurposeCode">
            <summary>
Key for accessing Purpose Code element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PaymentDescriptionCode">
            <summary>
Key for accessing Payment Description code element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.DueDate">
            <summary>
Key for accessing Due date element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PayerName">
            <summary>
Key for accessing Payer name element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PayerID">
            <summary>
Key for accessing Payer ID element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PayerReferenceModel">
            <summary>
Key for accessing Payer reference model element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PayerReference">
            <summary>
Key for accessing Payer reference element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PayerBankCode">
            <summary>
Key for accessing Payer bank code element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PayerAccountNumber">
            <summary>
Key for accessing Payer Account number element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PayerIBAN">
            <summary>
Key for accessing Payer IBAN element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.PaymentDescription">
            <summary>
Key for accessing PaymentDescription element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.SlipID">
            <summary>
Key for accessing SlipID element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.FormID">
            <summary>
Key for accessing Form ID element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.BankName">
            <summary>
Key for accessing Bank name element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.RecipientDetailedAddress">
            <summary>
Key for accessing Recipient detailed address element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.RecipientAddress">
            <summary>
Key for accessing Recipient address element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.RecipientName">
            <summary>
Key for accessing Recipient name element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.BankCode">
            <summary>
Key for accessing Bank code element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.ReferenceModel">
            <summary>
Key for accessing Reference model element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.Reference">
            <summary>
Key for accessing Reference element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.AccountNumber">
            <summary>
Key for accessing Account number element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.BIC">
            <summary>
Key for accessing BIC element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.IBAN">
            <summary>
Key for accessing IBAN element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.Currency">
            <summary>
Key for accessing Currency element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.Amount">
            <summary>
Key for accessing Amount element.
</summary>
        </member>
        <member name="P:Microblink.RecognitionDataKeys.RecognitionDataType">
            <summary>
Key for accessing Recognition data type element.
</summary>
        </member>
        <member name="F:photopay.CroBarPaymentData.croQRCode">
PaymentDataType Constant for QR Code

</member>
        <member name="F:photopay.CroBarPaymentData.croPdf417Barcode">
PaymentDataType Constant for Pdf417 Barcode

</member>
        <member name="F:photopay.CroBarPaymentData.hub3Barcode">
Slip ID constant for HUB3

</member>
        <member name="F:photopay.CroBarPaymentData.hub1Barcode">
Slip ID constant for HUB1

</member>
        <member name="M:photopay.CroBarPaymentData.addResult(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
 Adds payment data results from a given barcode string

 @param paymentDataType
 @param barcodeResult
 @param dataIsUncertain

</member>
        <member name="M:photopay.CroBarPaymentData.splitBarcodeResult(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Splits the barcode result into separate lines according to standards

 @param barcodeResult
 @return

</member>
        <member name="M:photopay.CroBarPaymentData.Dispose">
Destructor

</member>
        <member name="M:photopay.CroBarPaymentData.#ctor(System.Boolean,photopay.RecognitionDataType)">
Default constructor

</member>
        <member name="F:photopay.CroBarPaymentData.HUB3_OPTIONAL_DATA_ROW">
Optional data is places in the 14th row 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB3_PAYMENT_DESCRIPTION_ROW">
Payment description is placed in the 13th row 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB3_PURPOSE_CODE">
Purpose code is placed in the 12th row 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB3_REFERENCE_NUMBER_ROW">
Reference number is placed in the 11th row 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB3_REFERENCE_MODEL_ROW">
Reference model is placed in the 10th row 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB3_IBAN_ACCOUNT_NUMBER_ROW">
Account number or IBAN is placed in the ninth 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB3_RECEIVER_ADDRESS2">
Receiver address, 2st part is in the eight row 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB3_RECEIVER_ADDRESS1">
Receiver address, 1st part is in the seventh row 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB3_RECEIVER_NAME_ROW">
Receiver name is in the sixth row 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB3_PAYER_NAME_ROW">
Payer name is in the third row 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB3_AMOUNT_ROW">
Amount is placed in the second row 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB1_DUE_DATE_ROW">
Due date is placed in the 17th row of the HUB1 pdf417 result 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB1_PAYMENT_DESCRIPTION_ROW">
Payment description is placed in the 16th row of the HUB1 pdf417 result 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB1_PAYMENT_DESCRIPTION_CODE_ROW">
Payment description code is placed in the 15th row of the HUB1 pdf417 result 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB1_REFERENCE_NUMBER_ROW">
Reference number is placed in the 13th row of the HUB1 pdf417 result 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB1_REFERENCE_MODEL_ROW">
Reference model is placed in the 12th row of the HUB1 pdf417 result 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB1_ACCOUNT_NUMBER_ROW">
Account number is placed in the 11th row of the HUB1 pdf417 result 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB1_RECEIVER_ADDRESS_ROW">
Receiver address is in the tenth row of the HUB1 pdf427 result 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB1_RECEIVER_NAME_ROW">
Receiver name is in the ninth row of the HUB1 pdf427 result 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB1_PAYER_NAME_ROW">
Payer name is in the fourth row of the HUB1 pdf417 result 
</member>
        <member name="F:photopay.CroBarPaymentData.HUB1_AMOUNT_ROW">
================ HUB1 ===============*
Amount is placed in the third row of the HUB1 pdf417 result 
</member>
        <member name="F:photopay.CroBarPaymentData.STANDARD_ROW">
Coding standard is placed in the first row. Standard can be HUB1 or HUB2.
</member>
        <member name="T:photopay.CroBarPaymentData">
Ecapsulates the decoding of croatian payment data from pdf417 barcode

</member>
        <member name="F:photopay.CroPaymentData.paymentDataTypeCroatianSlip">
String constant for payment data type "Croatian slip"

</member>
        <member name="F:photopay.CroPaymentData.referenceStatusInvalidChecksum">
Reference status declaring that reference has model, has checksums and
at least one checksum is not valid.

</member>
        <member name="F:photopay.CroPaymentData.referenceStatusNoChecksum">
Reference status declaring that reference has model, but model is not
protected by the checksums.

</member>
        <member name="F:photopay.CroPaymentData.referenceStatusModelUnknown">
Reference status declaring that reference has no model.

</member>
        <member name="F:photopay.CroPaymentData.referenceStatusValid">
Reference status declaring that reference has model, has checksums and
all checksums are valid.

</member>
        <member name="F:photopay.CroPaymentData.referenceStatusInvalid">
Reference status declaring that recognizer cannot conclude anything about
the reference.

</member>
        <member name="F:photopay.CroPaymentData.slipIdHub3Left">
Name of the slip id for HUB3 left 
</member>
        <member name="F:photopay.CroPaymentData.slipIdHub1Left">
Name of the slip id for HUB1 left 
</member>
        <member name="F:photopay.CroPaymentData.slipIdHub3Right">
Name of the slip id for HUB3 right 
</member>
        <member name="F:photopay.CroPaymentData.slipIdHub1Right">
Name of the slip id for HUB1 right 
</member>
        <member name="M:photopay.CroPaymentData.Dispose">
Destructor

</member>
        <member name="M:photopay.CroPaymentData.resetData">
Resets the data to default values

</member>
        <member name="M:photopay.CroPaymentData.op_Assign(photopay.CroPaymentData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assign

</member>
        <member name="M:photopay.CroPaymentData.#ctor(photopay.CroPaymentData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor

</member>
        <member name="M:photopay.CroPaymentData.#ctor(System.Boolean,System.Boolean,System.Boolean)">
Default constructor

</member>
        <member name="T:photopay.CroPaymentData">
Holds the result of recognition for croatian payments

</member>
        <member name="F:photopay.CroPaymentDataThresholds.slipIdConfidenceThreshold">
Threshold for slip id confidence level 
</member>
        <member name="F:photopay.CroPaymentDataThresholds.paymentDescriptionCodeConfidenceThreshold">
Threshold for payment description code confidence level 
</member>
        <member name="F:photopay.CroPaymentDataThresholds.payerNameConfidenceThreshold">
Threshold for payment description confidence level 
</member>
        <member name="F:photopay.CroPaymentDataThresholds.paymentDescriptionConfidenceThreshold">
Threshold for payment description confidence level 
</member>
        <member name="F:photopay.CroPaymentDataThresholds.referenceConfidenceLowerThreshold">
Threshold for reference confidence level 
</member>
        <member name="F:photopay.CroPaymentDataThresholds.accountNumberConfidenceLowerThreshold">
Threshold for account number confidence level 
</member>
        <member name="F:photopay.CroPaymentDataThresholds.amountConfidenceLowerThreshold">
Threshold for amount confidence level 
</member>
        <member name="F:photopay.CroPaymentDataThresholds.referenceConfidenceThreshold">
Threshold for reference confidence level 
</member>
        <member name="F:photopay.CroPaymentDataThresholds.accountNumberConfidenceThreshold">
Threshold for account number confidence level 
</member>
        <member name="F:photopay.CroPaymentDataThresholds.amountConfidenceThreshold">
Threshold for amount confidence level 
</member>
        <member name="M:photopay.OcrPaymentData.setIntElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,photopay.ExtractionResultHistory!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,photopay.ExtractionResultHistoryFilter!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Boolean*,System.Boolean*,System.Int32!System.Runtime.Compile">
 Method sets int element value based on it's extraction history,
 filter method and confidence thresholds

 @param elementHistory
 @param filter
 @param elementValidThreshold
 @param element

</member>
        <member name="M:photopay.OcrPaymentData.setStringElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,photopay.ExtractionResultHistory!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,photopay.ExtractionResultHistoryFilter!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Boolean*,System.Boolean*,System.Int32!System.Runtime.Comp">
 Method sets string element value based on it's extraction history,
 filter method and confidence tresholds

 @param elementHistory
 @param filter
 @param elementValidThreshold
 @param element

</member>
        <member name="M:photopay.ExtractionResultHistoryFilter.getFilteredResult(photopay.ExtractionResultHistory!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method performs traversing through result history and estimating the
 correct extraction data, based on some criterium

 @param resultHistory history of past extractions
 @return estimated extraction results

</member>
        <member name="M:photopay.ExtractionResultHistoryFilter.Dispose">
Virtual destructor

</member>
        <member name="M:photopay.ExtractionResultHistoryFilter.#ctor(Ref&lt;photopay.ElementEmptyValidator&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Constructor

 @param emptyValidator    object that will decide if element is empty based
                          on history of recognitions

</member>
        <member name="T:photopay.ExtractionResultHistoryFilter">
Object which goes through the history of extraction results and gives
the best estimate about the observed result.

</member>
        <member name="M:photopay.ElementEmptyValidator.isElementEmpty(photopay.ExtractionResultHistory!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method performs traversing through result history and decides if the element is empty.

</member>
        <member name="T:photopay.ElementEmptyValidator">
Class of objects responsible for keeping track if some element is nonexistent on the payment form

</member>
        <member name="M:photopay.ExtractionResultHistory.getHistory">
 Getter method for retrieveing history list

 @return history list

</member>
        <member name="M:photopay.ExtractionResultHistory.resetHistory">
Method deletes all results from history

</member>
        <member name="M:photopay.ExtractionResultHistory.addToHistory(photopay.ExtractionResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method takes a new Extraction result and appends it to history
@param result

</member>
        <member name="M:photopay.ExtractionResultHistory.appendOtherHistory(photopay.ExtractionResultHistory!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method takes other extraction history and appends it to this

 @param other
 @return

</member>
        <member name="M:photopay.ExtractionResultHistory.Dispose">
Virtual destructor

</member>
        <member name="M:photopay.ExtractionResultHistory.op_Assign(photopay.ExtractionResultHistory!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Assignment operator

 @param other
 @return

</member>
        <member name="M:photopay.ExtractionResultHistory.#ctor(photopay.ExtractionResultHistory!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Copy constructor

 @param other

</member>
        <member name="M:photopay.ExtractionResultHistory.#ctor">
Default constructor

</member>
        <member name="F:photopay.ExtractionResultHistory.history_">
A list of past extraction results

</member>
        <member name="T:photopay.ExtractionResultHistory">
Class responsible for keeping track of the whole history of extractions,
and providing different strategies for using this redundancy for
determining the most probable extraction results.

</member>
        <member name="F:Microblink.ScreenOrientation.LandscapeLeft">
            <summary>
Screen orientation is in left landscape mode (home button is left of screen)
</summary>
        </member>
        <member name="F:Microblink.ScreenOrientation.PortraitUpside">
            <summary>
Screen orientation is in reverse portrait mode (home button is above screen)
</summary>
        </member>
        <member name="F:Microblink.ScreenOrientation.LandscapeRight">
            <summary>
Screen orientation is in right landscape mode (home button is right of screen)
</summary>
        </member>
        <member name="F:Microblink.ScreenOrientation.Portrait">
            <summary>
Screen orientation is in portrait mode (home button is below screen)
</summary>
        </member>
        <member name="F:photopay.PhotoPaySettings.zxingReaders_">
Other settings 
which ZXing readers are enabled

</member>
        <member name="F:photopay.PhotoPaySettings.photomathRecognizerSettings">
PhotoMath recognizer

</member>
        <member name="F:photopay.PhotoPaySettings.ocrRecognizerSettings">
Use segment scanner recognizer 

</member>
        <member name="F:photopay.PhotoPaySettings.recognizersStopOnFirstSuccess_">
Stop recognizers on first valid payment data

</member>
        <member name="F:photopay.PhotoPaySettings.useSanitization_">
Use data santization

</member>
        <member name="F:photopay.PhotoPaySettings.scanPaymentDescription_">
Fields 
Use scanning of payment description field

</member>
        <member name="F:photopay.PhotoPaySettings.scanOCRQuality_">
use OcrQuality estimator recognizer

</member>
        <member name="F:photopay.PhotoPaySettings.scanMRTD_">
Scan MRTD

</member>
        <member name="F:photopay.PhotoPaySettings.scanPhotoMath_">
use PhotoMath

</member>
        <member name="F:photopay.PhotoPaySettings.useZXing_">
use ZXing barcode readers

</member>
        <member name="F:photopay.PhotoPaySettings.scanUSDriverLicense_">
Scan US Driver's License

</member>
        <member name="F:photopay.PhotoPaySettings.scanInverse_">
Use for decoding barcode with inverse intensities
(white barcode on black surface)

</member>
        <member name="F:photopay.PhotoPaySettings.autoScaleDetection_">
Use to improve detection when image scale is not known.
It may unneccessarily slow down the detection and decoding
on images of known scale.

</member>
        <member name="F:photopay.PhotoPaySettings.allowNullQuietZone_">
Use to improve detection when barcode doesn't have quiet zone
(text concatenated with barcode)

</member>
        <member name="F:photopay.PhotoPaySettings.scanUncertain_">
Use uncertain scanning

</member>
        <member name="F:photopay.PhotoPaySettings.scanPdf417_">
use PDF417 barcode reader

</member>
        <member name="F:photopay.PhotoPaySettings.ocrLineStartPercentage_">
Percentage of image height where OCR line detection starts.

</member>
        <member name="F:photopay.PhotoPaySettings.scanSwissSlip_">
Scan Swiss paymentSlip

</member>
        <member name="F:photopay.PhotoPaySettings.scanKosSlip_">
Scan Kosovo payment slip

</member>
        <member name="F:photopay.PhotoPaySettings.scanKosCode128_">
Scan Kosovo code128 barcode

</member>
        <member name="F:photopay.PhotoPaySettings.scanUkBarcodes_">
Scan UK Barcodes

</member>
        <member name="F:photopay.PhotoPaySettings.scanUkGiroSlip_">
Scan UK Giro Credit payment slip

</member>
        <member name="F:photopay.PhotoPaySettings.scanNlSlip_">
Scan Dutch OCR line

</member>
        <member name="F:photopay.PhotoPaySettings.scanBeSlip_">
use Belgian slip

</member>
        <member name="F:photopay.PhotoPaySettings.ocrOnly_">
use OCROnly recognizer

</member>
        <member name="F:photopay.PhotoPaySettings.scanPhotoBull_">
use PhotoBull

</member>
        <member name="F:photopay.PhotoPaySettings.scanDeQRCode_">
Use German QR code

</member>
        <member name="F:photopay.PhotoPaySettings.scanDeSlip_">
use German slip

</member>
        <member name="F:photopay.PhotoPaySettings.scanAusQRCode_">
use Austrian QR code

</member>
        <member name="F:photopay.PhotoPaySettings.scanAusSlip_">
scan Austrian slip

</member>
        <member name="F:photopay.PhotoPaySettings.croSlipReadPaymentDescription_">
read payment description from Croatian slip

</member>
        <member name="F:photopay.PhotoPaySettings.croSlipReadPayerName_">
read payer name from Croatian slip

</member>
        <member name="F:photopay.PhotoPaySettings.scanCroSlip_">
scan Croatian slip

</member>
        <member name="F:photopay.PhotoPaySettings.scanCroQrCode_">
scan Croatian QR Code

</member>
        <member name="F:photopay.PhotoPaySettings.scanCroPdf417_">
scan Croatian Pdf417

</member>
        <member name="F:photopay.PhotoPaySettings.scanSloSlip_">
scan Slovenian slip

</member>
        <member name="F:photopay.PhotoPaySettings.scanHuSlip_">
Countries 
scan Hungarian slip

</member>
        <member name="M:photopay.PhotoPaySettings.toString">
Serializes the settings to string for easy logging 
</member>
        <member name="F:protection.LicenseToken.licensee_">
Name of application for which rights apply to 
</member>
        <member name="F:protection.LicenseToken.pingInterval_">
ping interval in days. If set to 0, ping interval is disabled.
</member>
        <member name="F:protection.LicenseToken.validUntil_">
timestamp until license is valid. If set to 0, timestamp will not be checked.
</member>
        <member name="M:protection.LicenseToken.getNumberOfDaysSinceMicroblinkEpoch">
Returns the number of days since 1.1.2015.
@return the number of days since 1.1.2015.

</member>
        <member name="M:protection.LicenseToken.getPingInterval">
Returns the maximum allowed interval in days between two pings.
Should be used only if USE_PING right is set.
@return

</member>
        <member name="M:protection.LicenseToken.getRightsManager">
Returns the reference to the rights manager which can be used for querying
application rights.
@return reference to rights manager

</member>
        <member name="M:protection.LicenseToken.isTimeRestricted">
Returns true if licence has time restriction bit set.
@return true if licence has time restriction bit set.

</member>
        <member name="M:protection.LicenseToken.hasPing">
Returns true if licence has ping bit set.
@return true if licence has ping bit set.

</member>
        <member name="M:protection.LicenseToken.checkPing(System.Int64)">
Checks if the ping interval has passed since last time successful ping was sent.
Returns true if ping interval has not passed (i.e. it is OK to use the library).
Returns false if ping interval has passed (i.e. library cannot be used until next successful ping).
@param lastPingTimestamp unix timestamp of moment when last ping was done
@return true if ping interval has not passed, false otherwise

</member>
        <member name="M:protection.LicenseToken.invalidate">
Locks the token and invalidates the license.
Call this method when you want to lock your application. Any subsequent calls to
isValid() will return false and any subsequent call to getRightsManager will
return reference to rights manager that has no enabled rights.

</member>
        <member name="M:protection.LicenseToken.getValidVersionString">
@brief returns the string that contains maximum version number for which this license is valid
@return the string that contains maximum version number for which this license is valid

</member>
        <member name="M:protection.LicenseToken.getValidUntilString">
@brief returns the string that contains timestamp until license is valid
@return the string that contains timestamp until license is valid

</member>
        <member name="M:protection.LicenseToken.getJsonInfo(protection.RightsSerializator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructs a JSON string with information about license.
@return License information summary in JSON.

</member>
        <member name="M:protection.LicenseToken.getError">
Returns the error string.

</member>
        <member name="M:protection.LicenseToken.getInfo">
Constructs a string that contains information about license.
@return License information summary.

</member>
        <member name="M:protection.LicenseToken.validate">
Calculates the validness for 'isValid' method. Takes into account
time of expiry.

</member>
        <member name="M:protection.LicenseToken.isValid">
Checks whether application is unlocked by proper license key.
@return True if application is unlocked, otherwise false.

</member>
        <member name="T:protection.LicenseToken">
required for clearing rights 
</member>
        <member name="T:protection.AppProtection">
contains static member of rights manager which has to be initialized 
</member>
        <member name="T:protection.Keygen">
required for granting rights 

Keygen is a friend of this class so that it can access seeds.  
</member>
        <member name="T:protection.RightsManagerSerializator">
required for enabling serialization and deserialization 
</member>
        <member name="M:protection.RightsManager.clear">
Clears all rights from this rights manager and purges the owning package name.

</member>
        <member name="M:protection.RightsManager.op_Assign(protection.RightsManager*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
move assignment operator (also allowed only to friend classes)
@param other
@return

</member>
        <member name="M:protection.RightsManager.op_Assign(protection.RightsManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
assignment operator
assignment is allowed only to friend classes
@param other the rights manager to assign
@return reference to self for chaining the operators

</member>
        <member name="M:protection.RightsManager.#ctor(protection.RightsManager*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Same as with copy constructor, move constructor is also available only to friends.
@param other

</member>
        <member name="M:protection.RightsManager.#ctor(protection.RightsManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor is also private. Application parts can only use const reference
to this object obtained via AppProtection::getRightsManager
@param other

</member>
        <member name="M:protection.RightsManager.#ctor">
Constructor is private because only RightsManagerSerializator, Keygen and AppProtection
classes can construct this object.

</member>
        <member name="F:protection.RightsManager.rights_">
Set of rights enabled for this application 
</member>
        <member name="M:protection.RightsManager.getSummary">
Constructs a string that contains information about rights and owning package.
@return License information summary.

</member>
        <member name="M:protection.RightsManager.getRights">
Returns the set of rights for this application.
@return The set of rights

</member>
        <member name="M:protection.RightsManager.isRightEnabled(System.Int32)">
Checks if particular right is enabled in application
@param right The particular right to be checked
@return true if right is enabled

</member>
        <member name="M:protection.RightsManager.Dispose">
destructor

</member>
        <member name="T:protection.RightsManager">
Class responsible for managing application rights.

</member>
        <member name="F:photopay.MasterRecognizer.cameraFrameProvider_">
Object notifying GPU of new frame. 
</member>
        <member name="F:photopay.MasterRecognizer.paymentRecognizer_">
Object for recognition of payment data 
</member>
        <member name="F:photopay.MasterRecognizer.ocrManager_">
Instance of object responsible for ocr 
</member>
        <member name="F:photopay.MasterRecognizer.currentChain_">
Map: recognizer id, recognizer position in current chain 
</member>
        <member name="M:photopay.MasterRecognizer.setShouldTerminateCameraFrameProvider(System.Boolean)">
For testing purposes.

</member>
        <member name="M:photopay.MasterRecognizer.getAllInitErrorMessages">
Returns all error messages concatenated into one string.

</member>
        <member name="M:photopay.MasterRecognizer.getInitErrorMessages">
Returns the initialization error messages.

</member>
        <member name="M:photopay.MasterRecognizer.getOcrManager">
Returns the internal OCR manager.
@return the internal OCR manager.

</member>
        <member name="M:photopay.MasterRecognizer.updateRecognizers(Ref&lt;ocr.OcrManager&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Ref&lt;photopay.RecognizerSettings&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method updates the recognizer chain with given device Info, ocr Manager, and PhotoPaySettings object.

 This method enables reconfiguration of recognizer chain.

 New recognizers can be created in this method, unneded recognizers can be deleted, and used ones can be updated using
 their update method.


</member>
        <member name="M:photopay.MasterRecognizer.resetRecognizers">
Resets the results of the recognizer objects

</member>
        <member name="M:photopay.MasterRecognizer.chainRecognize(mv.ICameraFrame*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,photopay.PaymentRecognizerDelegate*)">
 Performs recognition on the given image

 @param cameraFrame       camera frame to be recognized
 @param cDelegate         delegate to communicate progress with UI
 @return                  recognition results

</member>
        <member name="M:photopay.MasterRecognizer.Dispose">
Designated destructor

</member>
        <member name="M:photopay.MasterRecognizer.#ctor(DeviceInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ref&lt;ocr.OcrManager&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Ref&lt;photopay.RecognizerSettings&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst,Ref&lt;protection.LicenseToken&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

 @param deviceInfo information about device
 @param ocrManager OCR manager object
 @param photoPayMode recognition, recognition_test or detection_test
 @param settings settings for initializing recognizers
 @param status status of the initialization operation

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.isDrawBufferAvailable">
@return true if draw buffer is available, otherwise false

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.isImageShowingAvailable">
@return true if calling showImage will do something

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.setNewDrawBuffer(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Use this callback to create new draw buffer based on given
image. This is for cases when draw buffer is not standard
frame input.
@param original

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.showDrawBuffer(screenOrientation.ScreenOrientation!System.Runtime.CompilerServices.IsConst)">
This is the callback which shows the image that was returned
via method getDrawBuffer.

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.showImage(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,photopay.ShowImageType._ImageType!System.Runtime.CompilerServices.IsConst,screenOrientation.ScreenOrientation!System.Runtime.CompilerServices.IsConst,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This is the callback which shows arbitrary image during recognition process

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.reportFailedDetection">
Method should report back to UI if the whole chain failed
to detect anything.

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.showDewarpedElement(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ocr.OcrResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
this is the callback with dewarped image
and dewarped element locations
In release mode, this method should not do anything, and in debug
mode it should for example save images and dewarped elements.
@param dewarpedImage Result of dewarping
@param dewarpedElementLocations Locations of dewarped elements.

This is the callback with dewarped element image and ocr result on this
image. This method is called by recognizers that perform multiple dewarpings.
In release mode, this method should not do anything, and in debug mode
it should save or show given image.
@param dewarpedElement Image of the dewarped element.
@param ocrResult OCR result on given image.
@param elementName Name of the dewarped element.

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.getDrawBuffer">
in debug mode, gets the draw buffer for scanner to draw
@return pointer to cv::Mat which contains draw buffer

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.publishProgress(System.Int32)">
 Publishes progress of ocr engine

 @param progress progress in range [0, 1]

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.recognitionShouldStop">
Returns true if the caller wants recognition to stop as soon as possible

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.recognitionFinished(photopay.RecognitionData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Recognizer finished recognition with result

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.recognitionStarted">
Called when the recognizer starts recognition

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.detectedForm(std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst,photopay.tagDetectionStatus!System.Runtime.CompilerServices.IsConst)">
 Called when recognizer detects the payment form.
 Also returns the coordinates of the payment form and the
 size of the image on which the form is detected.

 Coordinates of the payment form are expected to be in order:
  - upper left point
  - upper right point
  - lower left point
  - lower right point

 Also, the detection status is provided

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.detectionStarted">
Called when the recognizer starts detection

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.Dispose">
Destructor

</member>
        <member name="M:Microblink.RecognizerDelegateBridge.#ctor(Microblink.WPRecognizerDelegate)">
 Constructor

 @param javaEnvironment
 @param jDelegateInstance

</member>
        <member name="M:Microblink.WPRecognizerDelegate.ShowImageDewarped(Microblink.RecognizerImage)">
            <summary>
Dewarped image used by the recognizer.
</summary>
        </member>
        <member name="M:Microblink.WPRecognizerDelegate.ShowImageSuccessfulScan(Microblink.RecognizerImage)">
            <summary>
Successfully scaned image by the recognizer.
</summary>
        </member>
        <member name="M:Microblink.WPRecognizerDelegate.ShowImageOriginal(Microblink.RecognizerImage)">
            <summary>
Original image used by the recognizer.
</summary>
        </member>
        <member name="M:Microblink.WPRecognizerDelegate.SetPaused(System.Boolean)">
            <summary>
Tells the delegate to return paused on next should stop callback.
</summary>
        </member>
        <member name="M:Microblink.WPRecognizerDelegate.ReportFailedDetection">
            <summary>
This method is called from library when all enabled recognizers reported
failed detection on image. This notification can be used for updating the UI.
NOTE:	This method will be called from the thread in which the recognition
		process is performed.
</summary>
        </member>
        <member name="M:Microblink.WPRecognizerDelegate.PublishProgress(System.Int32)">
            <summary>
This method is called from within OCR engine to inform user
about the current progress of the OCR process. The progress
is a integer percentage of the process (integer from interval
[0, 100]).

NOTE:	This progress is reported only from OCR engine, and presents
		the progress only of the OCR process, not the whole recognition
		process which consists of form detection, image enhancing, OCR
		and interpretation of OCR result.

NOTE 2:	In future this behavior might change to present a percentage of
		a whole recognition process.

NOTE 3:	This method will be called from the thread in which the recognition
		process is performed.
</summary>
            <param name="progress">Integer progress of OCR process.</param>
        </member>
        <member name="M:Microblink.WPRecognizerDelegate.ShouldRecognitionStop">
            <summary>
This method is called from within OCR engine and should return
a boolean indicating whether or not OCR process should be canceled.
This is useful in cases OCR process lasts for a longer time, but
user wants to cancel the process.
This method is called ONLY if OCR process is performed.

NOTE:	If you cancel the OCR process, you will get an empty result
		in onRecognitionFinished callback and as a result of method
		recognize in class ManagedPhotoPay.

NOTE 2:	This method will be called from the thread in which the recognition
		process is performed.
</summary>
            <returns>true if OCR process should be canceled, otherwise false</returns>
        </member>
        <member name="M:Microblink.WPRecognizerDelegate.OnRecognitionFinished(Microblink.IRecognitionResult)">
            <summary>
This method is called from library after form recognition ends. 
Recognition result is given via parameter result and can be null, 
invalid or empty. The same result is given as a result of method
recognize in class ManagedPhotoPay.
No matter if form detection has been successful or not, this
method will ALWAYS be called.

NOTE:	This method will be called from the thread in which the recognition
		process is performed.
</summary>
        </member>
        <member name="M:Microblink.WPRecognizerDelegate.OnRecognitionStarted">
            <summary>
This method is called from library before OCR and form recognition begins, but after the form
detection process has finished. No matter if form detection has been successful or not, this
method will ALWAYS be called.

NOTE:	This method will be called from the thread in which the recognition
		process is performed.
</summary>
        </member>
        <member name="M:Microblink.WPRecognizerDelegate.OnDetectedForm(Windows.Foundation.Collections.IVector`1{Windows.Foundation.Point},Microblink.DetectionStatus,System.Int32)">
            <summary>
This method is called from library when payment form detection
process finishes. Library sends list of corner points of detected
form, or empty list - that depends on what has been detected and
that information can be obtained from detectionStatus parameter.

DetectionStatus parameter gives information about detection - whether
detection has failed or has been successful. Furthermore, this parameter
can be used to get information if image is too blurry for OCR or if
it is too far away on image to perform a successful OCR.

Method should return a boolean that should inform library whether
or not it should continue to the OCR process. If this method returns false,
OCR will not be performed (this is useful for just performing payment form
detection test in different conditions without wasting time on OCR).
If this method returns true, library will continue with the OCR and recognition
process.

NOTE:	If form was not successfully detected, OCR will not be performed even if
		this method returns true. It just makes no sense to perform OCR on images
		on which payment slip is too far away on the scene or if image is blurry.

NOTE 2:	Even if OCR is not performed (either because this method returned false, or
		because form detection has not been successful, callback methods onRecognitionStarted
		and onRecognitionFinished WILL be called. The difference is just that onRecognitionFinished
		will contain empty result.

NOTE 3:	This method will be called from the thread in which the recognition
		process is performed.
</summary>
            <param name="points">List of corner points of detected form.</param>
            <param name="detectionStatus">Information about detection</param>
            <returns>True if you want to continue OCR and recognition process, otherwise false.</returns>
        </member>
        <member name="M:Microblink.WPRecognizerDelegate.OnDetectionStarted">
            <summary>
This method is called from library when payment form detection 
process starts. Method is called for each detection separately
i.e. if multiple recognizers are enabled, method will be called
for each recognizer until one recognizer successfully reads the form.

NOTE:	This method will be called from the thread in which the recognition
		process is performed.
</summary>
        </member>
        <member name="M:Microblink.RecognizerImage.GetImageStride">
            <summary>
Returns the row step of the contained image data.
</summary>
        </member>
        <member name="M:Microblink.RecognizerImage.GetImageHeight">
            <summary>
Returns the height of the contained image data.
</summary>
        </member>
        <member name="M:Microblink.RecognizerImage.GetImageWidth">
            <summary>
Returns the width of the contained image data.
</summary>
        </member>
        <member name="M:Microblink.RecognizerImage.GetImageChannels">
            <summary>
Returns the number of color channels contained in the image data.
</summary>
        </member>
        <member name="M:Microblink.RecognizerImage.GetImageData">
            <summary>
Returns the contained image data as an array. Note that this method is
expensive since the data needs to be copied from an internal buffer.
</summary>
        </member>
        <member name="T:Microblink.RecognizerImage">
            <summary>
Represents a container for recognizer images.
</summary>
        </member>
        <member name="T:Microblink.DetectionStatus">
            <summary>
This enum contains possible detection statuses that can be result
payment form detection.
</summary>
        </member>
        <member name="F:Microblink.DetectionStatus.CameraAtAngle">
            <summary>
Form detected, but camera is at too big angle
</summary>
        </member>
        <member name="F:Microblink.DetectionStatus.PartialForm">
            <summary>
Form is detected, but parts of the form are not in image
</summary>
        </member>
        <member name="F:Microblink.DetectionStatus.PDF417Success">
            <summary>
PDF417 barcode detected
</summary>
        </member>
        <member name="F:Microblink.DetectionStatus.FallbackSuccess">
            <summary>
Fallback detection was successful
</summary>
        </member>
        <member name="F:Microblink.DetectionStatus.QRSuccess">
            <summary>
QR code detected
</summary>
        </member>
        <member name="F:Microblink.DetectionStatus.CameraTooHigh">
            <summary>
Form detected, but the camera is too far above the payment form
</summary>
        </member>
        <member name="F:Microblink.DetectionStatus.Fail">
            <summary>
Indicates form detection has failed
</summary>
        </member>
        <member name="F:Microblink.DetectionStatus.Success">
            <summary>
Indicates payment form is successfully detected
</summary>
        </member>
        <member name="P:Microblink.PDF417RecognitionResult.Elements">
            <summary>
String -&gt; Object map of result elements. 
</summary>
            <remarks> Result data can
be retrieved from this map instead of using the specific
properties in IRecognitionResult implementing classes.
In the instances when specific property is not implemented
the only way of retrieving the data is via this map.
</remarks>
        </member>
        <member name="P:Microblink.PDF417RecognitionResult.Empty">
            <summary>
Indicates if the result is empty
</summary>
        </member>
        <member name="P:Microblink.PDF417RecognitionResult.Valid">
            <summary>
Indicates if the result is valid
</summary>
        </member>
        <member name="P:Microblink.PDF417RecognitionResult.Uncertain">
            <summary>
true if returned data is uncertain.        
</summary>
            <remarks>
Only applicable if used with PDF417RecognizerSettings.UncertainScanMode set to true.
</remarks>
        </member>
        <member name="P:Microblink.PDF417RecognitionResult.RawData">
            <summary>
Raw barcode data.
</summary>
        </member>
        <member name="P:Microblink.PDF417RecognitionResult.StringData">
            <summary>
String representation of data inside barcode.
</summary>
        </member>
        <member name="T:Microblink.PDF417RecognitionResult">
            <summary>
PDF417 recognition result
</summary>
        </member>
        <member name="M:photopay.Pdf417Recognizer.resetResults">
Resets the best results in the whole chain
and clears history

</member>
        <member name="M:photopay.Pdf417Recognizer.recognize(photopay.RecognitionContext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
     * Method fills the recognition result object with
     * payment data recognized from given image

     * Returns true if scanning was successful, false otherwise

</member>
        <member name="T:Runnable">
 \file

 Runnable.hpp

  Created on: May 2, 2013
      Author: dodo

Represents anything that can be run. For use with multithreaded and
multi-process execution.


 \file

 EdgeIntensityBlurEstimator.hpp

  Created on: Feb 20, 2013
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 Runnable.hpp

  Created on: May 2, 2013
      Author: dodo

Represents anything that can be run. For use with multithreaded and
multi-process execution.

</member>
        <member name="M:mv.Interpolation.bresenhamInterpolation(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst,mv.PixelHandler*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method generates points on a straight
 line between start point and end point using Bresenham's
 algorithm. Number of points is downscaled by a given factor

 @param startPoint
 @param endPoint
 @param scaleFactor
 @param interpolatedPoints

</member>
        <member name="M:mv.Interpolation.bresenhamInterpolation(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,mv.PixelHandler*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method generates a given number of points on a straight
 line between start point and end point using Bresenham's
 algorithm.

 @param startPoint
 @param endPoint
 @param numPoints
 @param interpolatedPoints

</member>
        <member name="M:mv.Interpolation.bresenhamInterpolationStraight(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,mv.PixelHandler*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method generates points on a straight line between start point
 and end point using Bresenham's
 algorithm.

 This method deals with horizontal or vertical lines.

 @param startPoint
 @param endPoint
 @param interpolatedPoints

</member>
        <member name="M:mv.Interpolation.bresenhamInterpolation(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,mv.PixelHandler*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method generates points on a straight line between start point
 and end point using Bresenham's
 algorithm.

 @param startPoint
 @param endPoint
 @param interpolatedPoints

</member>
        <member name="M:mv.Interpolation.bresenhamInterpolationPerpendicular(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,mv.PixelHandler*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
 Method generates points on a straight line starting from startPoint in a direction
 perpendicular to direction defined with vector from firstOrientationPoint to
 secondOrientationPoint using Bresenham's interpolation. Algorithm generates
 given number of points or until it reaches image edge.

 @param startPoint
 @param firstOrientationPoint
 @param secondOrientationPoint
 @param imageSize
 @param maxNumOfPoints

</member>
        <member name="M:mv.Interpolation.bresenhamInterpolationSelectiveStraight(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,mv.PixelHandler*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method generates a given number of points on a straight
 line between start point and end point using Bresenham's
 algorithm.

 This method deals with horizontal or vertical lines.

 The method visits all points as regular bresenham and uses
 no divisions and multiplications

 @param startPoint
 @param endPoint
 @param numPoints
 @param interpolatedPoints

</member>
        <member name="M:mv.Interpolation.bresenhamInterpolationSelective(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,mv.PixelHandler*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method generates a given number of points on a straight
 line between start point and end point using Bresenham's
 algorithm.

 The method visits all points as regular bresenham and uses
 no divisions and multiplications

 @param startPoint
 @param endPoint
 @param numPoints
 @param interpolatedPoints

</member>
        <member name="M:mv.Interpolation.bresenhamInterpolationDownsampledStraight(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,mv.PixelHandler*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method generates a given number of points on a straight
 line between start point and end point using Bresenham's
 algorithm.

 This method deals with horizontal or vertical lines.

 @param startPoint
 @param endPoint
 @param numPoints
 @param interpolatedPoints

</member>
        <member name="M:mv.Interpolation.bresenhamInterpolationDownsampled(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,mv.PixelHandler*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method generates a given number of points on a straight
 line between start point and end point using Bresenham's
 algorithm.

 @param startPoint
 @param endPoint
 @param numPoints
 @param interpolatedPoints

</member>
        <member name="M:mv.Interpolation.Dispose">
Destructor

</member>
        <member name="M:mv.Interpolation.#ctor">
Private constructor to prevent instantiation

</member>
        <member name="T:mv.Interpolation">
Interpolation methods

</member>
        <member name="F:barcode.Pdf417PatternDetector.END_PATTERN_REVERSED">
Elements of the reversed pdf417 end pattern =&gt; 121113117 
</member>
        <member name="F:barcode.Pdf417PatternDetector.END_PATTERN">
Elements of the pdf417 end pattern =&gt; 711311121 
</member>
        <member name="F:barcode.Pdf417PatternDetector.END_PATTERN_SUM">
Sum of elements in the pdf417 end pattern = 18 
</member>
        <member name="F:barcode.Pdf417PatternDetector.END_PATTERN_LENGTH">
Number of elements in the pdf417 end pattern = 9 
</member>
        <member name="F:barcode.Pdf417PatternDetector.START_PATTERN_REVERSED">
Elements of the reversed pdf417 start pattern =&gt; 31111118 
</member>
        <member name="F:barcode.Pdf417PatternDetector.START_PATTERN">
Elements of the pdf417 start pattern =&gt; 81111113 
</member>
        <member name="F:barcode.Pdf417PatternDetector.START_PATTERN_SUM">
Sum of elements in the pdf417 start pattern = 17 
</member>
        <member name="F:barcode.Pdf417PatternDetector.START_PATTERN_LENGTH">
Number of elements in the pdf417 start pattern = 8 
</member>
        <member name="P:Microblink.ZXingRecognizerSettings.Enabled">
            <summary>
Indicates the recognizer is enabled
</summary>
        </member>
        <member name="M:Microblink.ZXingRecognizerSettings.requiresLandscapeMode">
            <summary>
Does the recognizer require to be used in landscape orientation
</summary>
        </member>
        <member name="M:Microblink.ZXingRecognizerSettings.requiresAutofocus">
            <summary>
Does the recognizer require camera with autofocus feature
</summary>
        </member>
        <member name="M:Microblink.ZXingRecognizerSettings.requiresOCREngine">
            <summary>
Does the recognizer require on OCR engine
</summary>
        </member>
        <member name="M:Microblink.ZXingRecognizerSettings.requiresFrameQualityEstimation">
            <summary>
Does the recognizer require quality estimation
of video frames captured by camera.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognizerSettings.UPCECode">
            <summary>
Whether or not UPCE barcode should be scanned.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognizerSettings.UPCACode">
            <summary>
Whether or not UPCA barcode should be scanned.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognizerSettings.QRCode">
            <summary>
Whether or not QR code should be scanned.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognizerSettings.ITFCode">
            <summary>
Whether or not ITF barcode should be scanned.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognizerSettings.EAN8Code">
            <summary>
Whether or not EAN8 barcode should be scanned.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognizerSettings.EAN13Code">
            <summary>
Whether or not EAN13 barcode should be scanned.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognizerSettings.DataMatrixCode">
            <summary>
Whether or not DataMatrix 2D barcode should be scanned.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognizerSettings.Code39">
            <summary>
Whether or not Code39 barcode should be scanned.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognizerSettings.Code128">
            <summary>
Whether or not Code128 barcode should be scanned.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognizerSettings.AztecCode">
            <summary>
Whether or not Aztec 2D barcode should be scanned.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognizerSettings.InverseScanMode">
            <summary>
By setting this to true, you will enable scanning of barcodes with inverse
intensity values (i.e. white barcodes on dark background).         
</summary>
            <remarks>
This option can significantly increase recognition time. Default is false.
</remarks>
        </member>
        <member name="T:Microblink.ZXingRecognizerSettings">
            <summary>
ZXing recognizer settings
</summary>
        </member>
        <member name="F:mv.WPCameraFrame.frameOrientation_">
Screen orientation of device when image frame was taken 
</member>
        <member name="F:mv.WPCameraFrame.deviceMoving_">
Was device in motion when image frame was taken 
</member>
        <member name="F:mv.WPCameraFrame.cameraFocused_">
Was camera focused when image frame was taken 
</member>
        <member name="F:mv.AbstractCameraFrame.arbitraryTransformedImages_">
Cached images converted with various pixel converters 
</member>
        <member name="F:mv.AbstractCameraFrame.awbColorImage_">
Cached white balance adjusted BGR or BGRA image 
</member>
        <member name="F:mv.AbstractCameraFrame.invertedGrayscaleImage_">
Cached inverted grayscale image 
</member>
        <member name="F:mv.AbstractCameraFrame.frameQualityEstimator_">
Frame quality estimator used for determining this frame's quality 
</member>
        <member name="F:mv.AbstractCameraFrame.whiteBalanceResult_">
Result of white balance analysis 
</member>
        <member name="F:mv.AbstractCameraFrame.whiteBalanceAnalyzer_">
White balance analyzer that is used for determining frame's white balance. 
</member>
        <member name="M:Microblink.BarcodeElement.#ctor(Ref&lt;barcode.BarcodeElement&gt;)">
BarcodeElement *
</member>
        <member name="P:Microblink.USDLRecognizerSettings.Enabled">
            <summary>
Indicates the recognizer is enabled
</summary>
        </member>
        <member name="M:Microblink.USDLRecognizerSettings.requiresLandscapeMode">
            <summary>
Does the recognizer require to be used in landscape orientation
</summary>
        </member>
        <member name="M:Microblink.USDLRecognizerSettings.requiresAutofocus">
            <summary>
Does the recognizer require camera with autofocus feature
</summary>
        </member>
        <member name="M:Microblink.USDLRecognizerSettings.requiresOCREngine">
            <summary>
Does the recognizer require on OCR engine
</summary>
        </member>
        <member name="M:Microblink.USDLRecognizerSettings.requiresFrameQualityEstimation">
            <summary>
Does the recognizer require quality estimation
of video frames captured by camera.
</summary>
        </member>
        <member name="P:Microblink.USDLRecognizerSettings.UncertainScanMode">
            <summary>
Enable scanning of non-standard elements, but there is no guarantee that all data will be read.
</summary>
            <remarks>
For Pdf417 barcode to be used when multiple rows are missing(e.g.not whole barcode is printed).
</remarks>
        </member>
        <member name="P:Microblink.USDLRecognizerSettings.NullQuietZoneAllowed">
            <summary>
Allow scanning barcodes which don't have quiet zone surrounding it(e.g.text concatenated with barcode).
</summary>
            <remarks>
This option can significantly increase recognition time.
</remarks>
        </member>
        <member name="T:Microblink.USDLRecognizerSettings">
            <summary>
US driver's license recognizer settings
</summary>
        </member>
        <member name="M:photopay.PPLibInfo.#ctor">
This constructor will obtain draft information about library.
Draft information will only contain information about which recognizers
are built in library, but will not contain information such as maximum
texture size, GPU availability, etc.

</member>
        <member name="M:photopay.PPLibInfo.#ctor(Ref&lt;ocr.OcrManager&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
this constructor will obtain full information about library
it is expected that the library is fully initialized before
creating object with this constructor
@param ocrManager

</member>
        <member name="T:photopay.PPLibInfo">
Provides information about library: which OCR engine is used,
what recognizers are enabled, etc.

</member>
        <member name="M:getLibraryBuildVersion">

  Created on: 18/03/2014
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


 \file

 RCLibraryInfo.hpp

  Created on: Jan, 2014
      Author: Ljudevit

 Copyright (c)2014 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 PPLibInfo.hpp

  Created on: Dec 11, 2012
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


  Created on: 18/03/2014
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

</member>
        <member name="F:ocr.OcrManager.availableEngines_">
vector of all available engines 
</member>
        <member name="M:ocr.OcrManager.getAvailableEngines">
@return returns vector with all available engines. Entry that is NULL is unabailable.

</member>
        <member name="M:ocr.OcrManager.Dispose">
Virtual destructor

</member>
        <member name="M:ocr.OcrManager.#ctor(tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Constructor, creates a list of available OCR engines.

 In order for OCR engine to be available, the define statement for this
 OCR engine must be provided, and all required resources for given engine
 must be available.

 @param status [out parameter] contains result of initialization

</member>
        <member name="M:ocr.OcrEngine.processImageRegions(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Rect_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ref&lt;ocr.OcrEngineOptions&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ocr.OcrEngineDelegate*,System.Boolean)">
Processes multiple image regions and creates mutiple ocr results

</member>
        <member name="M:ocr.OcrEngine.processImageRegion(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Rect_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ref&lt;ocr.OcrEngineOptions&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ocr.OcrEngineDelegate*,System.Boolean)">
Processes the given image region and creats ocr layout

</member>
        <member name="M:ocr.OcrEngine.processImage(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ref&lt;ocr.OcrEngineOptions&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ocr.OcrEngineDelegate*,System.Boolean)">
Processes the given image and creates ocr layout

</member>
        <member name="M:ocr.OcrEngine.Dispose">
Destructor

</member>
        <member name="M:ocr.OcrEngine.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor

</member>
        <member name="T:ocr.OcrEngine">
Abstraction of ocr engines

</member>
        <member name="M:ocr.OcrResult.resultByAppendingTwoResults(ocr.OcrResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ocr.OcrResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Creates a new OCR result by appending two diferent results.
 Method just appends blocks of the second result to blocks of the first result.

  @param first  first result
  @param second second result

  @return result with appended two results

</member>
        <member name="M:ocr.OcrResult.verify">
 Method performs verification

 @return true if verifiable object has no errors, false otherwise

</member>
        <member name="M:ocr.OcrResult.setTransform(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Sets the transform property

  @param transform

</member>
        <member name="M:ocr.OcrResult.getTransform">
 Returns transform parameteres for tranforming OCR result to device UI

  @return transform

</member>
        <member name="M:ocr.OcrResult.isFlipped">
Returns true if the result is rotated by 180 degrees

</member>
        <member name="M:ocr.OcrResult.isEmpty">
Returns true if the result is empty

</member>
        <member name="M:ocr.OcrResult.getAvgQuality">
 Estimates quality of ocr block

 @return

</member>
        <member name="M:ocr.OcrResult.getSumQuality">
 Estimates quality of ocr block

 @return

</member>
        <member name="M:ocr.OcrResult.drawResult(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Method draws the ocrResult on a given image

</member>
        <member name="M:ocr.OcrResult.getBoundingBox">
Returns the bounding box arount the ocr result

</member>
        <member name="M:ocr.OcrResult.log(System.Int32,System.Boolean)">
Logs the result to std stream

</member>
        <member name="M:ocr.OcrResult.createIterator">
Returns the object which can iterate through the result

</member>
        <member name="M:ocr.OcrResult.toString">
Returns the result as string

</member>
        <member name="M:ocr.OcrResult.removeBlockAt(std._List_iterator&lt;std._List_val&lt;std._List_simple_types&lt;ocr.OcrBlock&gt;&gt;&gt;)">
Erases block at given iterator and returns the iterator that points
to the block that follows the removed one. If the removed block was
last in result, the returned iterator points to past last block in
the result (value that can be obtained with method @{link getResultEnd}).

</member>
        <member name="M:ocr.OcrResult.getResultEnd">
Returns the iterator that points to past last block in the result


Returns the iterator that points to past last block in the result

</member>
        <member name="M:ocr.OcrResult.getResultBeginning">
Returns the iterator that points to the first block in the result


Returns the const iterator that points to the first block in the result

</member>
        <member name="M:ocr.OcrResult.getCharCount">
 Returns number of chars in the result

 @return

</member>
        <member name="M:ocr.OcrResult.getBlockCount">
Returns the number of blocks in result

</member>
        <member name="M:ocr.OcrResult.Dispose">
Destructor

</member>
        <member name="M:ocr.OcrResult.op_Assign(ocr.OcrResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move-Assignment operator

</member>
        <member name="M:ocr.OcrResult.op_Assign(ocr.OcrResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy-Assignment operator

</member>
        <member name="M:ocr.OcrResult.#ctor(ocr.OcrResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move constructor

</member>
        <member name="M:ocr.OcrResult.#ctor(ocr.OcrResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor

</member>
        <member name="M:ocr.OcrResult.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor which takes string

</member>
        <member name="M:ocr.OcrResult.#ctor(std.list&lt;ocr.OcrBlock&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ocr.Box,System.Boolean)">
Constructor which takes prebuild blocks

</member>
        <member name="F:ocr.OcrResult.transform_">
Transformation matrix for transforming OCR result coordinates into coordiantes on the 
device UI.

</member>
        <member name="F:ocr.OcrResult.boundingBox_">
Bounding box around ocr result

</member>
        <member name="F:ocr.OcrResult.blocks_">
Blocks in result

</member>
        <member name="T:ocr.OcrResult">
Encapsulates the OCR results

</member>
        <member name="M:ocr.OcrResultIterator.getCurrentCharIndexInResult">
Finds the index of the current char in the result

</member>
        <member name="M:ocr.OcrResultIterator.op_Inequality(ocr.OcrResultIterator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
compares two iterators for equality and returns false if they are equal

</member>
        <member name="M:ocr.OcrResultIterator.op_Equality(ocr.OcrResultIterator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
compares two iterators for equality and returns true if they are equal

</member>
        <member name="M:ocr.OcrResultIterator.reset">
Resets the iterator to the beginning of the ocr result

</member>
        <member name="M:ocr.OcrResultIterator.deleteCurrentChar(tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Deletes the current character in the layout and moves
iterator to the next character (same as consumeNextChar)
@param status

</member>
        <member name="M:ocr.OcrResultIterator.consumeNextChar(tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Consumes the next character in the layout

</member>
        <member name="M:ocr.OcrResultIterator.getFollowingText(System.Int32)">
Iterates through the ocr result from the current point to next n characters
(iterates to end if n==0) and returns the obtained string

</member>
        <member name="M:ocr.OcrResultIterator.isOutOfBounds">
Returns true if the interator passed the last char in the whole layout

</member>
        <member name="M:ocr.OcrResultIterator.isEndOfLayout">
Returns true if the interator is on the last char in the whole layout

</member>
        <member name="M:ocr.OcrResultIterator.isEndOfBlock">
Returns true if the interator is on the last char in the current block

</member>
        <member name="M:ocr.OcrResultIterator.isEndOfLine">
Returns true if the iterator is on the last char in the current line

</member>
        <member name="M:ocr.OcrResultIterator.getCurrentLineLength">
Returns the length of the line the iterator is currently on.

</member>
        <member name="M:ocr.OcrResultIterator.getCurrentChar(tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the pointer to the current ocr character

</member>
        <member name="M:ocr.OcrResultIterator.Dispose">
Destructor

</member>
        <member name="M:ocr.OcrResultIterator.op_Assign(ocr.OcrResultIterator*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move-Assignment operator

</member>
        <member name="M:ocr.OcrResultIterator.op_Assign(ocr.OcrResultIterator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy-Assignment operator

</member>
        <member name="M:ocr.OcrResultIterator.#ctor(ocr.OcrResultIterator*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move constructor

</member>
        <member name="M:ocr.OcrResultIterator.#ctor(ocr.OcrResultIterator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor

</member>
        <member name="M:ocr.OcrResultIterator.#ctor(ocr.OcrResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor

</member>
        <member name="F:ocr.OcrResultIterator.currentCharacter_">
current OCR character 
</member>
        <member name="F:ocr.OcrResultIterator.currentLine_">
current OCR line 
</member>
        <member name="F:ocr.OcrResultIterator.currentBlock_">
current OCR block 
</member>
        <member name="F:ocr.OcrResultIterator.ocrResult_">
Result over which we wish to iterate 
</member>
        <member name="T:ocr.OcrResultIterator">
Class responsible for iterating over OcrResult

</member>
        <member name="M:ocr.OcrBlock.verify">
 Method performs verification

 @return true if verifiable object has no errors, false otherwise

</member>
        <member name="M:ocr.OcrBlock.getSumQuality">
 Estimates quality of ocr block

 @return

</member>
        <member name="M:ocr.OcrBlock.log(System.Int32,System.Boolean)">
Logs the result to std stream

</member>
        <member name="M:ocr.OcrBlock.removeLineAt(std._List_iterator&lt;std._List_val&lt;std._List_simple_types&lt;ocr.OcrLine&gt;&gt;&gt;)">
Removes the line at specific index and returns the iterator that
points to the line that follows the removed one. If the removed
line was the last in block, the returned iterator points to past
last line in block (the same value that can be obtained with
method @{link getBlockEnd}).

</member>
        <member name="M:ocr.OcrBlock.getBlockEnd">
Returns the iterator that points to past last line in block


Returns the iterator that points to past last line in block

</member>
        <member name="M:ocr.OcrBlock.getBlockBeginning">
Returns the iterator that points to first line in block


Returns the iterator that points to first line in block

</member>
        <member name="M:ocr.OcrBlock.getCharCount">
 Returns number of chars in the block

 @return

</member>
        <member name="M:ocr.OcrBlock.getLineCount">
Returns the character count in the line

</member>
        <member name="M:ocr.OcrBlock.Dispose">
Destructor

</member>
        <member name="M:ocr.OcrBlock.op_Assign(ocr.OcrBlock*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move-Assignment operator

</member>
        <member name="M:ocr.OcrBlock.op_Assign(ocr.OcrBlock!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy-Assignment operator

</member>
        <member name="M:ocr.OcrBlock.#ctor(ocr.OcrBlock*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move constructor

</member>
        <member name="M:ocr.OcrBlock.#ctor(ocr.OcrBlock!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor

</member>
        <member name="M:ocr.OcrBlock.#ctor(std.list&lt;ocr.OcrLine&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ocr.Box)">
Constructor

</member>
        <member name="F:ocr.OcrBlock.box_">
Bounding box of the block

</member>
        <member name="F:ocr.OcrBlock.lines_">
lines in block

</member>
        <member name="T:ocr.OcrBlock">
Represents the block of text in ocr result

</member>
        <member name="M:ocr.OcrLine.verify">
 Method performs verification

 @return true if verifiable object has no errors, false otherwise

</member>
        <member name="M:ocr.OcrLine.getSumQuality">
 Estimates quality of ocr line

 @return

</member>
        <member name="M:ocr.OcrLine.containsValue(System.UInt16!System.Runtime.CompilerServices.IsConst)">
 Returns true if line contains given value

 @return

</member>
        <member name="M:ocr.OcrLine.log(System.Int32,System.Boolean)">
Logs the result to std stream

</member>
        <member name="M:ocr.OcrLine.getAvgQuality">
 Method iterates through all chars and returns average char quality

 @return

</member>
        <member name="M:ocr.OcrLine.appendNewline">
Appends the newline character at the end of the line

</member>
        <member name="M:ocr.OcrLine.prependNewline">
Prepends the newline character at the front of the line

</member>
        <member name="M:ocr.OcrLine.lineWithTrimmedWhitespace">
 Creates the Ocr Line which has trimmed all whitespace from front and end of the line

 @return

</member>
        <member name="M:ocr.OcrLine.removeCharAt(std._List_iterator&lt;std._List_val&lt;std._List_simple_types&lt;ocr.OcrChar&gt;&gt;&gt;)">
Removes the char at specific iterator and returns an iterator
to the char after the removed one. If the removed character was
the last in line, the returned iterator points to past the end
of line (value that can be obtained with @{link getLineEnd}).

</member>
        <member name="M:ocr.OcrLine.getLineEnd">
Returns the iterator that points to past end of line


Returns the iterator that points to past end of line

</member>
        <member name="M:ocr.OcrLine.getLineBeginning">
Returns the iterator that points to first character in line


Returns the iterator that points to first character in line

</member>
        <member name="M:ocr.OcrLine.getCharCount">
Returns the character count in the line

</member>
        <member name="M:ocr.OcrLine.Dispose">
Destructor

</member>
        <member name="M:ocr.OcrLine.op_Assign(ocr.OcrLine*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move-Assignment operator

</member>
        <member name="M:ocr.OcrLine.op_Assign(ocr.OcrLine!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy-Assignment operator

</member>
        <member name="M:ocr.OcrLine.#ctor(ocr.OcrLine*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move constructor

</member>
        <member name="M:ocr.OcrLine.#ctor(ocr.OcrLine!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor

</member>
        <member name="M:ocr.OcrLine.#ctor(std.list&lt;ocr.OcrChar&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ocr.Box)">
Constructor

</member>
        <member name="F:ocr.OcrLine.box_">
Bounding box of the line

</member>
        <member name="F:ocr.OcrLine.chars_">
Chars in line

</member>
        <member name="T:ocr.OcrLine">
Represents the line in ocr result

</member>
        <member name="M:ocr.OcrChar.verify">
 Method performs verification

 @return true if verifiable object has no errors, false otherwise

</member>
        <member name="M:ocr.OcrChar.getEstimatedQuality">
 Estimates quality of the char

 @return

</member>
        <member name="M:ocr.OcrChar.log(System.Int32,System.Boolean)">
Logs the result to std stream

</member>
        <member name="M:ocr.OcrChar.getBaseline">
Returns the baseline of the character

</member>
        <member name="M:ocr.OcrChar.setUncertain(System.Boolean)">
 Sets the uncertain valie

 @param uncertain

</member>
        <member name="M:ocr.OcrChar.isUncertain">
Returns true if character is uncertain

</member>
        <member name="M:ocr.OcrChar.isItalic">
Returns true if character is italic

</member>
        <member name="M:ocr.OcrChar.isBold">
Returns true if character is bold

</member>
        <member name="M:ocr.OcrChar.addQualityFactor(System.Single)">
 Sets the quality of ocr char

 @param quality

</member>
        <member name="M:ocr.OcrChar.getQualityFactor">
Returns the quality factor of the char

</member>
        <member name="M:ocr.OcrChar.setQuality(System.Int32)">
 Sets the quality of ocr char

 @param quality

</member>
        <member name="M:ocr.OcrChar.getQuality">
Returns the quality of the char in interval [0, 100];

</member>
        <member name="M:ocr.OcrChar.setBoundingBox(ocr.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Sets the new Box for the char

 @param newBox

</member>
        <member name="M:ocr.OcrChar.getBoundingBox">
Returns the bounding box around the character

</member>
        <member name="M:ocr.OcrChar.setFont(ocr.OcrFont!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the new font of the character

</member>
        <member name="M:ocr.OcrChar.getFont">
Returns the font of the character

</member>
        <member name="M:ocr.OcrChar.setHeight(System.UInt16)">
Sets the new height of the character

</member>
        <member name="M:ocr.OcrChar.getHeight">
Returns the height of the character

</member>
        <member name="M:ocr.OcrChar.setValue(System.Char!System.Runtime.CompilerServices.IsConst)">
Sets the new value for this char

</member>
        <member name="M:ocr.OcrChar.getValue">
Returns the value of the character in UNICODE format

</member>
        <member name="M:ocr.OcrChar.Dispose">
Destructor

</member>
        <member name="M:ocr.OcrChar.getRecognitionVariants">
returns the list of recognition variants for current OcrChar 
</member>
        <member name="M:ocr.OcrChar.op_Assign(ocr.OcrChar*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move-Assignment operator

</member>
        <member name="M:ocr.OcrChar.op_Assign(ocr.OcrChar!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy-Assignment operator

</member>
        <member name="M:ocr.OcrChar.#ctor(ocr.OcrChar*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move constructor

</member>
        <member name="M:ocr.OcrChar.#ctor(ocr.OcrChar!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor

</member>
        <member name="M:ocr.OcrChar.#ctor(System.Char,System.UInt16,ocr.Box,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Single,ocr.OcrFont,std.list&lt;ocr.OcrChar&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16)">
Constructor

</member>
        <member name="F:ocr.OcrChar.baseline_">
Char baseline location

</member>
        <member name="F:ocr.OcrChar.variants_">
Recognition variants for current OCR char 
</member>
        <member name="F:ocr.OcrChar.font_">
Ocr font 
</member>
        <member name="F:ocr.OcrChar.qualityFactor_">
Factor which multiplies quality estimate

</member>
        <member name="F:ocr.OcrChar.isUncertain_">
Is character uncertain?

</member>
        <member name="F:ocr.OcrChar.isItalic_">
Is character italic?

</member>
        <member name="F:ocr.OcrChar.isBold_">
Is character bold?

</member>
        <member name="F:ocr.OcrChar.quality_">
Quality of the char

</member>
        <member name="F:ocr.OcrChar.box_">
Bounding box of the char

</member>
        <member name="F:ocr.OcrChar.height_">
Height of the char

</member>
        <member name="F:ocr.OcrChar.value_">
Return the value of char

</member>
        <member name="T:ocr.OcrChar">
Character representation

</member>
        <member name="M:Verifiable.verify">
 Method performs verification

 @return true if verifiable object has no errors, false otherwise

</member>
        <member name="M:Verifiable.Dispose">
Virtual destructor 
</member>
        <member name="M:Verifiable.#ctor">
 Constructor

 Private to prevent instantiation.

</member>
        <member name="T:Verifiable">
Interface for all classes which integrity can be verified at runtime

</member>
        <member name="M:isAlpha(System.Char)">
 \file

 PPLibInfo.hpp

  Created on: Dec 11, 2012
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 OcrEngine.hpp

  Created on: Jun 12, 2012
      Author: cerovec

 \file

 OcrResult.h

  Created on: May 6, 2012
      Author: cerovec

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 OcrBlock.h

  Created on: May 6, 2012
      Author: cerovec

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 OcrLine.h

  Created on: May 6, 2012
      Author: cerovec

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 OcrChar.h

  Created on: May 6, 2012
      Author: cerovec

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 wchar.h

  Created on: Nov 28, 2012
      Author: dodo

 Copyright (c)2012 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


 \file

 OcrEngine.hpp

  Created on: Jun 12, 2012
      Author: cerovec

 \file

 OcrResult.h

  Created on: May 6, 2012
      Author: cerovec

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 OcrBlock.h

  Created on: May 6, 2012
      Author: cerovec

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 OcrLine.h

  Created on: May 6, 2012
      Author: cerovec

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 OcrChar.h

  Created on: May 6, 2012
      Author: cerovec

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 wchar.h

  Created on: Nov 28, 2012
      Author: dodo

 Copyright (c)2012 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

</member>
        <member name="F:ResourceManager.observers_">
Collection of objects notified on resource changes.

</member>
        <member name="F:ResourceManager.resources_">
Table in which resources are stored.

</member>
        <member name="M:ResourceManager.notifyObservers(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify all registered observer that entry with resID key changed.

</member>
        <member name="M:ResourceManager.Dispose">
Destroys the resources table

</member>
        <member name="M:ResourceManager.#ctor">
Constructor. Creates empty resources table

</member>
        <member name="M:ResourceManager.clearAllEntries">
Method empties the resource map, but does not perform any deallocations.

</member>
        <member name="M:ResourceManager.getAllResources">
Retrieves all entries. Used in DetectorStudio to free allocated memory
for all resources. On Android side, memory is freed on Java side.
@return Reference to map with all resources.

</member>
        <member name="M:ResourceManager.unregisterObserver(ResourceManagerObserver*)">
Remove an observer from this resource manager.

</member>
        <member name="M:ResourceManager.registerObserver(ResourceManagerObserver*)">
Register an observer on this resource manager.

</member>
        <member name="M:ResourceManager.getResource(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves the entry with given key string. Available resources can be obtained
with static key strings given in this class.

@param resID key string under which the data is stored in the table

</member>
        <member name="M:ResourceManager.addEntry(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
     * Adds new entry in the table
     
     * @param resID - string key under which the entry is stored
     * @param resData - data of the entry
     * @param resDataLength - length of the entry in bytes

</member>
        <member name="M:ResourceManager.getInstance">
@brief getResourceManager returns the resource manager singleton instance
@return the resource manager singleton instance

</member>
        <member name="F:ResourceManager.KEY_ABBYY_EUROPEAN_PATTERNS">
List of keys under which the data entries are stored in the table 
</member>
        <member name="T:ResourceManager">
class responsible for managing in-memory resources

</member>
        <member name="M:ResourceEntry.#ctor(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
 Creates entry from pointer to data and its length

 @param resData - pointer to data
 @param resLength - length of the data in bytes

</member>
        <member name="M:ResourceEntry.#ctor">
Creates empty entry - data points nowhere (NULL), and the length is 0

</member>
        <member name="F:ResourceEntry.resLength">
Lenght of the data in bytes 
</member>
        <member name="F:ResourceEntry.resData">
Pointer to the data 
</member>
        <member name="T:ResourceEntry">
Entry in the resources table.
Consists of the pointer to the data and length of the data 

</member>
        <member name="T:ResourceManagerObserver">
 \file

 ResourceManager.hpp

  Created on: Dec 23, 2012
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

</member>
        <member name="M:saveTextToFile(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Save text to IsolatedStorage of application.

</member>
        <member name="M:saveImageToFile(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Save cvMat to IsolatedStorage of application. Image is automatically prefixed with timestamp.

</member>
        <member name="M:createRecognitionResultList(std.vector&lt;Ref&lt;photopay.RecognitionData&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create vector of result data.

</member>
        <member name="M:createRecognitionResult(photopay.RecognitionData*)">
**
**
Create appropriate result

</member>
        <member name="P:Microblink.PDF417RecognizerSettings.Enabled">
            <summary>
Indicates the recognizer is enabled
</summary>
        </member>
        <member name="M:Microblink.PDF417RecognizerSettings.requiresLandscapeMode">
            <summary>
Does the recognizer require to be used in landscape orientation
</summary>
        </member>
        <member name="M:Microblink.PDF417RecognizerSettings.requiresAutofocus">
            <summary>
Does the recognizer require camera with autofocus feature
</summary>
        </member>
        <member name="M:Microblink.PDF417RecognizerSettings.requiresOCREngine">
            <summary>
Does the recognizer require on OCR engine
</summary>
        </member>
        <member name="M:Microblink.PDF417RecognizerSettings.requiresFrameQualityEstimation">
            <summary>
Does the recognizer require quality estimation
of video frames captured by camera.
</summary>
        </member>
        <member name="P:Microblink.PDF417RecognizerSettings.InverseScanMode">
            <summary>
By setting this to true, you will enable scanning of barcodes with inverse
intensity values (i.e. white barcodes on dark background).         
</summary>
            <remarks>
This option can significantly increase recognition time. Default is false.
</remarks>
        </member>
        <member name="P:Microblink.PDF417RecognizerSettings.NullQuietZoneAllowed">
            <summary>
Allow scanning barcodes which don't have quiet zone surrounding it(e.g.text concatenated with barcode).
</summary>
            <remarks>
This option can significantly increase recognition time.
</remarks>
        </member>
        <member name="P:Microblink.PDF417RecognizerSettings.UncertainScanMode">
            <summary>
Enable scanning of non-standard elements, but there is no guarantee that all data will be read.
</summary>
            <remarks>
For Pdf417 barcode to be used when multiple rows are missing(e.g.not whole barcode is printed).
</remarks>
        </member>
        <member name="T:Microblink.PDF417RecognizerSettings">
            <summary>
PDF417 recognizer settings
</summary>
        </member>
        <member name="P:Microblink.IRecognizerSettings.Enabled">
            <summary>
Indicates the recognizer is enabled
</summary>
        </member>
        <member name="M:Microblink.IRecognizerSettings.requiresLandscapeMode">
            <summary>
Does the recognizer require to be used in landscape orientation
</summary>
        </member>
        <member name="M:Microblink.IRecognizerSettings.requiresAutofocus">
            <summary>
Does the recognizer require camera with autofocus feature
</summary>
        </member>
        <member name="M:Microblink.IRecognizerSettings.requiresOCREngine">
            <summary>
Does the recognizer require on OCR engine
</summary>
        </member>
        <member name="M:Microblink.IRecognizerSettings.requiresFrameQualityEstimation">
            <summary>
Does the recognizer require quality estimation
of video frames captured by camera.
</summary>
        </member>
        <member name="T:Microblink.IRecognizerSettings">
            <summary>
Base interface for all recognizer settings classes
</summary>
        </member>
        <member name="F:Microblink.RecognitionMode.DetectionTestMode">
            <summary>
will perform only detection and will profile the performance of slip
detection
</summary>
        </member>
        <member name="F:Microblink.RecognitionMode.RecognitionTestMode">
            <summary>
will perform indefinite scan and will profile the performance of scans
</summary>
        </member>
        <member name="F:Microblink.RecognitionMode.Normal">
            <summary>
indicates normal scanning operation
</summary>
        </member>
        <member name="P:Microblink.BarDecoderRecognitionResult.Elements">
            <summary>
String -&gt; Object map of result elements. 
</summary>
            <remarks> Result data can
be retrieved from this map instead of using the specific
properties in IRecognitionResult implementing classes.
In the instances when specific property is not implemented
the only way of retrieving the data is via this map.
</remarks>
        </member>
        <member name="P:Microblink.BarDecoderRecognitionResult.Empty">
            <summary>
Indicates if the result is empty
</summary>
        </member>
        <member name="P:Microblink.BarDecoderRecognitionResult.Valid">
            <summary>
Indicates if the result is valid
</summary>
        </member>
        <member name="P:Microblink.BarDecoderRecognitionResult.ExtendedRawData">
            <summary>
Raw extended barcode data. 
</summary>
            <remarks>
Available only on barcodes that support extended data encoding (e.g. code39).
</remarks>
        </member>
        <member name="P:Microblink.BarDecoderRecognitionResult.RawData">
            <summary>
Raw barcode data.
</summary>
        </member>
        <member name="P:Microblink.BarDecoderRecognitionResult.ExtendedStringData">
            <summary>
String representation of extended data.         
</summary>
            <remarks>
Available only on barcodes that support extended data encoding (e.g. code39).
</remarks>
        </member>
        <member name="P:Microblink.BarDecoderRecognitionResult.StringData">
            <summary>
String representation of data inside barcode.
</summary>
        </member>
        <member name="P:Microblink.BarDecoderRecognitionResult.BarcodeTypeString">
            <summary>
Type of barcode scanned with BarDecoder recognizer as string. 
</summary>
            <remarks>
Currently this can only be CODE128 or CODE39.
</remarks>
        </member>
        <member name="P:Microblink.BarDecoderRecognitionResult.BarcodeType">
            <summary>
Type of barcode scanned with BarDecoder recognizer. 
</summary>
            <remarks>
Currently this can only be CODE128 or CODE39.
</remarks>
        </member>
        <member name="T:Microblink.BarDecoderRecognitionResult">
            <summary>
Bardecoder recognition result
</summary>
        </member>
        <member name="M:photopay.BarDecoderRecognizer.setAutoScaleDetection(System.Boolean)">
 Enables detecting the scale of the image before performing a barcode read.

 @param autoScale

</member>
        <member name="M:photopay.BarDecoderRecognizer.setTryHarder(System.Boolean)">
 Enables decoding of barcodes without quiet zone round the barcode
 (e.g. text concatenated with barcode blocks)

 @param tryHarder

</member>
        <member name="M:photopay.BarDecoderRecognizer.setUseUncertainDecoding(System.Boolean)">
 Enables decoding of barcodes where multiple rows are missing from the end of the barcode
 (e.g. when more lines at the end of barcode are not printed, and there is not enough
 error correction codewords left to compensate for missing rows)

 @param useUncertainDecoding

</member>
        <member name="M:photopay.BarDecoderRecognizer.resetResults">
Resets the best results in the whole chain
and clears history

</member>
        <member name="M:photopay.BarDecoderRecognizer.recognize(photopay.RecognitionContext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
     * Method fills the recognition result object with
     * payment data recognized from given image

     * Returns true if scanning was successful, false otherwise

</member>
        <member name="M:photopay.BarDecoderRecognizer.Dispose">
Virtual destructor

</member>
        <member name="M:photopay.BarDecoderRecognizer.#ctor(Ref&lt;photopay.BarDecoderRecognizerSettings&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor

</member>
        <member name="M:photopay.BarDecoderRecognizer.alreadyDetected(std.vector&lt;Ref&lt;photopay.RecognitionData&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Returns true is we already have given paymentDataType earlier in chain

 @param results
 @param paymentDataType

</member>
        <member name="F:photopay.BarDecoderRecognizer.code128Reader_">
Object responsible for reading Code128 barcodes

</member>
        <member name="F:photopay.BarDecoderRecognizer.code39Reader_">
Object responsible for reading Code39 barcodes

</member>
        <member name="F:photopay.BarDecoderRecognizer.barDecoderData_">
Object which stored barcode result

</member>
        <member name="T:photopay.BarDecoderRecognizer">
Recognizer which scans image for Code39 barcodes

</member>
        <member name="M:photopay.BarDecoderData.addBarcodeData(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,barcode.BarcodeData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Adds barcode results

 @param barcodeData - BarDecoder object with barcode information embedded

</member>
        <member name="M:photopay.BarDecoderData.Dispose">
Virtual destructor

</member>
        <member name="M:photopay.BarDecoderData.#ctor">
 Constructor

 Sets paymentDataType to UNKNOWN value. Users are responsible for setting that value.

</member>
        <member name="T:photopay.BarDecoderData">
BarDecoder data for scanning results

</member>
        <member name="M:photopay.BarDecoderDelegate.detectionStarted">
Called when the recognizer starts detection

</member>
        <member name="M:photopay.BarDecoderDelegate.Dispose">
Virtual destructor

</member>
        <member name="M:photopay.BarDecoderDelegate.#ctor(photopay.PaymentRecognizerDelegate*)">
Constructor

</member>
        <member name="F:photopay.BarDecoderDelegate.paymentDelegate_">
Private instance of BarcodeRecognizerDelegate

</member>
        <member name="T:photopay.BarDecoderDelegate">
Delegate object which serves as bridge between PaymentRecognizerDelegate
and BarcodeRecognizerDelegate.

</member>
        <member name="F:barcode.Code128PatternDetector.END_PATTERN_REVERSED">
Elements of the reversed Code128 end pattern =&gt; 2111332 
</member>
        <member name="F:barcode.Code128PatternDetector.END_PATTERN">
Elements of the Code128 end pattern =&gt; 2331112 
</member>
        <member name="F:barcode.Code128PatternDetector.END_PATTERN_SUM">
Sum of elements in the Code128 end pattern = 13 
</member>
        <member name="F:barcode.Code128PatternDetector.END_PATTERN_LENGTH">
Number of elements in the Code128 end pattern = 7 
</member>
        <member name="F:barcode.Code128PatternDetector.START_PATTERN_REVERSED_C">
Elements of the reversed Code128 start pattern for Subtype C =&gt; 31111118 
</member>
        <member name="F:barcode.Code128PatternDetector.START_PATTERN_C">
Elements of the Code128 start pattern for Subtype C =&gt; 211232 
</member>
        <member name="F:barcode.Code128PatternDetector.START_PATTERN_REVERSED_B">
Elements of the reversed Code128 start pattern for Subtype B =&gt; 412112 
</member>
        <member name="F:barcode.Code128PatternDetector.START_PATTERN_B">
Elements of the Code39 start pattern for Subtype B =&gt; 211214 
</member>
        <member name="F:barcode.Code128PatternDetector.START_PATTERN_REVERSED_A">
Elements of the reversed Code128 start pattern for Subtype A =&gt; 214112 
</member>
        <member name="F:barcode.Code128PatternDetector.START_PATTERN_A">
Elements of the Code128 start pattern for Subtype A =&gt; 211412 
</member>
        <member name="F:barcode.Code128PatternDetector.START_PATTERN_SUM">
Sum of elements in the Code128 start pattern = 11 
</member>
        <member name="F:barcode.Code128PatternDetector.START_PATTERN_LENGTH">
Number of elements in the Code128 start pattern = 6 
</member>
        <member name="F:barcode.Code128PatternDetector.PATTERN_SUM">
Sum of elements in all Code128 patterns = 11 
</member>
        <member name="F:barcode.Code128PatternDetector.PATTERN_LENGTH">
Number of elements in all Code128 patterns = 6 
</member>
        <member name="F:barcode.Code128PatternDetector.MAX_DECODING_AVERAGE_DIFFERENCE">
Maximum allowed average difference between patterns to consider them equal 
</member>
        <member name="F:barcode.Code128PatternDetector.MAX_DECODING_INDIVIDUAL_DIFFERENCE">
Maximum allowed difference between individual elements of two patterns
</member>
        <member name="F:barcode.Code39PatternDetector.PATTERN_REVERSED">
Elements of the reversed Code39 pattern =&gt; 112121121 
</member>
        <member name="F:barcode.Code39PatternDetector.PATTERN">
Elements of the Code39 pattern =&gt; 121121211 
</member>
        <member name="F:barcode.Code39PatternDetector.PATTERN_SUM">
Sum of elements in the Code39 pattern = 12 
</member>
        <member name="F:barcode.Code39PatternDetector.PATTERN_LENGTH">
Number of elements in the Code39 pattern = 9 
</member>
        <member name="M:barcode.PatternDetector.detectOnScanLine(barcode.ScanLine!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,barcode.LineSegment*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,barcode.LineSegment*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.pair&lt;System.Single,barcode.DetectionMode&gt;!System.Runtime.CompilerServices.IsConst,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Used to determine if given scanLine passes true barcode. First start and stop pattern are found if they exist,
and then border follow is used to found exact position of each barcode block.

</member>
        <member name="M:barcode.PatternDetector.findStartOrStopSequences(barcode.ScanLine!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.pair&lt;System.Single,System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.pair&lt;System.Single,System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tag">
Finds start and stop sequences from given vector with edges of the barcode line

</member>
        <member name="M:barcode.PatternDetector.calcPatternMatchVariance(barcode.ScanLine!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst,System.Boolean,std.pair&lt;System.Single,System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.pair&lt;System.Single,System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Function determines if the current edge sequence correspondes to a given patterns.
Edge sequence must start with black bar.

</member>
        <member name="F:barcode.PatternDetector.MAX_AVERAGE_DIFFERENCE">
Maximum allowed average difference between patterns to consider them equal 
</member>
        <member name="F:barcode.PatternDetector.MAX_INDIVIDUAL_DIFFERENCE">
Maximum allowed difference between individual elements of two patterns
</member>
        <member name="M:mv.MultiplicativePixelConverter.grayScalePixelConverter">
Creates default BGR to grayscale pixel converter.
@return Reference to grayscale pixel converter.

</member>
        <member name="M:barcode.BarcodeRecognizerDelegate.showDrawBuffer">
This is the callback which shows the image that was returned
via method getDrawBuffer.

</member>
        <member name="M:barcode.BarcodeRecognizerDelegate.getDrawBuffer">
in debug mode, gets the draw buffer for scanner to draw
@return pointer to cv::Mat which contains draw buffer

</member>
        <member name="M:barcode.BarcodeRecognizerDelegate.recognitionFinished(barcode.BarcodeData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Recognizer finished recognition with result

</member>
        <member name="M:barcode.BarcodeRecognizerDelegate.recognitionStarted">
Called when the recognizer starts recognition

</member>
        <member name="M:barcode.BarcodeRecognizerDelegate.setDetectedBarcodeModuleSize(System.Single)">
Called after detecting barcode for testing purposes

</member>
        <member name="M:barcode.BarcodeRecognizerDelegate.detectedForm(std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst,barcode.tagBarcodeDetectionStatus!System.Runtime.CompilerServices.IsConst)">
 Called when recognizer detects the payment form.
 Also returns the coordinates of the payment form and the
 size of the image on which the form is detected.

 Coordinates of the payment form are expected to be in order:
  - upper left point
  - upper right point
  - lower right point
  - lower left point

 Also, the detection status is provided

</member>
        <member name="M:barcode.BarcodeRecognizerDelegate.detectionStarted">
Called when the recognizer starts detection

</member>
        <member name="P:Microblink.ZXingRecognitionResult.Elements">
            <summary>
String -&gt; Object map of result elements. 
</summary>
            <remarks> Result data can
be retrieved from this map instead of using the specific
properties in IRecognitionResult implementing classes.
In the instances when specific property is not implemented
the only way of retrieving the data is via this map.
</remarks>
        </member>
        <member name="P:Microblink.ZXingRecognitionResult.Empty">
            <summary>
Indicates if the result is empty
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognitionResult.Valid">
            <summary>
Indicates if the result is valid
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognitionResult.ExtendedRawData">
            <summary>
Raw extended barcode data. 
</summary>
            <remarks>
Available only on barcodes that support extended data encoding (e.g. code39).
</remarks>
        </member>
        <member name="P:Microblink.ZXingRecognitionResult.RawData">
            <summary>
Raw barcode data.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognitionResult.ExtendedStringData">
            <summary>
String representation of extended data.         
</summary>
            <remarks>
Available only on barcodes that support extended data encoding (e.g. code39).
</remarks>
        </member>
        <member name="P:Microblink.ZXingRecognitionResult.StringData">
            <summary>
String representation of data inside barcode.
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognitionResult.BarcodeTypeString">
            <summary>
Type of barcode scanned with ZXing recognizer as string. 
</summary>
        </member>
        <member name="P:Microblink.ZXingRecognitionResult.BarcodeType">
            <summary>
Type of barcode scanned with ZXing recognizer. 
</summary>
        </member>
        <member name="T:Microblink.ZXingRecognitionResult">
            <summary>
ZXing recognition result
</summary>
        </member>
        <member name="T:PlatformStringUtils">
 \file

 PlatformStringUtils.hpp

  Created on: Jan, 2014
      Author: Ljudevit

 Copyright (c)2014 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


 \file

 RCRecognitionData.hpp

  Created on: Jan, 2014
      Author: Ljudevit

 Copyright (c)2014 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 PlatformStringUtils.hpp

  Created on: Jan, 2014
      Author: Ljudevit

 Copyright (c)2014 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

</member>
        <member name="M:photopay.ZXingRecognizer.recognize(photopay.RecognitionContext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
     * Method fills the recognition result object with
     * payment data recognized from given image

     * Returns true if scanning was successful, false otherwise

</member>
        <member name="M:photopay.RecognizerSettings.#ctor(System.Boolean,photopay.RecognizerType)">
Designated constructor 
</member>
        <member name="M:photopay.RecognizerSettings.setEnabled(System.Boolean!System.Runtime.CompilerServices.IsConst)">
Sets recognizer to enabled or not enabled 
</member>
        <member name="M:photopay.RecognizerSettings.isEnabled">
Returns is recognizer enabled or not 
</member>
        <member name="M:photopay.RecognizerSettings.requiresGPUAcceleration">
Returns true if recognizer using this setting requires GPU acceleration for image processing.

</member>
        <member name="M:photopay.RecognizerSettings.requiresOCREngine">
Returns true if recognizer using this setting requires OCR engine to be available.

</member>
        <member name="M:photopay.RecognizerSettings.requiresFrameQualityEstimation">
Returns true if recognizer using this setting requires frame quality analysis to be enabled.

</member>
        <member name="M:photopay.RecognizerSettings.Dispose">
Virtual destructor 
</member>
        <member name="F:RECOGNIZER_TYPE_GENERIC">
Generic recognizer type. 
</member>
        <member name="F:RECOGNIZER_TYPE_PAYBULL">
PayBull recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_OCR_LINE">
Ocr line recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_LIBRARY_INFORMATION">
Library information recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_OCR_QUALITY">
OCR quality estimation recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_OCR_ONLY">
OCR only recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_OCR">
Generic OCR recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_MRTD">
Machine readable travel document recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_MATH">
PhotoMath recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_NETHERLANDS_SLIP">
Dutch slip recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_KOSOVO_SLIP">
Kosovo slip recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_HUNGARY_SLIP">
Hungarian slip recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_GERMANY_SLIP">
German slip recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_UK_DRIVER_LICENSE">
UK Driver License recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_UK_SLIP">
UK slip recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_SWITZERLAND_SLIP">
Swiss slip recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_SLOVENIA_SLIP">
Slovenian slip recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_CROATIA_SLIP">
Croatian slip recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_BELGIUM_SLIP">
Belgian slip recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_AUSTRIA_SLIP">
Austrian slip recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_BARCODE">
Custom 1D barcode recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_ZXING">
ZXing recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_USDL">
US Drivers's Licence recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_UK_QR_CODE">
UK QR code recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_PDF417">
PDF417 recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_KOSOVO_CODE128">
Kosovo code128 barcode recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_GERMANY_QR_CODE">
German QR code recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_CROATIA_QR_CODE">
Croatian barcode data code recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_CROATIA_PDF417">
Croatian barcode data PDF417 recognizer 
</member>
        <member name="F:RECOGNIZER_TYPE_AUSTRIA_QR_CODE">
Austrian QR code recognizer 
</member>
        <member name="M:barcode.Readers.toString">
Serializes the settings to string for easy logging 
</member>
        <member name="M:photopay.PaymentRecognizerDelegate.sortPoints(std.vector&lt;cv.Point_&lt;System.Single&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Point_&lt;System.Single&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method sorts the given points in clockwise order starting from upperleft

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.publishProgress(System.Int32)">
 Publishes progress of ocr engine

 @param progress progress in range [0, 100]

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.willOcrImage(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method which reports the image which will be OCR-ed

 @param image which will be sent to segmentation and classification in the OCR process

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.recognitionShouldStop">
Returns true if the caller wants recognition to stop as soon as possible

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.reportFailedDetection">
Method should report back to UI if the whole chain failed
to detect anything.

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.resetFailedDetection">
Method resets the failed detection flag to true, i.e. it appears
as if detection was failed.

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.Dispose">
Destructor

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.#ctor">
Default constructor

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.showOcrResult(ocr.OcrResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
This method is used to show OCR result in UI.

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.showDewarpedElement(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ocr.OcrResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
This is the callback with dewarped element image and ocr result on this
image. This method is called by recognizers that perform multiple dewarpings.
In release mode, this method should not do anything, and in debug mode
it should save or show given image.
@param dewarpedElement Image of the dewarped element.
@param ocrResult OCR result on given image.
@param elementName Name of the dewarped element.

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.setNewDrawBuffer(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Use this callback to create new draw buffer based on given
image. This is for cases when draw buffer is not standard
frame input. This is also used in MasterRecognizer to set default
draw buffer.

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.showDrawBuffer(screenOrientation.ScreenOrientation!System.Runtime.CompilerServices.IsConst)">
This is the callback which shows the image that was returned
via method getDrawBuffer.

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.showCameraFrame(mv.ICameraFrame*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,photopay.ShowImageType._ImageType!System.Runtime.CompilerServices.IsConst,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This is the callback that shows camera frame
@param imCache

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.showImage(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,photopay.ShowImageType._ImageType!System.Runtime.CompilerServices.IsConst,screenOrientation.ScreenOrientation!System.Runtime.CompilerServices.IsConst,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This is the callback which shows arbitrary image during recognition process.
Image type is passed so that callee can decide whether to save image or not.

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.getTransformToScreen(cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
 Transforms the dewarped location of the object to the location of the object on screen.

  @param imageSize        size of the video frame
  @param imageLocation    location of the object on image
  @param dewarpedLocation location of the object in dewarped coordinates.

  @return cv::Mat with perspective transform from dewarped location to screen location

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.isImageShowingAvailable">
@return true if calling showImage will do something

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.getDrawBuffer">
in debug mode, gets the draw buffer for scanner to draw
@return pointer to cv::Mat which contains draw buffer

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.isDrawBufferAvailable">
@return true if draw buffer is available, otherwise false

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.recognitionFinished(photopay.RecognitionData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Recognizer finished recognition with result

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.recognitionStarted">
Called when the recognizer starts recognition

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.detectedForm(std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst,photopay.tagDetectionStatus!System.Runtime.CompilerServices.IsConst)">
 Called when recognizer detects the payment form.
 Also returns the coordinates of the payment form and the
 size of the image on which the form is detected.

 Coordinates of the payment form are expected to be in order:
  - upper left point
  - upper right point
  - lower left point
  - lower right point

 Also, the detection status is provided

</member>
        <member name="M:photopay.PaymentRecognizerDelegate.detectionStarted">
Called when the recognizer starts detection

</member>
        <member name="T:photopay.PaymentRecognizerDelegate">
Abstract delegate object which is responsible for recognition notifications
Appropriate callback functions are called on events:
	- recognizer started recognition
	- recognizer detected a payment form
	- recognizer finished with result

</member>
        <member name="T:photopay.ShowImageType">
Enumeration of image types which are in delegate

</member>
        <member name="F:photopay.PaymentRecognizer.successor_">
Next recognizer in chain 

</member>
        <member name="M:photopay.PaymentRecognizer.chainReturn(photopay.RecognitionContext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ref&lt;photopay.RecognitionData&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 @brief chainReturn
 A method for proper returning from Payment recognizers

 @return true if chain resulted with a successful recognition, false otherwise

</member>
        <member name="M:photopay.PaymentRecognizer.resetResults">
Resets the best results in the whole chain

</member>
        <member name="M:photopay.PaymentRecognizer.updateSettings(Ref&lt;photopay.RecognizerSettings&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@param settings

</member>
        <member name="M:photopay.PaymentRecognizer.recognize(photopay.RecognitionContext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
     * Method fills the recognition result object with
     * payment data recognized from given image

     * Returns true if scanning was successful, false otherwise

</member>
        <member name="M:photopay.PaymentRecognizer.Dispose">
Destructor

</member>
        <member name="M:photopay.PaymentRecognizer.#ctor">
Constructor

</member>
        <member name="F:photopay.PaymentRecognizer.bestResult_">
Result with hightest confidence shared between recognitions

</member>
        <member name="T:photopay.PaymentRecognizer">
Abstract Payment Recognizer

</member>
        <member name="F:photopay.RecognitionContext.shouldStopOnFirstSuccess_">
If true, first recognizer in chain that performs successful recognition will stop the recognition chain 
</member>
        <member name="F:photopay.RecognitionContext.delegate_">
Current recognizer delegate for reporting callbacks 
</member>
        <member name="F:photopay.RecognitionContext.results_">
Current results in recognition chain 
</member>
        <member name="F:photopay.RecognitionContext.cameraFrame_">
Current frame in recognition. RecognitionContext does not own camera frame. 
</member>
        <member name="M:photopay.RecognitionContext.setStopOnFirstSuccess(System.Boolean)">
@brief setStopOnFirstSuccess Sets whether first recognizer that successfully recognizes the frame should break the recognition chain
@param shouldStopOnFirstSuccess whether first recognizer that successfully recognizes the frame should break the recognition chain

</member>
        <member name="M:photopay.RecognitionContext.shouldStopOnFirstSuccess">
@brief shouldStopOnFirstSuccess Returns true if first recognizer that successfully recognizes the frame should break the recognition chain.
@return Returns true if first recognizer that successfully recognizes the frame should break the recognition chain.

</member>
        <member name="M:photopay.RecognitionContext.setDelegate(photopay.PaymentRecognizerDelegate*)">
@brief setDelegate Sets the pointer to recognizer delegate. Ownership is not acquired.
@param delegate recognizer delegate

</member>
        <member name="M:photopay.RecognitionContext.getDelegate">
@brief getDelegate Returns the pointer to recognizer delegate (if exists)
@return the pointer to recognizer delegate (if exists)

</member>
        <member name="M:photopay.RecognitionContext.getResults">
@brief getResults Returns the reference to current vector of recognition results
@return the reference to current vector of recognition results

</member>
        <member name="M:photopay.RecognitionContext.setCameraFrame(mv.ICameraFrame*)">
@brief setCameraFrame Sets the frame to be recognized. Ownership is not acquired.
@param cameraFrame camera frame to be recognized

</member>
        <member name="M:photopay.RecognitionContext.getCameraFrame">
@brief getCameraFrame Returns current frame in recognition.
@return current frame in recognition.

</member>
        <member name="M:ocr.OcrEngineOptions.setMaxCharAlternatives(System.Int32)">
Sets the maximum number of alternatives that can be produced for
each OcrChar. Default is 0. Allowing more alternatives gives you
ability for more detailed OCR result processing, at a cost of performance.
@param maxCharAlternatives maximum number of alternatives that can be produced for each OcrChar.

</member>
        <member name="M:ocr.OcrEngineOptions.getMaxCharAlternatives">
Returns the maximum number of alternatives that can be produced for
each OcrChar. Default is 0.
@return maximum number of alternatives that can be produces for each OcrChar.

</member>
        <member name="M:photopay.PaymentDetector.getRoi">
 Return the ROI

  @return region of interest

</member>
        <member name="M:photopay.PaymentDetector.setRoi(cv.Rect_&lt;System.Single&gt;)">
 Set the roi

  @param roi region of interest in which the MRTD is scanned

</member>
        <member name="M:photopay.PaymentDetector.resetState">
If any detector state exists (counting of failed detections) or similar,
this method resets it.

</member>
        <member name="M:photopay.PaymentDetector.getPixelConverters">
@return All pixel converters used in this detector.

</member>
        <member name="M:photopay.PaymentDetector.ocrBoxToCvRect(ocr.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Convenience method for format conversions

</member>
        <member name="M:photopay.PaymentDetector.calcDewarpedElementsLocations(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,std.vector&lt;cv.Rect_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method calculates the dewarped coordinates of decoding elements

 @param dewarpedLocation
 @param resultCode
 @param dewarpedElementLocations

</member>
        <member name="M:photopay.PaymentDetector.calcDewarpedLocations(std.vector&lt;mv.Quadrangle&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,std.vector&lt;mv.Quadrangle&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method calculates the dewarped coordinates of all dewarped areas
@param decodingLocations
@param resultCode
@param dewarpedLocations

</member>
        <member name="M:photopay.PaymentDetector.calcDewarpedLocation(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,mv.Quadrangle*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method calculates the dewarped coordinates of the dewarped area

 @param detectionLocation
 @param dewarpedLocation

</member>
        <member name="M:photopay.PaymentDetector.calcDecodingLocations(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,std.vector&lt;mv.Quadrangle&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method calculates all locations of the decoding areas on the image
@param detectionLocation
@param resultCode
@param decodingLocations

</member>
        <member name="M:photopay.PaymentDetector.calcDecodingLocation(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,mv.Quadrangle*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method calculates the location of the decoding area on the image

 @param detectionLocation
 @param resultCode
 @param decodingLocation

</member>
        <member name="M:photopay.PaymentDetector.calcDisplayLocation(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,mv.Quadrangle*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method calculates the location of the form which will be displayed

 @param detectionLocation
 @param displayLocation

</member>
        <member name="M:photopay.PaymentDetector.calcDetectionStatus(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst)">
Method calculates the detection status for a given detection location
@param detectionLocation
@param resultCode
@return

</member>
        <member name="M:photopay.PaymentDetector.detectPaymentFormLocation(mv.ICameraFrame*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,mv.Quadrangle*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*)">
 Method finds the payment form on the given image and returns the result code

 @param frame camera's frame
 @param detectionLocation Detection result will be saved in this variable.
 @param drawBuffer If not NULL, this buffer will be used for debugging of
        scanners.
 @return detection result code as defined in each specific detector

</member>
        <member name="M:photopay.PaymentDetector.Dispose">
Destructor

</member>
        <member name="M:photopay.PaymentDetector.#ctor">
Constructor

</member>
        <member name="F:photopay.PaymentDetector.RESULT_CODE_DETECTION_FAILED">
Indicates detector failed to find austrian form 
</member>
        <member name="T:photopay.PaymentDetector">
 Class responsible for detection of payment forms.
 Each recognizer has a companion detector for finding location of the payment form.

 This object is responsible for determining:
  - Location of payment form on the image
  - Detections status
  - Location of payment form which will be presented on the screen
  - Location of the area which will be decoded
  - Location of payment form in dewarped perspective
  - Locations of payment form elements which need decoding in dewarped perspective

</member>
        <member name="T:photopay.tagDetectionStatus">
Detection status enum

</member>
        <member name="M:mv.PixelConverter.hashValue">
Method calculates and returns the unique hash value of the converter
that can be used for comparison of different pixel converters.
@return

</member>
        <member name="M:mv.PixelConverter.isUsingContrastStrech">
Used by white balance analyzer to check if current pixelConverter
should also perform contrast stretch.
@return

</member>
        <member name="M:mv.PixelConverter.getPcType">
Method return the type of the converter.
@return

</member>
        <member name="M:mv.PixelConverter.getOriginalOffset(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method returns original offset (float version) of the converter
(not modified by the white balance analyzer).
@param offset

</member>
        <member name="M:mv.PixelConverter.getOriginalFloatFactors(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method returns original factors (float version) of the converter (those factors
are not modified by the white balance analyzer).
@param redFactor
@param greenFactor
@param blueFactor

</member>
        <member name="M:mv.PixelConverter.getOriginaOffset(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method returns original offset of the converter
(not modified by the white balance analyzer).
@param offset

</member>
        <member name="M:mv.PixelConverter.getOriginalFactors(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method returns original factors of the converter (those factors
are not modified by the white balance analyzer).
@param redFactor
@param greenFactor
@param blueFactor

</member>
        <member name="M:mv.PixelConverter.getFloatOffset(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method returns current offset (float version) of the converter
(might be changed by the white balance analyzer)
@param offset

</member>
        <member name="M:mv.PixelConverter.getFloatFactors(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method returns current factors (float version) of the converter (those factors
might be modified by the white balance analyzer).
@param redFactor
@param greenFactor
@param blueFactor

</member>
        <member name="M:mv.PixelConverter.getOffset">
Method returns current offset of the converter (might be changed
by the white balance analyzer).

</member>
        <member name="M:mv.PixelConverter.getOffset(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method returns current offset of the converter (might be changed
by the white balance analyzer).
@param offset

</member>
        <member name="M:mv.PixelConverter.getFactors(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method returns current factors of the converter (those factors
might be modified by the white balance analyzer).
@param redFactor
@param greenFactor
@param blueFactor

</member>
        <member name="M:mv.PixelConverter.convertPixel(cv.Vec&lt;System.Byte,0x4&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method converts color pixel to gray
@param pixel
@return

</member>
        <member name="M:mv.PixelConverter.convertPixel(cv.Vec&lt;System.Byte,0x3&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method converts color pixel to gray
@param pixel
@return

</member>
        <member name="M:mv.PixelConverter.setNewFloatOffset(System.Int32!System.Runtime.CompilerServices.IsConst)">
Method sets new offset (float version) of the converter. This method is used
by white balance analyzers to update factors according to
white balance of the frame.
@param offset

</member>
        <member name="M:mv.PixelConverter.setNewFloatFactors(System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)">
Method sets new factors (float version) of the converter. This method is used
by white balance analyzers to update factors according to
white balance of the frame.
@param rFact
@param gFact
@param bFact

</member>
        <member name="M:mv.PixelConverter.setNewOffset(System.Int32!System.Runtime.CompilerServices.IsConst)">
Method sets new offset of the converter. This method is used
by white balance analyzers to update factors according to
white balance of the frame.
@param offset

</member>
        <member name="M:mv.PixelConverter.setNewFactors(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)">
Method sets new factors of the converter. This method is used
by white balance analyzers to update factors according to
white balance of the frame.
@param rFact
@param gFact
@param bFact

</member>
        <member name="M:mv.PixelConverter.makeCopy">
Method make an almost exact copy of current object.
'Almost exact' means that frame dependend data (such as
AWB modified factors) are not copied.
@return

</member>
        <member name="M:mv.PixelConverter.convertPixel(System.Int32,System.Int32,System.Int32)">
Method converts color pixel to gray
@param r
@param g
@param b
@return

</member>
        <member name="M:mv.GammaCorrection.sRGBgammaCompression(System.Int32)">
method compresses gamma value of given pixel intensity according to
sRGB gamma compression definition {@link http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale}
This is required for compressing RGB colorspace
@param val pixel intensity
@return compressed pixel intensity

</member>
        <member name="M:mv.GammaCorrection.sRGBgammaExpansion(System.Int32)">
method expands gamma value of given pixel intensity according to
sRGB gamma expansion definition {@link http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale}
This is required for linearizing RGB colorspace
@param val pixel intensity
@return expanded pixel intesity

</member>
        <member name="M:mv.ICameraFrame.getFrameOrientation">
Returns the orientation of the device when frame was captured.

</member>
        <member name="M:mv.ICameraFrame.isDeviceMoving">
Returns true if device was in motion when this frame was captured. It is possible even for photo frames (isPhotoFrame returns true)
to be captured in motion.

</member>
        <member name="M:mv.ICameraFrame.isCameraFocused">
Returns true if camera was focused when frame was captured. Note that this can be different from result of
isFocused which is based on multiple parameters.

</member>
        <member name="M:mv.ICameraFrame.isFocused">
Returns true if frame thinks it is focused, i.e. sharp enough for recognition. Note that this is frame's own opinion -
recognizers can obtain frame quality with method getFrameQuality to implement their own heuristics for determining
if frame is really good enough for processing.
Also note that this method might trigger a frame quality estimation analysis.

</member>
        <member name="M:mv.ICameraFrame.getFrameQualityEstimator">
Returns the frame quality estimator that is used for quality estimation of this frame. Returns NULL if no frame quality
estimator is associated with this frame.

</member>
        <member name="M:mv.ICameraFrame.getWhiteBalanceAnalysisResult">
Returns the result of white balance analysis, calculating it if necessary. If no white balance analyser exists for this frame,
calculation will fail and this method will return NULL.

</member>
        <member name="M:mv.ICameraFrame.getWhiteBalanceAnalyzer">
Returns white balance analyzer used for analyzing this frame. Returns NULL if no white balance analyzer is associated
with this frame.

</member>
        <member name="M:mv.ICameraFrame.isOriginalFrameYUV">
Returns true if the originally set frame was in YUV format.

</member>
        <member name="M:mv.ICameraFrame.isPhotoFrame">
Returns true if the frame is actually a photograph and not a video frame (regardless of its resolution).
Recognition of photographs will not utilize time redundancy.

</member>
        <member name="M:mv.ICameraFrame.getArbitraryImage(mv.PixelConverter!System.Runtime.CompilerServices.IsConst*,mv.RGBFactors!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves the reference to arbitrary image created with given pixel converter, creating it if necessary.
If pixConv is NULL, returns the same output as getAwbBgrImage.

</member>
        <member name="M:mv.ICameraFrame.getAwbBgrOrBgraImage(mv.RGBFactors!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves the reference to white balance adjusted BGR or BGRA image, creating it if necessary.

</member>
        <member name="M:mv.ICameraFrame.getInvertedGrayscaleImage">
Retrieves the reference to inverted grayscale image, creating it if necessary.

</member>
        <member name="M:mv.ICameraFrame.getGrayscaleImage">
Retrieves the reference to grayscale image, creating it if necessary.

</member>
        <member name="M:mv.ICameraFrame.getBgrOrBgraImage">
Retrieves the reference to BGR or BGRA image (whichever is available).
If neither is available, creates and returns BGRA image.

</member>
        <member name="M:mv.ICameraFrame.getBgraImage">
Retrieves the reference to BGRA image, creating it if necessary.

</member>
        <member name="M:mv.ICameraFrame.getBgrImage">
Retrieves the reference to BGR image, creating it if necessary.

</member>
        <member name="M:mv.ICameraFrame.getOriginalFrameSize">
Returns the original size of the frame

</member>
        <member name="M:mv.ICameraFrame.getFrameSize">
Returns the size of the frame

</member>
        <member name="F:SCREEN_ORIENTATION_COUNT">
Number of available screen orientations. This must be last enum entry 
</member>
        <member name="F:SCREEN_ORIENTATION_LANDSCAPE_LEFT">
Screen orientation is in left landscape mode (home button is left of screen) 
</member>
        <member name="F:SCREEN_ORIENTATION_PORTRAIT_UPSIDE">
Screen orientation is in reverse portrait mode (home button is above screen) 
</member>
        <member name="F:SCREEN_ORIENTATION_LANDSCAPE_RIGHT">
Screen orientation is in right landscape mode (home button is right of screen) 
</member>
        <member name="F:SCREEN_ORIENTATION_PORTRAIT">
Screen orientation is in portrait mode (home button is below screen) 
</member>
        <member name="M:mv.Quadrangle.toString">
 Returns string representation of the Quadrangle

  @return string representation of the Quadrangle

</member>
        <member name="M:mv.Quadrangle.toRect">
Method returns an OpenCV rectangle from this quandrangle
Method loses some accuracy since quadrangle isn't neccesarily aligned to the axes.

</member>
        <member name="M:mv.Quadrangle.toVector">
 Method returns the vector of points the points to vector

 @param points

</member>
        <member name="M:mv.Quadrangle.toIntArray(System.Int32*)">
 Method pushes the points to int array in form (x_ul, y_ul, x_ur, y_ur, x_lr, y_lr, x_ll, y_ll).

 @param points

</member>
        <member name="M:mv.Quadrangle.toFloatArray(System.Single*)">
 Method pushes the points to float array in form (x_ul, y_ul, x_ur, y_ur, x_lr, y_lr, x_ll, y_ll).

 @param points

</member>
        <member name="M:mv.Quadrangle.toVector(std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method pushes the points to vector

 @param points

</member>
        <member name="M:mv.Quadrangle.getWarpedRectangle(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method warps the perspective of the current quadrangle and creates a new warped quadrangle

 @param transformationMatrix
 @return

</member>
        <member name="M:mv.Quadrangle.getAffineTransform(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the affine transform which transform this to other quadrangle

</member>
        <member name="M:mv.Quadrangle.getPerspectiveTransform(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the perspective transform which transform this to other quadrangle

</member>
        <member name="M:mv.Quadrangle.draw(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Scalar_&lt;System.Double&gt;)">
 Method draws the quadrangle on the given image

 @param image
 @param color

</member>
        <member name="M:mv.Quadrangle.getBoundingRectangle">
Method created a new rectangle which encloses this quadrangle.

</member>
        <member name="M:mv.Quadrangle.scaleBy(System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)">
Meothd creates a new quadrangle which is a scaled version of this quadrangle.

</member>
        <member name="M:mv.Quadrangle.interpolateTo(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
Method creates a new quadrangle which is an interpolation between this and given other quadrangle
Interpolation depends on the given interpolation factor
 If 1, resulting quadrangle will be equal to other quadrangle
 If 0 or smaller, resulting quandrangle will be equal to this quadrangle
 If other value, linear interpolation will be performed to obtain result

</member>
        <member name="M:mv.Quadrangle.getVerticalRectangle(System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
 Calculates the rectangle that has the same left and right bounding lines,
 but upper and lower border positiones are given with relative positions to current rectangle

 @param upperPos
 @param lowerPos
 @return

</member>
        <member name="M:mv.Quadrangle.getHorizontalRectangle(System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
 Calculates the rectangle that has the same upper and lower bounding lines,
 but left and right border positiones are given with relative positions to current rectangle

 @param leftPos
 @param rightPos
 @return

</member>
        <member name="M:mv.Quadrangle.getSpreadedRectangle(System.Double!System.Runtime.CompilerServices.IsConst)">
 Spreads the corner points of the rectangle by a certain percentage

 @param spreadRatio
 @return

</member>
        <member name="M:mv.Quadrangle.isPointInside(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Returns true if point is inside this quadrangle

  @param point point for which we perform the test

  @return true if point is inside this quadrangle

</member>
        <member name="M:mv.Quadrangle.getSkewMeasure">
Returns the skew measure of the quadrangle on scale [0, 1].
If the quadrangle is skewed or warped, this measure will be close to 1.
If the quadrangle has 90 degrees angles, the measure will be 0

</member>
        <member name="M:mv.Quadrangle.getWidthToHeightRatio">
Returns the width to height aspect ratio
@return aspect ratio

</member>
        <member name="M:mv.Quadrangle.getWidth">
Returns the average width of the quadrangle
@return width

</member>
        <member name="M:mv.Quadrangle.getHeight">
Returns the average height of the quadrangle
@return height

</member>
        <member name="M:mv.Quadrangle.getHorizontalLine">
 Returns the horizontal line - line connecting centers of left and right quadrangle sides

  @return horizontal line

</member>
        <member name="M:mv.Quadrangle.getArea">
Returns the area of the quadrangle
@return area

</member>
        <member name="M:mv.Quadrangle.getCenter">
Returns the center of the quadrangle
@return

</member>
        <member name="M:mv.Quadrangle.getUpperRight">
 Upper right getter

 @return

</member>
        <member name="M:mv.Quadrangle.getUpperLeft">
 Upper left getter

 @return

</member>
        <member name="M:mv.Quadrangle.getLowerRight">
 Lower right getter

 @return

</member>
        <member name="M:mv.Quadrangle.getLowerLeft">
 Lower left getter

 @return

</member>
        <member name="M:mv.Quadrangle.op_AdditionAssignment(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator +=

</member>
        <member name="M:mv.Quadrangle.Dispose">
Destructor

</member>
        <member name="M:mv.Quadrangle.op_Assign(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Assignment operator

 @param other
 @return

</member>
        <member name="M:mv.Quadrangle.#ctor(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Copy constructor

 @param other

</member>
        <member name="M:mv.Quadrangle.#ctor(cv.Rect_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor for OpenCV rectangle

</member>
        <member name="M:mv.Quadrangle.#ctor(std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor for vector

</member>
        <member name="M:mv.Quadrangle.#ctor(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor

</member>
        <member name="T:mv.Quadrangle">
Quadrangle class

</member>
        <member name="M:mv.LineSegment.divide(System.Double!System.Runtime.CompilerServices.IsConst)">
Division function. Required for calculating mean in K-means algorithm.
@param number
@return

</member>
        <member name="M:mv.LineSegment.add(Ref&lt;mv.Sample&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Addition function. Required for calculating mean in K-means algorithm.
@param other

</member>
        <member name="M:mv.LineSegment.clone">
make a clone of itself
@return

</member>
        <member name="M:mv.LineSegment.squaredDistanceToPointInt(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates squared distance to point in integer arithmetics

</member>
        <member name="M:mv.LineSegment.squaredDistanceToPoint(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates squared distance to point

</member>
        <member name="M:mv.LineSegment.distanceToLineSegment(mv.LineSegment!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Distance function to other segment

</member>
        <member name="M:mv.LineSegment.distance(mv.Sample!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Distance function

</member>
        <member name="M:mv.LineSegment.log(System.Int32)">
Logs the line segment to stdout

</member>
        <member name="M:mv.LineSegment.drawLine(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method draws the line on the image and sets the errorstatus flag

 @param image

</member>
        <member name="M:mv.LineSegment.invertDirection">
Inverts the direction of the line;

</member>
        <member name="M:mv.LineSegment.length">
Returns the length of the line segment

</member>
        <member name="M:mv.LineSegment.getPointAtLocation(System.Double)">
Returns the point at specified location on the line.
Param represents:
	0 - startPoint of the line
	1 - endPoint of the line

</member>
        <member name="M:mv.LineSegment.getEndPoint">
 Returns the end point of the segment

 @return

</member>
        <member name="M:mv.LineSegment.op_Assign(mv.LineSegment!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Assignment operator

 @param other
 @return

</member>
        <member name="M:mv.LineSegment.#ctor(mv.LineSegment!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Copy constructor

 @param other

</member>
        <member name="M:mv.LineSegment.Dispose">
Virtual destructor

</member>
        <member name="M:mv.LineSegment.#ctor(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor which takes two points

</member>
        <member name="F:mv.LineSegment.endPoint_">
Line end point

</member>
        <member name="M:mv.Line.drawModel(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Draws the model with initialization values and inliers
 For debugging purposes

 @param image
 @param initValues
 @param inliers
 @param color

</member>
        <member name="M:mv.Line.calculateModelError(std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Evaluation of model based on observed values

 @param model
 @param values
 @return error cost of the model calculated on given values

</member>
        <member name="M:mv.Line.distanceToValue(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
RansacModel methods 
 Method returns the distance from a value to the model

 @param value
 @return

</member>
        <member name="M:mv.Line.log(System.Int32)">
Logs the line to stdout

</member>
        <member name="M:mv.Line.invertDirection">
Inverts the direction of the line

</member>
        <member name="M:mv.Line.getProjectedPoint(cv.Point_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method calculates projection of given point to line and returns it.

</member>
        <member name="M:mv.Line.getPerpendicularLineThroughPoint(cv.Point_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method calculates and returns the perpendicular line through given point

</member>
        <member name="M:mv.Line.getPerpendicularVector">
 Method calculates and returnes the vector perpendicular to line direction

 @return

</member>
        <member name="M:mv.Line.findIntersectionWithImage(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,mv.LineSegment*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Finds the intersection with image rectangle

 @param image
 @param status
 @return

</member>
        <member name="M:mv.Line.findIntersectionWithRect(cv.Rect_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,mv.LineSegment*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method returns the line segment intersection of line and rectangle

 @param rect
 @param segment
 @param status
 @return

</member>
        <member name="M:mv.Line.drawLine(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Scalar_&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method draws the line on the image and sets the errorstatus flag

 @param image

</member>
        <member name="M:mv.Line.isPointCollinear(cv.Point_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst)">
 Checks if the point is collinear to line

 @param testPoint
 @param distanceThreshold
 @return

</member>
        <member name="M:mv.Line.isPointCollinear(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
 Checks if the point is collinear to line

 @param testPoint
 @param distanceThreshold
 @return

</member>
        <member name="M:mv.Line.getCosAngle(mv.Line!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method calculates the cosine of the angle between this and other line
@return cosine of the angle

</member>
        <member name="M:mv.Line.squaredDistanceToPoint2f(cv.Point_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates squared distance to point

</member>
        <member name="M:mv.Line.squaredDistanceToPoint(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates squared distance to point

</member>
        <member name="M:mv.Line.distanceToPoint(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the distance to point

</member>
        <member name="M:mv.Line.getDirection">
Direction getter
@return

</member>
        <member name="M:mv.Line.getStartPoint">
End Point getter

</member>
        <member name="M:mv.Line.Dispose">
Destructor

</member>
        <member name="M:mv.Line.op_Assign(mv.Line!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator

</member>
        <member name="M:mv.Line.#ctor(mv.Line!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor

</member>
        <member name="M:mv.Line.#ctor(std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
 Constructor that fits the line to the points

 @param points
 @params strategy
 	- strategy used for line creating. Default is 0. Values mean:
 		: 0 - least squares method
 		: 1 - RANSAC method

</member>
        <member name="M:mv.Line.#ctor(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,mv.Direction!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor which takes point and direction

</member>
        <member name="M:mv.Line.#ctor(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor which takes two points

</member>
        <member name="F:mv.Line.direction_">
Direction vector

</member>
        <member name="F:mv.Line.startPoint_">
Start point of the line

</member>
        <member name="T:mv.Line">
Line object

</member>
        <member name="T:mv.Direction">
Class for efficient line direction representation

</member>
        <member name="M:mv.Geometry.computeRotationMatrix(System.Single!System.Runtime.CompilerServices.IsConst,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Generates rotation matrix which remapping coordinates from original coordinate system
 (original image) to rotated system (image where text is in horizontal position).
 Rotation is performed around the image top left corner.

 @param angle - dominant direction of image elements on original image
 @param rotationMatrix - computed rotation matrix

</member>
        <member name="M:mv.Geometry.distance(cv.Point_&lt;System.Int32&gt;,cv.Point_&lt;System.Int32&gt;)">
Returns the distance between two points in double precision

</member>
        <member name="M:mv.Geometry.spreadCornerPoints(std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
DEPRECATED METHODS STILL USED FOR BARCODE 
 Function adds the offset to detected points

 TODO:
 	Method has a flaw because it uses flawed findCornerCoordinates

</member>
        <member name="M:mv.Geometry.findStartPointForDirection(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Vec&lt;System.Single,0x2&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method finds start point for line with direction

 @deprecated
	Use class Line and it's methods

</member>
        <member name="M:mv.Geometry.findStartPoint(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Finds end points of the line on the image

 @deprecated
 	Use class Line and it's methods

</member>
        <member name="M:mv.Geometry.checkColinearity(cv.Vec&lt;System.Single,0x2&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Vec&lt;System.Single,0x2&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Vec&lt;System.Single,0x2&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 @param startPoint
 @param pdirection
 @param point
 @return

 @deprecated
 	Use class Line and it's methods

</member>
        <member name="M:mv.Geometry.checkColinearity(cv.Vec&lt;System.Single,0x2&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Vec&lt;System.Single,0x2&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 @param startPoint
 @param pdirection
 @param point
 @return

 @deprecated
 	Use class Line and it's methods

</member>
        <member name="M:mv.Geometry.zoomImage(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Returns the zoomed image

</member>
        <member name="M:mv.Geometry.calculateCentroid(std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the centroid of all points in the vector

</member>
        <member name="M:mv.Geometry.getBoundingBoxPoints(std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Method calculates rectangle that is a bounding box of given points
in image of size imageSize. Corner points of that bounding box is
returned via boundingBoxPoints parameter. Bounding box can be expanded
up to expand pixels in each direction.
@param points Source quadrangle (detected form points)
@param imageSize Size of image
@param boundingBoxPoints Returned bounding box quadrangle
@param expand How much should bounding box be expanded.

</member>
        <member name="M:mv.Geometry.crop(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.Point_&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Simple crop of the part of the image surrounding the given points.
Resulting image is a bounding box arount the points

</member>
        <member name="M:mv.Geometry.saturatePoint(cv.Point_&lt;System.Int32&gt;,cv.Point_&lt;System.Int32&gt;,cv.Point_&lt;System.Int32&gt;)">
Saturates point and clamps its coordinates between minPoint and maxPoint

</member>
        <member name="M:mv.Geometry.isPointInside(cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Returns true if the point a is inside rectangle of size [0, 0], [size.x, size.y]

 @deprecated
 	Use class cv::Rect

</member>
        <member name="M:mv.Geometry.roundPoint(cv.Point_&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Rounds the point to integer values
@param pointf
@return

</member>
        <member name="M:mv.Geometry.Dispose">
Private destructor

</member>
        <member name="M:mv.Geometry.#ctor">
Private constructor to prevent instantiation

</member>
        <member name="T:mv.Geometry">
Static class with geometry related methods

</member>
        <member name="M:invSqrt(System.Single)">
method calculates 1/sqrt(x)
taken from: http://www.beyond3d.com/content/articles/8/

</member>
        <member name="F:DeviceInfo.data_">
other data about device 
</member>
        <member name="F:DeviceInfo.maxCPUFrequency_">
Maximum CPU frequency in MHz of processor 0 
</member>
        <member name="F:DeviceInfo.numberOfProcessors_">
How many processors does the device have? 
</member>
        <member name="F:DeviceInfo.isHQ_">
Is device of high quality? 
</member>
        <member name="F:DeviceInfo.manufacturer_">
Device manufacturer 
</member>
        <member name="F:DeviceInfo.model_">
Device model 
</member>
        <member name="F:DeviceInfo.deviceName_">
Device name 
</member>
        <member name="F:DeviceInfo.osVersion_">
OS version 
</member>
        <member name="F:DeviceInfo.operatingSystem_">
OS name 
</member>
        <member name="F:DeviceInfo.OS_ANDROID">
Available operating systems 
</member>
        <member name="F:DeviceInfo.DEVICE_DEFAULT">
Available devices 
</member>
        <member name="M:DeviceInfo.getDeviceSpeedLevel">
 Returns the speed level of the device

 0 - extra slow device
 6 - very fast device with at least 1100MHz processor or multicore.
 10 - extra fast device

 Other values are determined by number of processors and processor speed.

</member>
        <member name="M:DeviceInfo.setMaxCPUFrequency(System.Int32)">
Sets the maximum frequency in MHz of processor 0.
@param maxFreq maximum frequency of processor 0.

</member>
        <member name="M:DeviceInfo.getMaxCPUFrequency">
Returns the maximum CPU frequency in MHz of processor 0.
@return

</member>
        <member name="M:DeviceInfo.setNumberOfProcessors(System.Int32)">
Sets the number of available processors on device.
@param procNum number of processors available at the moment

</member>
        <member name="M:DeviceInfo.getNumberOfProcessors">
Returns the number of available processors on device.
Not all processors have to be active at the moment.
@return

</member>
        <member name="M:DeviceInfo.isMobileDevice">
Method returns true for mobile devices. For now these are only Android and iOS

</member>
        <member name="M:DeviceInfo.setHQ(System.Boolean)">
Method sets whether device is of high quality.
@param hq True if device is HQ, otherwise false.

</member>
        <member name="M:DeviceInfo.isHQDevice">
Method returns true if device is of high quality.
@return True if device is HQ, false otherwise.

</member>
        <member name="M:DeviceInfo.setManufacturer(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method set the device manufacturer.
@param manufacturer Device manufacturer.

</member>
        <member name="M:DeviceInfo.getManufacturer">
 Method returns the device manufacturer

 @return Device manufacturer

</member>
        <member name="M:DeviceInfo.setModel(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method set the device model.
@param model Device model.

</member>
        <member name="M:DeviceInfo.getModel">
 Method returns the device model

 @return Device model

</member>
        <member name="M:DeviceInfo.setDeviceName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method sets the name of the device.
@param deviceName Device name

</member>
        <member name="M:DeviceInfo.getDeviceName">
 Method returns the name of the device

 @return Device name

</member>
        <member name="M:DeviceInfo.setOsVersion(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method sets the OS version of the device.
@param osVer OS version

</member>
        <member name="M:DeviceInfo.getOsVersion">
 Method returns the OS version of the device

 @return OS version

</member>
        <member name="M:DeviceInfo.setOperatingSystem(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method sets the OS name of the device.
@param os OS name

</member>
        <member name="M:DeviceInfo.getOperatingSystem">
 Method returns the OS name of the device

 @return OS name

</member>
        <member name="M:DeviceInfo.Dispose">
Virtual destructor

</member>
        <member name="M:DeviceInfo.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerService">
 Constructor

 @param operatingSystem Device's operating system (eg. Android)
 @param osVersion Device's operating system version (eg. 4.1)
 @param manufacturer Manufacturer of the device (eg. Samsung)
 @param model Device model
 @param deviceName Device name
 @param isHQ whether or not device has high quality camera (at least HD)
 @param numOfProcessors Number of processors on the device
 @param maxCPUFrequency Maximum CPU frequency in MHz of processor 0

</member>
        <member name="M:DeviceInfo.initializeSharedInstance(DeviceInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Initialize shared instance with values of given device info.
@param deviceInfo Device information that needs to become shared.

</member>
        <member name="M:DeviceInfo.getSharedInstance">
Returns the shared instance of device info
@return Pointer to device info structure

</member>
        <member name="T:DeviceInfo">
Device information holder

</member>
        <member name="M:StringMap.getHashMap">
Returns the native STL hash map that is contained as member. Useful for efficient iteration over keys.
@return the native STL hash map that is contained as member. Useful for efficient iteration over keys.

</member>
        <member name="M:StringMap.readFromJson(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Reads the hashmap from JSON.
@param jsonObj
@param status

</member>
        <member name="M:StringMap.writeToJson(rapidjson.Writer&lt;rapidjson.GenericStringBuffer&lt;rapidjson.UTF8&lt;&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes the hashmap to JSON.
@param writer
@param status

</member>
        <member name="M:StringMap.log(System.Int32)">
Logs the hashmap to log.
@param loglevel

</member>
        <member name="M:StringMap.keyExists(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return whether or not given key exists in map.
@param key Name of the key.
@return true if key exists, otherwise false

</member>
        <member name="M:StringMap.getValueForKey(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the value for given key. If no value is set for given key, returns empty string.
@param key Name of the key
@return Value for the key or "" if nothing is set for key.

</member>
        <member name="M:StringMap.setValueForKey(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the given value to given key.
@param key Name of the key
@param value Value for the key

</member>
        <member name="T:StringMap">
 \file

 DeviceInfo.hpp

  Created on: Oct 31, 2012
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 StringMap.hpp

  Created on: Sep 29, 2013
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


 \file

 StringMap.hpp

  Created on: Sep 29, 2013
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

</member>
        <member name="M:mv.ImageIO.isSupportedFileType(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;)">
Returns true if the file with a given filename is supported by the marker

</member>
        <member name="M:FileUtils.getPlatformPath(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
returns the platform specific path from given unix path
@param unixPath path string in unix form, e.g. c:/windows/system32
@return platform specific path, e.g. on windows: c:\\windows\\system32

</member>
        <member name="T:FileUtils">
 \file

 Ransac.hpp

  Created on: Jul 11, 2012
      Author: cerovec

 \file

 ImageIO.h

  Created on: Feb 11, 2012
      Author: cerovec

 \file

 FileUtils.hpp

  Created on: Oct 29, 2013
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

</member>
        <member name="M:mv.Sample.log(System.Int32)">
Logging method, for convenience

</member>
        <member name="M:mv.Sample.divide(System.Double!System.Runtime.CompilerServices.IsConst)">
Division function. Required for calculating mean in K-means algorithm.
@param number
@return

</member>
        <member name="M:mv.Sample.add(Ref&lt;mv.Sample&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Addition function. Required for calculating mean in K-means algorithm.
@param other

</member>
        <member name="M:mv.Sample.clone">
make a clone of itself
@return

</member>
        <member name="M:mv.Sample.distance(mv.Sample!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Distance function

</member>
        <member name="M:mv.Sample.Dispose">
Destructor

</member>
        <member name="M:mv.Sample.#ctor">
Constructor

</member>
        <member name="T:mv.Sample">
Class representing a sample for clustering

</member>
        <member name="M:ocr.OcrEngineDelegate.publishProgress(System.Int32)">
 Publishes progress of ocr engine

 @param progress progress in range [0, 100]

</member>
        <member name="M:ocr.OcrEngineDelegate.willOcrImage(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method which reports the image which will be OCR-ed

 @param image which will be sent to segmentation and classification in the OCR process

</member>
        <member name="M:ocr.OcrEngineDelegate.recognitionShouldStop">
 Method which determines if ocr process should stop

 @return true if ocr engine should stop, false otherwise

</member>
        <member name="M:ocr.OcrEngineDelegate.Dispose">
Destructor

</member>
        <member name="M:ocr.OcrEngineDelegate.#ctor">
Constructor

</member>
        <member name="T:ocr.OcrEngineDelegate">
Delegate object through which the information about OCR process is returned to caller

</member>
        <member name="M:photopay.RecognitionData.sanitize">
Performs sanitization

</member>
        <member name="M:photopay.RecognitionData.Dispose">
Destructor 
</member>
        <member name="M:photopay.RecognitionData.addExtractionResults(std.vector&lt;photopay.ExtractionResult&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Adds extraction results to history

 @param extractionResults

</member>
        <member name="M:photopay.RecognitionData.clone">
@return clone of self

</member>
        <member name="M:photopay.RecognitionData.op_Assign(photopay.RecognitionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment

</member>
        <member name="M:photopay.RecognitionData.#ctor(photopay.RecognitionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor

</member>
        <member name="M:photopay.RecognitionData.#ctor(photopay.RecognitionDataType,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor that does not take currency 
</member>
        <member name="M:photopay.RecognitionData.#ctor(photopay.RecognitionDataType,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor 
</member>
        <member name="M:photopay.RecognitionData.isValid">
checks if the payment data is valid. If true, payment is ready for execution 
</member>
        <member name="M:photopay.RecognitionData.getElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Generic element getter
@param elementName name of the element
@return element value

</member>
        <member name="M:photopay.RecognitionData.getOcrLineElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Ocr Line data element getter.
@param elementName name of the element
@return element value or nullptr

</member>
        <member name="M:photopay.RecognitionData.getMathElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Math data element getter.
@param elementName name of the element
@return element value or nullptr

</member>
        <member name="M:photopay.RecognitionData.getOcrResultElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
OCR data element getter
@param elementName name of the element
@return element value or nullptr

</member>
        <member name="M:photopay.RecognitionData.getBarcodeDataElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
barcode data element getter
@param elementName name of the element
@return element value or nullptr

</member>
        <member name="M:photopay.RecognitionData.getIntElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
integer element getter
@param elementName name of the element
@param defaultValue default value that will be returned if element does not exist or is not integer
@return element value or default value

</member>
        <member name="M:photopay.RecognitionData.getBoolElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Bool element getter
@param element name of the element
@param defaultValue default value that will be returned if element does not exist or is not a bool
@return  element value or default value

</member>
        <member name="M:photopay.RecognitionData.getStringElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
string element getter
@param elementName name of the element
@param defaultValue default value that will be returned if element does not exist or is not string
@return element value or default value

</member>
        <member name="M:photopay.RecognitionData.elementExists(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if element with given name exists

</member>
        <member name="M:photopay.RecognitionData.getDataType">
Returns the PaymentData type

</member>
        <member name="M:photopay.RecognitionData.#ctor(photopay.RecognitionDataType)">
Constructor used by serializer only - should not be used by derived classes 
</member>
        <member name="M:photopay.RecognitionData.getSanitizer">
Returns the appropriate sanitizer object for this payment data.

</member>
        <member name="F:photopay.RecognitionData.empty_">
flag indicating empty payment data 
</member>
        <member name="F:photopay.RecognitionData.valid_">
flag indicating valid payment data 
</member>
        <member name="F:photopay.RecognitionData.validElements_">
valid elements - all elements that are in this set are considered
                 valid and payment recognizer may decide not to perform
                 additional OCR on these elements

</member>
        <member name="F:photopay.RecognitionData.elements_">
string elements, such as IBAN, BIC, receiver name, ... 
</member>
        <member name="T:photopay.RecognitionData">
Represents information on payment slips. Facade to results of various recognition methods.

</member>
        <member name="F:RECOGNITION_DATA_TYPE_COUNT">
number of entries 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_LIBRARY_INFO">
Information about library and licence 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_ZXING">
ZXing data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_USDL">
US Drivers's Licence data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_UK_QR_CODE">
UK QR code data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_UK_DRIVER_LICENSE">
UK Driver License 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_UK_SLIP">
UK slip data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_SWITZERLAND_SLIP">
Swiss slip data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_SLOVENIA_SLIP">
Slovenian slip data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_MATH">
PhotoMath data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_PAYBULL">
PayBull data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_PDF417">
PDF417 data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_OCR_QUALITY">
Ocr Quality data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_OCR_LINE">
Ocr Line data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_OCR">
Generic OCR data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_NETHERLANDS_SLIP">
Dutch slip data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_MRTD">
Machine readable travel document data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_KOSOVO_CODE128">
Kosovo code128 barcode data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_KOSOVO_SLIP">
Kosovo slip data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_HUNGARY_SLIP">
Hungarian slip data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_GERMANY_QR_CODE">
German QR code data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_GERMANY_SLIP">
German slip data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_CROATIA_QR_CODE">
Croatian barcode data QR code 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_CROATIA_BARCODE">
Croatian barcode data PDF417 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_CROATIA_SLIP">
Croatian slip data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_BELGIUM_SLIP">
Belgian slip data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_BARCODE">
Custom 1D barcode data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_AUSTRIA_QR_CODE">
Austrian QR code data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_AUSTRIA_SLIP">
Austrian slip data 
</member>
        <member name="F:RECOGNITION_DATA_TYPE_GENERIC">
Generic recognition data type. 
</member>
        <member name="F:photopay.RecognitionValue.impl_">
Pimpl object 
</member>
        <member name="M:photopay.RecognitionValue.getOcrLineValue">
Getter for OcrLineRecognitinResult value. If type is not OcrLineRecognitinResult, this method will return undefined value.
 @return a pointer to internal OcrLineRecognitinResult object.

</member>
        <member name="M:photopay.RecognitionValue.getQuadrangleValue">
Getter for quadrangle value. If type is not Quadrangle, this method will return undefined value.
 @return a pointer to internal quadrangle object.

</member>
        <member name="M:photopay.RecognitionValue.getPhotoMathValue">
Getter for PhotoMath data. If type is not PhotoMath, this method will return undefined value.
@return a pointer to internal PhotoMath result structure

</member>
        <member name="M:photopay.RecognitionValue.getOcrValue">
Getter for OCR data. If type is not OCR, this method will return undefined value.
@return a pointer to internal OCR structure

</member>
        <member name="M:photopay.RecognitionValue.getBarcodeValue">
Getter for barcode detailed data. If type is not barcode, this method will return undefined value.
@return a pointer to internal barcode structure

</member>
        <member name="M:photopay.RecognitionValue.getRawStringValue">
Getter for string value.
Returns a pointer to the internal string.
If type is not string, this method will return undefined value.
@return a pointer to the internal string.

</member>
        <member name="M:photopay.RecognitionValue.getStringValue">
Getter for string value.
Returns a copy of the internal string (convenience method)
If type is not string, this method will return undefined value.

</member>
        <member name="M:photopay.RecognitionValue.getIntValue">
Getter for integer value. If type is not integer, this method will return undefined value.
@return integer representation of the value

</member>
        <member name="M:photopay.RecognitionValue.getBoolValue">
Getter for boolean value. If type is not boolean, this method will return undefined value.
@return boolean representation of the value;

</member>
        <member name="M:photopay.RecognitionValue.toString">
Returns the string representation of value. For logging 
</member>
        <member name="M:photopay.RecognitionValue.getType">
Getter for type 
</member>
        <member name="M:photopay.RecognitionValue.Dispose">
Virtual destructor 
</member>
        <member name="M:photopay.RecognitionValue.op_Assign(photopay.OcrLineRecognitionResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator with OcrLineRecognitinResult data 
</member>
        <member name="M:photopay.RecognitionValue.op_Assign(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator with quadrangle data 
</member>
        <member name="M:photopay.RecognitionValue.op_Assign(System.Boolean!System.Runtime.CompilerServices.IsConst)">
Assignment operator with boolean data 
</member>
        <member name="M:photopay.RecognitionValue.op_Assign(photomath.PhotoMathResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator with PhotoMath data 
</member>
        <member name="M:photopay.RecognitionValue.op_Assign(ocr.OcrResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator with OCR data 
</member>
        <member name="M:photopay.RecognitionValue.op_Assign(barcode.BarcodeDetailedData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator with barcode data 
</member>
        <member name="M:photopay.RecognitionValue.op_Assign(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Assignment operator with c-string data 
</member>
        <member name="M:photopay.RecognitionValue.op_Assign(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator with string data 
</member>
        <member name="M:photopay.RecognitionValue.op_Assign(System.Int32!System.Runtime.CompilerServices.IsConst)">
Assignment operator with integer data 
</member>
        <member name="M:photopay.RecognitionValue.op_Assign(photopay.RecognitionValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator 
</member>
        <member name="M:photopay.RecognitionValue.#ctor(photopay.RecognitionValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor 
</member>
        <member name="M:photopay.RecognitionValue.#ctor(photopay.OcrLineRecognitionResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Vreates value with OcrLineRecognitionResult 
</member>
        <member name="M:photopay.RecognitionValue.#ctor(mv.Quadrangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates value with Quadrangle data 
</member>
        <member name="M:photopay.RecognitionValue.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst)">
Creates value with boolean data 
</member>
        <member name="M:photopay.RecognitionValue.#ctor(photomath.PhotoMathResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates value with PhotoMath data 
</member>
        <member name="M:photopay.RecognitionValue.#ctor(ocr.OcrResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates value with OCR data 
</member>
        <member name="M:photopay.RecognitionValue.#ctor(barcode.BarcodeDetailedData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates value with barcode data 
</member>
        <member name="M:photopay.RecognitionValue.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Creates value with c-string data 
</member>
        <member name="M:photopay.RecognitionValue.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates value with string data 
</member>
        <member name="M:photopay.RecognitionValue.#ctor(System.Int32!System.Runtime.CompilerServices.IsConst)">
Creates value with integer data 
</member>
        <member name="M:photopay.RecognitionValue.#ctor">
Default constructor used in STL containers 
</member>
        <member name="T:photopay.RecognitionValue">
Value stored in Recognition data map

</member>
        <member name="M:photopay.ScanDataSanitizer.sanitizeString(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method performs sanitization

@param value   value which needs to be sanitized
@param key     key for the given value (e.g. account number, payment description

</member>
        <member name="M:photopay.ScanDataSanitizer.sanitizeChars(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the string with removed all the chars which are not in allowed chars string

</member>
        <member name="M:photopay.ScanDataSanitizer.sanitizeLength(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Returns the string with given length, but makes sure that truncation
is performed on UTF8 string, i.e. no multibyte chars are split

</member>
        <member name="T:photopay.ScanDataSanitizer">
Class used for sanitizing of data obtained by scanning

</member>
        <member name="M:photopay.ExtractionResult.setEmpty(System.Boolean)">
Sets the isEmpty property 

</member>
        <member name="M:photopay.ExtractionResult.isEmpty">
Returns true of the result is empty, i.e. nothing was found for this element in extraction process

</member>
        <member name="M:photopay.ExtractionResult.getConfidenceLevel">
Confidence level getter

</member>
        <member name="M:photopay.ExtractionResult.getName">
Name getter

</member>
        <member name="M:photopay.ExtractionResult.setValue(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Value setter 
</member>
        <member name="M:photopay.ExtractionResult.getValue">
Value getter

</member>
        <member name="M:photopay.ExtractionResult.op_LessThan(photopay.ExtractionResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Comparison operator
@return

</member>
        <member name="M:photopay.ExtractionResult.op_Assign(photopay.ExtractionResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator

</member>
        <member name="M:photopay.ExtractionResult.#ctor(photopay.ExtractionResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor

</member>
        <member name="M:photopay.ExtractionResult.Dispose">
NOTE: isEmpty must be default set to false because when performing multiple
      reads if one element is successfuly read the first time, next time
      it won't be read and then empty result will be added to history.
      To prevent history confusion, default extraction result must be
      defined as non-empty!

Frees the memory used to store recognition result

</member>
        <member name="M:photopay.ExtractionResult.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ocr.Box!System.Ru">
Creates an empty recognition result

</member>
        <member name="F:photopay.ExtractionResult.position_">
position of the result

</member>
        <member name="F:photopay.ExtractionResult.resultName_">
string name for result

</member>
        <member name="F:photopay.ExtractionResult.empty_">
Flag indicating the extraction found nothing

</member>
        <member name="F:photopay.ExtractionResult.confidenceLevel_">
Confidence level

</member>
        <member name="F:photopay.ExtractionResult.resultValue_">
string value for result

</member>
        <member name="T:photopay.ExtractionResult">
Encapsulates the recognition result

</member>
        <member name="M:ocr.Box.logi">
Log function

</member>
        <member name="F:ocr.Box.height_">
Height of the box

</member>
        <member name="F:ocr.Box.width_">
Width of the box

</member>
        <member name="F:ocr.Box.y_">
Y coordinate of upper left point

</member>
        <member name="F:ocr.Box.x_">
X coordinate of upper left point

</member>
        <member name="M:ocr.Box.Dispose">
Destructor

</member>
        <member name="M:ocr.Box.isEmpty">
Returns if the box is empty, i.e. NULL box;
@return

</member>
        <member name="M:ocr.Box.getAlignmentMeasureForMultipleBoxes(std.vector&lt;ocr.Box&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;ocr.Box&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method is a generalization of getAlignmentMeasure and works for arbitrary number of boxes
@param first
@param second
@return

</member>
        <member name="M:ocr.Box.getAlignmentMeasure(ocr.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method returns a double from 0 to 1 which correspond to how well are the boxes aligned.

 @param other
 @return

</member>
        <member name="M:ocr.Box.relativeTranslate(System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)">
Returns the box translated by given relative factors.
@param xFactor factor of width used for horizontal translation
@param yFactor factor of height used for vertical translation
@return

</member>
        <member name="M:ocr.Box.getSpreadBox(System.Single!System.Runtime.CompilerServices.IsConst)">
 Returns the box spread by a constant factor in all directions

 @param spreadFactor
 @return

</member>
        <member name="M:ocr.Box.getHorizontalSlice(System.UInt32,System.UInt32)">
Gets the horizontal slice of box.
+-----------------+
|                 |
|                 |
|                 |
|-----------------|
|                 |
+-----------------+
@param sliceIndex
@param numSlices
@return

</member>
        <member name="M:ocr.Box.getVerticalSlice(System.UInt32,System.UInt32)">
Gets the vertical slice of box.
+----------------+
|    |           |
|    |           |
+----------------+
@param sliceIndex
@param numSlices
@return

</member>
        <member name="M:ocr.Box.getCorners">
 Returns vector with corner points

 @return

</member>
        <member name="M:ocr.Box.isSubsetOf(ocr.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Returns true if this box is a subset of the other box

 @param other
 @return

</member>
        <member name="M:ocr.Box.getOverlappingBox(ocr.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Method returns a new Box which represents overlapping area of this box and other
 @param other

 @return overlapping box

</member>
        <member name="M:ocr.Box.getCenter">
 Returns the center of the box

 @return

</member>
        <member name="M:ocr.Box.getArea">
 Returns the area of the box

 @return area

</member>
        <member name="M:ocr.Box.op_Equality(ocr.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Comparison operator

</member>
        <member name="M:ocr.Box.op_Addition(ocr.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Plus operator

</member>
        <member name="M:ocr.Box.op_AdditionAssignment(ocr.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Plus equal (increment) operator

</member>
        <member name="M:ocr.Box.op_Assign(ocr.Box*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move-Assignment operator

</member>
        <member name="M:ocr.Box.op_Assign(ocr.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy-Assignent operator

</member>
        <member name="M:ocr.Box.#ctor(ocr.Box*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move constructor

</member>
        <member name="M:ocr.Box.#ctor(ocr.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor

</member>
        <member name="M:ocr.Box.toRectf">
 Converts box to a opencv float rectangle format

 @return

</member>
        <member name="M:ocr.Box.toRect">
 Converts box to a opencv rect format

 @return

</member>
        <member name="M:ocr.Box.#ctor(cv.Rect_&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Creates a box from opencv rect format

 @param rect

</member>
        <member name="M:ocr.Box.#ctor(System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)">
 Constructor

 @param x
 @param y
 @param width
 @param height

</member>
        <member name="F:ocr.Box.emptyHeight">
Height of empty Box 
</member>
        <member name="F:ocr.Box.emptyWidth">
Width of empty Box 
</member>
        <member name="F:ocr.Box.emptyY">
Y coordinate of empty Box 
</member>
        <member name="F:ocr.Box.emptyX">
X coordinate of empty Box 
</member>
        <member name="T:ocr.Box">
Box class.
Has upper left point and size.

</member>
        <member name="M:rapidjson.JsonSerializable.queryObjectMembers(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,std.function&lt;(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;,System.">
Utility method for retrieving member elements from the JSON object.
@param jsonObj           JSON object that will be tested to have required element
                         identified by name.
@param name              Name of the element that should be retrieved.
@param elementHandler    Function that will be called for every element in JSON object.
                         Function should return true if element handling was OK or false
                         if there was an error while handling the element. In case of error,
                         element iteration may stop.
                         Function receives an element, its name in object and ErrorStatus
                         which it can use to report errors.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:rapidjson.JsonSerializable.queryObject(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,std.function&lt;(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;,tagErrorStatus*!System.Runtime.CompilerService">
Utility method for retrieving object elements from the JSON object.
@param jsonObj           JSON object that will be tested to have required element
                         identified by name.
@param name              Name of the element that should be retrieved.
@param objectHandler     Function that will be called for handling object if it exists.
                         Function receives JSON object so it can further process it and
                         ErrorStatus which it can use to report errors.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:rapidjson.JsonSerializable.queryArray(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,std.function&lt;(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;,System.UInt32,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;,tagErrorStatus*!Sys">
Utility method for retrieving array of elements from the JSON object.
@param jsonObj           JSON object that will be tested to have required element array
                         identified by name.
@param name              Name of the element array that should be retrieved.
@param elementHandler    Function that will be called for every element in JSON array.
                         Function should return true if element handling was OK or false
                         if there was an error while handling the element. In case of error,
                         element iteration may stop.
                         Function receives array element, its index in array and ErrorStatus
                         which it can use to report errors.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:rapidjson.JsonSerializable.queryString(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Utility method for retrieving string element of the JSON object.
@param jsonObj           JSON object that will be tested to have required element
                         identified by name.
@param name              Name of the element that should be retrieved.
@param val       [out]   Variable to which result of retrieveal will be saved. If error occurs,
                         existing value will not be changed.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:rapidjson.JsonSerializable.queryUInt64(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt64*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Utility method for retrieving 64-bit unsigned int element of the JSON object.
@param jsonObj           JSON object that will be tested to have required element
                         identified by name.
@param name              Name of the element that should be retrieved.
@param val       [out]   Variable to which result of retrieveal will be saved. If error occurs,
                         existing value will not be changed.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:rapidjson.JsonSerializable.queryInt64(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int64*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Utility method for retrieving 64-bit int element of the JSON object.
@param jsonObj           JSON object that will be tested to have required element
                         identified by name.
@param name              Name of the element that should be retrieved.
@param val       [out]   Variable to which result of retrieveal will be saved. If error occurs,
                         existing value will not be changed.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:rapidjson.JsonSerializable.queryUInt(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Utility method for retrieving unsigned int element of the JSON object.
@param jsonObj           JSON object that will be tested to have required element
                         identified by name.
@param name              Name of the element that should be retrieved.
@param val       [out]   Variable to which result of retrieveal will be saved. If error occurs,
                         existing value will not be changed.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:rapidjson.JsonSerializable.queryInt(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Utility method for retrieving int element of the JSON object.
@param jsonObj           JSON object that will be tested to have required element
                         identified by name.
@param name              Name of the element that should be retrieved.
@param val       [out]   Variable to which result of retrieveal will be saved. If error occurs,
                         existing value will not be changed.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:rapidjson.JsonSerializable.queryBool(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Utility method for retrieving bool element of the JSON object.
@param jsonObj           JSON object that will be tested to have required element
                         identified by name.
@param name              Name of the element that should be retrieved.
@param val       [out]   Variable to which result of retrieveal will be saved. If error occurs,
                         existing value will not be changed.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:rapidjson.JsonSerializable.queryGeneralizedDouble(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Utility method for retrieving double element even if he doesn't have decimal places of the JSON object.
@param jsonObj           JSON object that will be tested to have required element
                         identified by name.
@param name              Name of the element that should be retrieved.
@param val       [out]   Variable to which result of retrieveal will be saved. If error occurs,
                         existing value will not be changed.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:rapidjson.JsonSerializable.queryGeneralizedFloat(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Utility method for retrieving float element even if he doesn't have decimal places of the JSON object.
@param jsonObj           JSON object that will be tested to have required element
                         identified by name.
@param name              Name of the element that should be retrieved.
@param val       [out]   Variable to which result of retrieveal will be saved. If error occurs,
                         existing value will not be changed.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:rapidjson.JsonSerializable.queryFloat(rapidjson.GenericValue&lt;rapidjson.UTF8&lt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tagErrorStatus*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Utility method for retrieving float element of the JSON object.
@param jsonObj           JSON object that will be tested to have required element
                         identified by name.
@param name              Name of the element that should be retrieved.
@param val       [out]   Variable to which result of retrieveal will be saved. If error occurs,
                         existing value will not be changed.
@param status    [out]   If success, status will be set to ERROR_STATUS_SUCCESS, otherwise it
                         will be set to ERROR_STATUS_DESERIALIZATION_FAILED and val will not be changed.
@param mandatory         If set to true and error occurs, it will be logged and status will be set to ERROR_STATUS_DESERIALIZATION_FAILED. Default is true.

</member>
        <member name="M:StringUtils.stringWithCString(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Inits std::string with cString and encoding

</member>
        <member name="M:StringUtils.countOccurrences(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Counts the number of occurrences of string string in string instring.

 @return number of occurrences

</member>
        <member name="M:StringUtils.trimRight(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Trim string from right

</member>
        <member name="M:StringUtils.trimLeft(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Trim string from left

</member>
        <member name="M:StringUtils.trim(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Trim from both ends

</member>
        <member name="M:StringUtils.intToString(System.Int32!System.Runtime.CompilerServices.IsConst)">
Converts integer to string.

</member>
        <member name="M:StringUtils.stringToInt(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts string to integer.
Ignores chars that are not digits.

</member>
        <member name="M:StringUtils.Dispose">
@brief Private destructor

</member>
        <member name="M:StringUtils.#ctor">
@brief Private constructor to prevent instantiation

</member>
        <member name="T:StringUtils">
@brief Utility class for manipulating strings

</member>
        <member name="M:IConv.convert(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts the input string
string should be null terminated
if s-jis is not null terminated or it has
multiple byte chars with null in them this
will not work, or to provide in other way
input buffer length....

</member>
        <member name="M:IConv.Dispose">
Destructor

</member>
        <member name="M:IConv.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Constructor

</member>
        <member name="T:IConv">
 \file

 ZXingRecognizer.hpp

  Created on: Apr 9, 2013
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 PaymentRecognizer.h

  Created on: Feb 13, 2012
      Author: cerovec

 \file

 PaymentData.h

  Created on: Feb 21, 2012
      Author: cerovec

 \file

 StringUtils.h

  Created on: Mar 23, 2012
      Author: cerovec

Charset conversion utility


 \file

 PaymentRecognizer.h

  Created on: Feb 13, 2012
      Author: cerovec

 \file

 PaymentData.h

  Created on: Feb 21, 2012
      Author: cerovec

 \file

 StringUtils.h

  Created on: Mar 23, 2012
      Author: cerovec

Charset conversion utility


 \file

 CommonUtil.h

  Created on: Jan, 2014
      Author: dodo, Ljudevit

 Copyright (c)2014 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

Name of folder in which to save debug images

Allow saving of files

Whether image saving is allowed

if saving image is allowed, save all images

if image saving is allowed, save all images
* generated by scanner (no matter if detection was
* successful or not)

if image saving is allowed, save results of
* image dewarping

if image saving is allowed, save results of
* image dewarping with marked OCR char positions

if defined, XML serialized OCR results
* will be saved

Save log output to a file in isolated storage

 \file

 PaymentData.h

  Created on: Feb 21, 2012
      Author: cerovec

 \file

 StringUtils.h

  Created on: Mar 23, 2012
      Author: cerovec

Charset conversion utility


 \file

 PaymentData.h

  Created on: Feb 21, 2012
      Author: cerovec

 \file

 StringUtils.h

  Created on: Mar 23, 2012
      Author: cerovec

Charset conversion utility


 \file

 StringUtils.h

  Created on: Mar 23, 2012
      Author: cerovec

Charset conversion utility


 \file

 wchar.h

  Created on: Nov 28, 2012
      Author: dodo

 Copyright (c)2012 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 StringUtils.h

  Created on: Mar 23, 2012
      Author: cerovec

Charset conversion utility

</member>
        <member name="M:Microblink.BarcodeDetailedData.GetAllData">
            <summary>
Returns all barcode detailed data merged in one byte array
</summary>
BarcodeDetailedData *
</member>
        <member name="P:Microblink.BarcodeDetailedData.Elements">
            <summary>
Collection of barcode elements
</summary>
        </member>
        <member name="T:Microblink.BarcodeDetailedData">
            <summary>
Collection of text or byte elements that represent results of barcode scanning
</summary>
        </member>
        <member name="P:Microblink.BarcodeElement.Text">
            <summary>
Element data represented by string.
</summary>
            <remarks>
This property is null if barcode element type is BYTE_DATA.
</remarks>
        </member>
        <member name="P:Microblink.BarcodeElement.Bytes">
            <summary>
Element data in byte array form.
</summary>
        </member>
        <member name="P:Microblink.BarcodeElement.Type">
            <summary>
Type of barcode element
</summary>
            <remarks>
Can be text or byte data type
</remarks>
        </member>
        <member name="T:Microblink.BarcodeElement">
            <summary>
Barcode element, member of barcode detailed data
</summary>
        </member>
        <member name="T:Microblink.BarcodeElementType">
            <summary>
Type of barcode element in barcode detailed data
</summary>
            <remarks>
Can be text or byte data type
</remarks>
        </member>
        <member name="T:Counted">
 \file

 BarcodeDetailedData.hpp

  Created on: Aug 21, 2013
      Author: dodo

 Copyright (c)2015 MicroBlink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.



  Created on: July 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


  Created on: July 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.



  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.



  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


 \file

 PaymentRecognizerDelegateBridge.hpp

  Created on: Jan, 2014
      Author: Ljudevit

 Copyright (c)2014 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

 \file

 PaymentRecognizer.h

  Created on: Feb 13, 2012
      Author: cerovec



  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.



  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.



  Created on: July 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


  Created on: July 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


  Created on: May 2015
      Author: zivac

 Copyright (c)2015 Microblink Ltd. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

</member>
        <member name="D:I_RPC_HANDLE">
 \file

 RCBarcodeRecognitionData.hpp

  Created on: Jan, 2014
      Author: Ljudevit

 Copyright (c)2014 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


 \file

 RCPaymentRecognizerDelegate.hpp

  Created on: Jan, 2014
      Author: Ljudevit

 Copyright (c)2014 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.


 \file

 PhotoPayComponent.hpp

  Created on: Jan, 2014
      Author: Ljudevit

 Copyright (c)2014 Racuni.hr d.o.o. All rights reserved.

 ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.

</member>
        <member name="T:Microblink.BarcodeType">
            <summary>
Type of barcode scanned
</summary>
        </member>
        <member name="P:Microblink.IRecognitionResult.Elements">
            <summary>
String -&gt; Object map of result elements. 
</summary>
            <remarks> Result data can
be retrieved from this map instead of using the specific
properties in IRecognitionResult implementing classes.
In the instances when specific property is not implemented
the only way of retrieving the data is via this map.
</remarks>
        </member>
        <member name="P:Microblink.IRecognitionResult.Empty">
            <summary>
Indicates if the result is empty
</summary>
        </member>
        <member name="P:Microblink.IRecognitionResult.Valid">
            <summary>
Indicates if the result is valid
</summary>
        </member>
        <member name="T:Microblink.IRecognitionResult">
            <summary>
Base interface for all recognition result classes
</summary>
        </member>
        <!-- Discarding badly formed XML document comment for member 'M:mv.ICameraFrame.getFrameQuality'. -->
        <!-- Discarding badly formed XML document comment for member 'M:mv.ICameraFrame.getFrameQuality'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microblink.RecognitionMode'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microblink.RecognitionMode'. -->
        <!-- Discarding badly formed XML document comment for member 'M:mv.ICameraFrame.getFrameQuality'. -->
        <!-- Discarding badly formed XML document comment for member 'F:mv.AbstractCameraFrame.frameQuality_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microblink.RecognitionMode'. -->
        <!-- Discarding badly formed XML document comment for member 'M:mv.ICameraFrame.getFrameQuality'. -->
        <!-- Discarding badly formed XML document comment for member 'M:mv.ICameraFrame.getFrameQuality'. -->
        <!-- Discarding badly formed XML document comment for member 'M:mv.ICameraFrame.getFrameQuality'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microblink.RecognitionMode'. -->
        <!-- Discarding badly formed XML document comment for member 'F:photopay.CroBarPaymentData.HUB3_CURRENCY_ROW'. -->
        <!-- Discarding badly formed XML document comment for member 'F:mv.AbstractCameraFrame.frameQuality_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microblink.RecognitionMode'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microblink.RecognitionMode'. -->
        <!-- Discarding badly formed XML document comment for member 'M:mv.ICameraFrame.getFrameQuality'. -->
        <!-- Discarding badly formed XML document comment for member 'F:mv.AbstractCameraFrame.frameQuality_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvFloor(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvCeil(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:cv.Vec2b'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.RotatedRect'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.Range'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.KeyPoint.#ctor(cv.Point_<System.Single>,System.Single,System.Single,System.Single,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.Moments'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv._InputArray'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv._OutputArray'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.Mat'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.Mat.#ctor(System.Int32,System.Int32,System.Int32,cv.Scalar_<System.Double>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.Mat.#ctor(cv.Size_<System.Int32>,System.Int32,cv.Scalar_<System.Double>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.Mat.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,cv.Scalar_<System.Double>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.Mat.row(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.Mat.diag(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.Mat.convertTo(cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.Mat.setTo(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.Mat.reshape(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.Mat.isContinuous'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.SparseMat'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.SparseMatConstIterator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.NAryMatIterator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.MatExpr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.abs(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CvFileStorage'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.FileNode'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.FileStorage.writeRaw(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.borderInterpolate(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.convertScaleAbs(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.findNonZero(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.mixChannels(cv.Mat!System.Runtime.CompilerServices.IsConst*,System.UInt32,cv.Mat*,System.UInt32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.flip(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.hconcat(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.hconcat(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.vconcat(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.vconcat(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.bitwise_and(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.absdiff(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.compare(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.min(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.min(cv.UMat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.UMat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.UMat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.max(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.max(cv.UMat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.UMat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.UMat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.pow(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.checkRange(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,cv.Point_<System.Int32>*,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.perspectiveTransform(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.completeSymm(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.determinant(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.eigen(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.dft(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.dct(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.randu(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.PCA'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.RNG'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.kmeans(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.TermCriteria,System.Int32,System.Int32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.Algorithm'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.Algorithm.save(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.setNumThreads(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.alignSize(System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.CommandLineParser'. -->
        <!-- Discarding badly formed XML document comment for member 'D:CvRNG'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CvBox2D.#ctor(CvPoint2D32f,CvSize2D32f,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CvSeqBlock.count'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvInitMatHeader(CvMat*,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvCreateMat(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvScalarToRawData(CvScalar!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvGetNextSparseNode(CvSparseMatIterator*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvGetDims(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvGetMat(System.Void!System.Runtime.CompilerServices.IsConst*,CvMat*,System.Int32*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvReshapeMatND(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Void*,System.Int32,System.Int32,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvReshape(System.Void!System.Runtime.CompilerServices.IsConst*,CvMat*,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvGetRawData(System.Void!System.Runtime.CompilerServices.IsConst*,System.Byte**,System.Int32*,CvSize*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvAnd(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvAndS(System.Void!System.Runtime.CompilerServices.IsConst*,CvScalar,System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvInRange(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvInRangeS(System.Void!System.Runtime.CompilerServices.IsConst*,CvScalar,CvScalar,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:CvCmpFunc'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvWriteReal(CvFileStorage*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvWrite(CvFileStorage*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,CvAttrList)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvGetHashedKey(CvFileStorage*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.DownhillSolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.DownhillSolver.setInitStep(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.ConjGradSolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.solveLP(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.bilateralFilter(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,System.Double,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.boxFilter(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.Size_<System.Int32>,cv.Point_<System.Int32>,System.Boolean,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.blur(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_<System.Int32>,cv.Point_<System.Int32>,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.filter2D(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_<System.Int32>,System.Double,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.Canny(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Int32,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.cornerEigenValsAndVecs(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.HoughLines(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.HoughLinesP(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Int32,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.HoughCircles(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.getRotationMatrix2D(cv.Point_<System.Single>,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.invertAffineTransform(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.integral(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.phaseCorrelate(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.pyrDown(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_<System.Int32>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.getDefaultNewCameraMatrix(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_<System.Int32>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.calcHist(cv.Mat!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst**,System.Boolean,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.equalizeHist(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.pyrMeanShiftFiltering(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Int32,cv.TermCriteria)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.floodFill(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_<System.Int32>,cv.Scalar_<System.Double>,cv.Rect_<System.Int32>*,cv.Scalar_<System.Double>,cv.Scalar_<System.Double>,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.HuMoments(cv.Moments!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.approxPolyDP(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.contourArea(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.minAreaRect(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.minEnclosingCircle(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Point_<System.Single>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.minEnclosingTriangle(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.convexHull(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.isContourConvex(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.fitEllipse(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.fitLine(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.rotatedRectangleIntersection(cv.RotatedRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.RotatedRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.drawContours(cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.Scalar_<System.Double>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.Point_<System.Int32>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.getTextSize(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,System.Int32,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.LineIterator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvIntegral(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void*,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvConvertMaps(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvCreateStructuringElementEx(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvGetRectSubPix(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvPoint2D32f)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvGetQuadrangleSubPix(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,CvMat!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvCreateHist(System.Int32,System.Int32*,System.Int32,System.Single**,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvRectangle(System.Void*,CvPoint,CvPoint,CvScalar,System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvClipLine(CvSize,CvPoint*,CvPoint*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.inpaint(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.fastNlMeansDenoising(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.fastNlMeansDenoising(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<System.Single>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.fastNlMeansDenoisingMulti(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.fastNlMeansDenoisingMulti(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,std.vector<System.Single>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.createTonemap(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.calcOpticalFlowFarneback(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.estimateRigidTransform(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.KalmanFilter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.KalmanFilter.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.MSER'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.DescriptorMatcher.match(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<cv.DMatch>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CvHaarClassifierCascade'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.findHomography(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.projectPoints(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.Compile'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.solvePnP(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.solvePnPRansac(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Int32,System.Single,System.Double,cv._OutputArray!Syste'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.findChessboardCorners(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_<System.Int32>,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.findCirclesGrid(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_<System.Int32>,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.Ptr<cv.Feature2D>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.calibrateCamera(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_<System.Int32>,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv.TermCriteria)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.stereoRectify(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_<System.Int32>,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.findFundamentalMat(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,System.Double,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.findEssentialMat(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv.Point_<System.Double>,System.Int32,System.Double,System.Double,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.recoverPose(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv.Point_<System.Double>,cv._InputOutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.computeCorrespondEpilines(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.correctMatches(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.fisheye.projectPoints(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Affine3<System.Double>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.fisheye.distortPoints(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.fisheye.undistortPoints(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.imwrite(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<System.Int32>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.VideoCapture.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.VideoCapture.grab'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.setMouseCallback(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,=FUNC:System.Void(System.Int32,System.Int32,System.Int32,System.Int32,System.Void*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.setOpenGlDrawCallback(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,=FUNC:System.Void(System.Void*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.createButton(cv.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,=FUNC:System.Void(System.Int32,System.Void*),System.Void*,System.Int32,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:cv.ml.ParamGrid.logStep'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.ml.TrainData'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.ml.TrainData.getTrainNormCatResponses'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.ml.TrainData.create(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.ml.KNearest.findNearest(cv._InputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.ml.SVM.KernelTypes'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.ml.EM.create'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.ml.DTrees.getMaxCategories'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.ml.DTrees.create'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.ml.Boost.create'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.ml.ANN_MLP.getRpropDWMinus'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.ml.ANN_MLP.create'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microblink.RecognitionMode'. -->
        <!-- Discarding badly formed XML document comment for member 'M:mv.ICameraFrame.getFrameQuality'. -->
        <!-- Discarding badly formed XML document comment for member 'P:Microblink.USDLRecognitionResult.kNameSuffix'. -->
        <!-- Discarding badly formed XML document comment for member 'P:Microblink.USDLRecognitionResult.kAKAMiddleName'. -->
        <!-- Discarding badly formed XML document comment for member 'M:mv.ICameraFrame.getFrameQuality'. -->
        <!-- Discarding badly formed XML document comment for member 'F:mv.AbstractCameraFrame.frameQuality_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microblink.RecognitionMode'. -->
    </members>
</doc>